---
layout: "default"
title: "Type Aliases"
description: "Documentation for global type aliases in the Swift language."
root: "/v3.1"
---

<div class="declaration">
<code class="language-swift">typealias AnyClass = AnyObject.Type</code>
<div class="comment">
    <p>The protocol to which all class types implicitly conform.</p>

<p>You can use the <code>AnyClass</code> protocol as the concrete type for an instance of
any class. When you do, all known <code>@objc</code> class methods and properties are
available as implicitly unwrapped optional methods and properties,
respectively. For example:</p>

<pre><code class="language-swift">class IntegerRef {
    @objc class func getDefaultValue() -&gt; Int {
        return 42
    }
}

func getDefaultValue(_ c: AnyClass) -&gt; Int? {
    return c.getDefaultValue?()
}</code></pre>

<p>The <code>getDefaultValue(_:)</code> function uses optional chaining to safely call
the implicitly unwrapped class method on <code>c</code>. Calling the function with
different class types shows how the <code>getDefaultValue()</code> class method is
only conditionally available.</p>

<pre><code class="language-swift">print(getDefaultValue(IntegerRef.self))
// Prints &quot;Optional(42)&quot;

print(getDefaultValue(NSString.self))
// Prints &quot;nil&quot;</code></pre>

<p><strong>See Also:</strong> <code>AnyObject</code></p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias ArrayLiteralConvertible = ExpressibleByArrayLiteral</code>
</div>
<div class="declaration">
<code class="language-swift">typealias BidirectionalIndexable = _BidirectionalIndexable</code>
<div class="comment">
    <p>A type that provides subscript access to its elements, with bidirectional
index traversal.</p>

<p>In most cases, it&#39;s best to ignore this protocol and use the
<code>BidirectionalCollection</code> protocol instead, because it has a more complete
interface.</p>

<p><em>Deprecated:</em> it will be removed in Swift 4.0.  Please use &#39;BidirectionalCollection&#39; instead.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias BooleanLiteralConvertible = ExpressibleByBooleanLiteral</code>
</div>
<div class="declaration">
<code class="language-swift">typealias BooleanLiteralType = Bool</code>
<div class="comment">
    <p>The default type for an otherwise-unconstrained Boolean literal.</p>

<p>When you create a constant or variable using one of the Boolean literals
<code>true</code> or <code>false</code>, the resulting type is determined by the
<code>BooleanLiteralType</code> alias. For example:</p>

<pre><code class="language-swift">let isBool = true
print(&quot;isBool is a &#39;\(type(of: isBool))&#39;&quot;)
// Prints &quot;isBool is a &#39;Bool&#39;&quot;</code></pre>

<p>The type aliased by <code>BooleanLiteralType</code> must conform to the
<code>ExpressibleByBooleanLiteral</code> protocol.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CBool = Bool</code>
<div class="comment">
    <p>The C &#39;_Bool&#39; and C++ &#39;bool&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CChar = Int8</code>
<div class="comment">
    <p>The C &#39;char&#39; type.</p>

<p>This will be the same as either <code>CSignedChar</code> (in the common
case) or <code>CUnsignedChar</code>, depending on the platform.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CChar16 = UInt16</code>
<div class="comment">
    <p>The C++11 &#39;char16_t&#39; type, which has UTF-16 encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CChar32 = UnicodeScalar</code>
<div class="comment">
    <p>The C++11 &#39;char32_t&#39; type, which has UTF-32 encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CDouble = Double</code>
<div class="comment">
    <p>The C &#39;double&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CFloat = Float</code>
<div class="comment">
    <p>The C &#39;float&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CInt = Int32</code>
<div class="comment">
    <p>The C &#39;int&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CLong = Int</code>
</div>
<div class="declaration">
<code class="language-swift">typealias CLongLong = Int64</code>
</div>
<div class="declaration">
<code class="language-swift">typealias CShort = Int16</code>
<div class="comment">
    <p>The C &#39;short&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CSignedChar = Int8</code>
<div class="comment">
    <p>The C &#39;signed char&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CUnsignedChar = UInt8</code>
<div class="comment">
    <p>The C &#39;unsigned char&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CUnsignedInt = UInt32</code>
<div class="comment">
    <p>The C &#39;unsigned int&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CUnsignedLong = UInt</code>
<div class="comment">
    <p>The C &#39;unsigned long&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CUnsignedLongLong = UInt64</code>
<div class="comment">
    <p>The C &#39;unsigned long long&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CUnsignedShort = UInt16</code>
<div class="comment">
    <p>The C &#39;unsigned short&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias CWideChar = UnicodeScalar</code>
<div class="comment">
    <p>The C++ &#39;wchar_t&#39; type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias DictionaryIndex&lt;Key,</code>
</div>
<div class="declaration">
<code class="language-swift">typealias DictionaryLiteralConvertible = ExpressibleByDictionaryLiteral</code>
</div>
<div class="declaration">
<code class="language-swift">typealias ExpressibleByStringInterpolation</code>
<div class="comment">
    <p>A type that can be initialized by string interpolation with a string
literal that includes expressions.</p>

<p>Use string interpolation to include one or more expressions in a string
literal, wrapped in a set of parentheses and prefixed by a backslash. For
example:</p>

<pre><code class="language-swift">let price = 2
let number = 3
let message = &quot;One cookie: $\(price), \(number) cookies: $\(price * number).&quot;
print(message)
// Prints &quot;One cookie: $2, 3 cookies: $6.&quot;</code></pre>

<h1>Conforming to the ExpressibleByStringInterpolation Protocol</h1>

<p>To use string interpolation to initialize instances of your custom type,
implement the required initializers for <code>ExpressibleByStringInterpolation</code>
conformance. String interpolation is a multiple-step initialization
process. When you use string interpolation, the following steps occur:</p>

<ol><li>The string literal is broken into pieces. Each segment of the string
literal before, between, and after any included expressions, along with
the individual expressions themselves, are passed to the
<code>init(stringInterpolationSegment:)</code> initializer.</li><li>The results of those calls are passed to the
<code>init(stringInterpolation:)</code> initializer in the order in which they
appear in the string literal.</li></ol>

<p>In other words, initializing the <code>message</code> constant in the example above
using string interpolation is equivalent to the following code:</p>

<pre><code class="language-swift">let message = String(stringInterpolation:
      String(stringInterpolationSegment: &quot;One cookie: $&quot;),
      String(stringInterpolationSegment: price),
      String(stringInterpolationSegment: &quot;, &quot;),
      String(stringInterpolationSegment: number),
      String(stringInterpolationSegment: &quot; cookies: $&quot;),
      String(stringInterpolationSegment: price * number),
      String(stringInterpolationSegment: &quot;.&quot;))</code></pre>

<p><em>Deprecated:</em> it will be replaced or redesigned in Swift 4.0.  Instead of conforming to &#39;ExpressibleByStringInterpolation&#39;, consider adding an &#39;init(_:String)&#39;.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias ExtendedGraphemeClusterLiteralConvertible = ExpressibleByExtendedGraphemeClusterLiteral</code>
</div>
<div class="declaration">
<code class="language-swift">typealias ExtendedGraphemeClusterType = String</code>
<div class="comment">
    <p>The default type for an otherwise-unconstrained Unicode extended
grapheme cluster literal.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias Float32 = Float</code>
<div class="comment">
    <p>A 32-bit floating point type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias Float64 = Double</code>
<div class="comment">
    <p>A 64-bit floating point type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias FloatLiteralConvertible = ExpressibleByFloatLiteral</code>
</div>
<div class="declaration">
<code class="language-swift">typealias FloatLiteralType = Double</code>
<div class="comment">
    <p>The default type for an otherwise-unconstrained floating point literal.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias Indexable = _Indexable</code>
<div class="comment">
    <p>A type that provides subscript access to its elements, with forward index
traversal.</p>

<p>In most cases, it&#39;s best to ignore this protocol and use the <code>Collection</code>
protocol instead, because it has a more complete interface.</p>

<p><em>Deprecated:</em> it will be removed in Swift 4.0.  Please use &#39;Collection&#39; instead.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias IndexableBase = _IndexableBase</code>
<div class="comment">
    <p>A type that provides subscript access to its elements, with forward
index traversal.</p>

<p>In most cases, it&#39;s best to ignore this protocol and use the <code>Collection</code>
protocol instead, because it has a more complete interface.</p>

<p><em>Deprecated:</em> it will be removed in Swift 4.0.  Please use &#39;Collection&#39; instead.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias IntMax = Int64</code>
<div class="comment">
    <p>The largest native signed integer type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias IntegerLiteralConvertible = ExpressibleByIntegerLiteral</code>
</div>
<div class="declaration">
<code class="language-swift">typealias IntegerLiteralType = Int</code>
<div class="comment">
    <p>The default type for an otherwise-unconstrained integer literal.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias MutableIndexable = _MutableIndexable</code>
<div class="comment">
    <p>A type that provides subscript access to its elements.</p>

<p>In most cases, it&#39;s best to ignore this protocol and use the
<code>MutableCollection</code> protocol instead, because it has a more complete
interface.</p>

<p><em>Deprecated:</em> it will be removed in Swift 4.0.  Please use &#39;MutableCollection&#39; instead.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias NilLiteralConvertible = ExpressibleByNilLiteral</code>
</div>
<div class="declaration">
<code class="language-swift">typealias RandomAccessIndexable = _RandomAccessIndexable</code>
<div class="comment">
    <p>A collection that supports efficient random-access index traversal.</p>

<p>In most cases, it&#39;s best to ignore this protocol and use the
<code>RandomAccessCollection</code> protocol instead, because it has a more complete
interface.</p>

<p><em>Deprecated:</em> it will be removed in Swift 4.0.  Please use &#39;RandomAccessCollection&#39; instead.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias RangeReplaceableIndexable = _RangeReplaceableIndexable</code>
<div class="comment">
    <p>A type that supports replacement of an arbitrary subrange of elements with
the elements of another collection.</p>

<p>In most cases, it&#39;s best to ignore this protocol and use the
<code>RangeReplaceableCollection</code> protocol instead, because it has a more
complete interface.</p>

<p><em>Deprecated:</em> it will be removed in Swift 4.0.  Please use &#39;RandomAccessCollection&#39; instead.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias SetIndex&lt;Element&gt; = Set&lt;Element&gt;.Index</code>
</div>
<div class="declaration">
<code class="language-swift">typealias StringInterpolationConvertible = ExpressibleByStringInterpolation</code>
<div class="comment">
    <p><em>Deprecated:</em> it will be replaced or redesigned in Swift 4.0.  Instead of conforming to &#39;StringInterpolationConvertible&#39;, consider adding an &#39;init(_:String)&#39;.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias StringLiteralConvertible = ExpressibleByStringLiteral</code>
</div>
<div class="declaration">
<code class="language-swift">typealias StringLiteralType = String</code>
<div class="comment">
    <p>The default type for an otherwise-unconstrained string literal.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias UIntMax = UInt64</code>
<div class="comment">
    <p>The largest native unsigned integer type.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias UnfoldFirstSequence&lt;T&gt; = UnfoldSequence&lt;T, (T?, Bool)&gt;</code>
<div class="comment">
    <p>The return type of <code>sequence(first:next:)</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias UnicodeScalarLiteralConvertible = ExpressibleByUnicodeScalarLiteral</code>
</div>
<div class="declaration">
<code class="language-swift">typealias UnicodeScalarType = String</code>
<div class="comment">
    <p>The default type for an otherwise-unconstrained unicode scalar literal.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias Void = ()</code>
<div class="comment">
    <p>The return type of functions that don&#39;t explicitly specify a return type;
an empty tuple (i.e., <code>()</code>).</p>

<p>When declaring a function or method, you don&#39;t need to specify a return
type if no value will be returned. However, the type of a function,
method, or closure always includes a return type, which is <code>Void</code> if
otherwise unspecified.</p>

<p>Use <code>Void</code> or an empty tuple as the return type when declaring a
closure, function, or method that doesn&#39;t return a value.</p>

<pre><code class="language-swift">// No return type declared:
func logMessage(_ s: String) {
    print(&quot;Message: \(s)&quot;)
}

let logger: (String) -&gt; Void = logMessage
logger(&quot;This is a void function&quot;)
// Prints &quot;Message: This is a void function&quot;</code></pre>
</div>
</div>
