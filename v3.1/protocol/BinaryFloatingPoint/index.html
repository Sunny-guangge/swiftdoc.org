---
layout: "default"
title: "BinaryFloatingPoint"
description: "Swift documentation for 'BinaryFloatingPoint': A radix-2 (binary) floating-point type."
keywords: "BinaryFloatingPoint,protocol,swift,documentation,<,<=,==,>,>=,-,-,abs,add,addProduct,adding,addingProduct,advanced,distance,divide,divided,formRemainder,formSquareRoot,formTruncatingRemainder,isEqual,isLess,isLessThanOrEqualTo,isTotallyOrdered,maximum,maximumMagnitude,minimum,minimumMagnitude,multiplied,multiply,negate,negated,remainder,round,rounded,squareRoot,subtract,subtracting,truncatingRemainder,binade,exponentBitCount,exponentBitPattern,significandBitCount,significandBitPattern,significandWidth,magnitude,exponent,floatingPointClass,greatestFiniteMagnitude,infinity,isCanonical,isFinite,isInfinite,isNaN,isNormal,isSignalingNaN,isSubnormal,isZero,leastNonzeroMagnitude,leastNormalMagnitude,nan,nextDown,nextUp,pi,radix,sign,signalingNaN,significand,ulp,ulpOfOne,RawSignificand,RawExponent,Magnitude,FloatLiteralType,IntegerLiteralType,Exponent,Stride"
root: "/v3.1"
---

<div class="intro-declaration"><code class="language-swift">protocol BinaryFloatingPoint</code></div>

<div class="discussion comment">
    <p>A radix-2 (binary) floating-point type.</p>

<p>The <code>BinaryFloatingPoint</code> protocol extends the <code>FloatingPoint</code> protocol
with operations specific to floating-point binary types, as defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>. <code>BinaryFloatingPoint</code> is implemented in
the standard library by <code>Float</code>, <code>Double</code>, and <code>Float80</code> where available.</p>

<p><strong>See Also:</strong> <code>FloatingPoint</code></p>
</div>

<table class="standard">
<tr>
<th id="inheritance">Inheritance</th>
<td>
<code class="inherits">AbsoluteValuable, Arithmetic, Comparable, Equatable, ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral, FloatingPoint, SignedNumber, Strideable</code>
<span class="viz"><a href="hierarchy/">View Protocol Hierarchy &rarr;</a></span>
</td>
</tr>

<tr>
<th id="aliases">Associated Types</th>
<td>
<span id="aliasesmark"></span>
<div class="declaration">
<code class="language-swift">RawSignificand : UnsignedInteger</code>
<div class="comment">
    <p>A type that represents the encoded significand of a value.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">RawExponent : UnsignedInteger</code>
<div class="comment">
    <p>A type that represents the encoded exponent of a value.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">Magnitude : Equatable, ExpressibleByIntegerLiteral</code>
</div>
<div class="declaration inherited">
<code class="language-swift">FloatLiteralType</code>
<div class="comment">
    <p>A type that represents a floating-point literal.</p>

<p>Valid types for <code>FloatLiteralType</code> are <code>Float</code>, <code>Double</code>, and <code>Float80</code>
where available.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">IntegerLiteralType</code>
<div class="comment">
    <p>A type that represents an integer literal.</p>

<p>The standard library integer and floating-point types are all valid types
for <code>IntegerLiteralType</code>.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">Exponent : SignedInteger</code>
<div class="comment">
    <p>A type that represents any written exponent.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">Stride : SignedNumber</code>
<div class="comment">
    <p>A type that represents the distance between two values of <code>Self</code>.</p>
</div>
</div>
</td>
</tr>


<tr>
<th>Import</th>
<td><code class="language-swift">import Swift</code></td>
</tr>

</table>


<h3>Initializers</h3>
<div class="declaration" id="init_-double">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-double">init(<wbr>_: Double)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-double"><div class="p">
    <p>Creates a new instance from the given value, rounded to the closest
possible representation.</p>

<p><strong><code>value</code>:</strong>  A floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Double)</code>

    </div></div>
</div>
<div class="declaration" id="init_-float">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-float">init(<wbr>_: Float)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-float"><div class="p">
    <p>Creates a new instance from the given value, rounded to the closest
possible representation.</p>

<p><strong><code>value</code>:</strong>  A floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Float)</code>

    </div></div>
</div>
<div class="declaration" id="init_-float80">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-float80">init(<wbr>_: Float80)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-float80"><div class="p">
    <p>Creates a new instance from the given value, rounded to the closest
possible representation.</p>

<p><strong><code>value</code>:</strong>  A floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Float80)</code>

    </div></div>
</div>
<div class="declaration" id="init-sign_exponentbitpattern_significandbitpattern_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-sign_exponentbitpattern_significandbitpattern_">init(<wbr>sign:<wbr>exponentBitPattern:<wbr>significandBitPattern:)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init-sign_exponentbitpattern_significandbitpattern_"><div class="p">
    <p>Creates a new instance from the specified sign and bit patterns.</p>

<p>The values passed as <code>exponentBitPattern</code> and <code>significandBitPattern</code> are
interpreted in the binary interchange format defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>sign:</strong> The sign of the new value.
  <strong>exponentBitPattern:</strong> The bit pattern to use for the exponent field of
    the new value.
  <strong>significandBitPattern:</strong> The bit pattern to use for the significand
    field of the new value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(sign: FloatingPointSign, exponentBitPattern: Self.RawExponent, significandBitPattern: Self.RawSignificand)</code>

    </div></div>
</div>
<div class="declaration inherited" id="init-floatliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-floatliteral_">init(<wbr>floatLiteral:)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init-floatliteral_"><div class="p">
    <p>Creates an instance initialized to the specified floating-point value.</p>

<p>Do not call this initializer directly. Instead, initialize a variable or
constant using a floating-point literal. For example:</p>

<pre><code class="language-swift">let x = 21.5</code></pre>

<p>In this example, the assignment to the <code>x</code> constant calls this
floating-point literal initializer behind the scenes.</p>

<p><strong><code>value</code>:</strong>  The value to create.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(floatLiteral value: Self.FloatLiteralType)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/ExpressibleByFloatLiteral/"><code>ExpressibleByFloatLiteral</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-integerliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-integerliteral_">init(<wbr>integerLiteral:)</a><div class="comment collapse" id="comment-init-integerliteral_"><div class="p">
    <p>Creates an instance initialized to the specified integer value.</p>

<p>Do not call this initializer directly. Instead, initialize a variable or
constant using an integer literal. For example:</p>

<pre><code class="language-swift">let x = 23</code></pre>

<p>In this example, the assignment to the <code>x</code> constant calls this integer
literal initializer behind the scenes.</p>

<p><strong><code>value</code>:</strong>  The value to create.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(integerLiteral value: Self.IntegerLiteralType)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/ExpressibleByIntegerLiteral/"><code>ExpressibleByIntegerLiteral</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int">init(<wbr>_: Int)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-int"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int8">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int8">init(<wbr>_: Int8)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-int8"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int8)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int16">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int16">init(<wbr>_: Int16)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-int16"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int16)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int32">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int32">init(<wbr>_: Int32)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-int32"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int32)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int64">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int64">init(<wbr>_: Int64)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-int64"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int64)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint">init(<wbr>_: UInt)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-uint"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint8">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint8">init(<wbr>_: UInt8)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-uint8"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt8)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint16">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint16">init(<wbr>_: UInt16)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-uint16"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt16)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint32">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint32">init(<wbr>_: UInt32)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-uint32"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt32)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint64">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint64">init(<wbr>_: UInt64)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init_-uint64"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt64)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-sign_exponent_significand_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-sign_exponent_significand_">init(<wbr>sign:<wbr>exponent:<wbr>significand:)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init-sign_exponent_significand_"><div class="p">
    <p>Creates a new value from the given sign, exponent, and significand.</p>

<p>The following example uses this initializer to create a new <code>Double</code>
instance. <code>Double</code> is a binary floating-point type that has a radix of
<code>2</code>.</p>

<pre><code class="language-swift">let x = Double(sign: .plus, exponent: -2, significand: 1.5)
// x == 0.375</code></pre>

<p>This initializer is equivalent to the following calculation, where <code>**</code>
is exponentiation, computed as if by a single, correctly rounded,
floating-point operation:</p>

<pre><code class="language-swift">let sign: FloatingPointSign = .plus
let exponent = -2
let significand = 1.5
let y = (sign == .minus ? -1 : 1) * significand * Double.radix ** exponent
// y == 0.375</code></pre>

<p>As with any basic operation, if this value is outside the representable
range of the type, overflow or underflow occurs, and zero, a subnormal
value, or infinity may result. In addition, there are two other edge
cases:</p>

<ul><li>If the value you pass to <code>significand</code> is zero or infinite, the result
is zero or infinite, regardless of the value of <code>exponent</code>.</li><li>If the value you pass to <code>significand</code> is NaN, the result is NaN.</li></ul>

<p>For any floating-point value <code>x</code> of type <code>F</code>, the result of the following
is equal to <code>x</code>, with the distinction that the result is canonicalized
if <code>x</code> is in a noncanonical encoding:</p>

<pre><code class="language-swift">let x0 = F(sign: x.sign, exponent: x.exponent, significand: x.significand)</code></pre>

<p>This initializer implements the <code>scaleB</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE
754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>sign:</strong> The sign to use for the new value.
  <strong>exponent:</strong> The new value&#39;s exponent.
  <strong>significand:</strong> The new value&#39;s significand.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(sign: FloatingPointSign, exponent: Self.Exponent, significand: Self)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-signof_magnitudeof_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-signof_magnitudeof_">init(<wbr>signOf:<wbr>magnitudeOf:)</a><div class="comment collapse" id="comment-init-signof_magnitudeof_"><div class="p">
    <p>Creates a new floating-point value using the sign of one value and the
magnitude of another.</p>

<p>The following example uses this initializer to create a new <code>Double</code>
instance with the sign of <code>a</code> and the magnitude of <code>b</code>:</p>

<pre><code class="language-swift">let a = -21.5
let b = 305.15
let c = Double(signOf: a, magnitudeOf: b)
print(c)
// Prints &quot;-305.15&quot;</code></pre>

<p>This initializer implements the IEEE 754 <code>copysign</code> operation.</p>

<p><strong>Parameters:</strong>
  <strong>signOf:</strong> A value from which to use the sign. The result of the
    initializer has the same sign as <code>signOf</code>.
  <strong>magnitudeOf:</strong> A value from which to use the magnitude. The result of
    the initializer has the same magnitude as <code>magnitudeOf</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(signOf: Self, magnitudeOf: Self)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>

<h3>Static Variables</h3>
<div class="declaration" id="static-var-exponentbitcount_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-exponentbitcount_-int">static var exponentBitCount: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-exponentbitcount_-int"><div class="p">
    <p>The number of bits used to represent the type&#39;s exponent.</p>

<p>A binary floating-point type&#39;s <code>exponentBitCount</code> imposes a limit on the
range of the exponent for normal, finite values. The <em>exponent bias</em> of
a type <code>F</code> can be calculated as the following, where <code>**</code> is
exponentiation:</p>

<pre><code class="language-swift">let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>

<p>The least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and
the largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved
for subnormals and zeros, and an all-ones exponent is reserved for
infinity and NaN.</p>

<p>For example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives
an exponent bias of <code>127</code> by the calculation above.</p>

<pre><code class="language-swift">let bias = 2 ** (Float.exponentBitCount - 1) - 1
// bias == 127
print(Float.greatestFiniteMagnitude.exponent)
// Prints &quot;127&quot;
print(Float.leastNormalMagnitude.exponent)
// Prints &quot;-126&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">static var exponentBitCount: Int { get }</code>

    </div></div>
</div>
<div class="declaration" id="static-var-significandbitcount_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-significandbitcount_-int">static var significandBitCount: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-significandbitcount_-int"><div class="p">
    <p>The available number of fractional significand bits.</p>

<p>For fixed-width floating-point types, this is the actual number of
fractional significand bits.</p>

<p>For extensible floating-point types, <code>significandBitCount</code> should be the
maximum allowed significand width (without counting any leading integral
bit of the significand). If there is no upper limit, then
<code>significandBitCount</code> should be <code>Int.max</code>.</p>

<p>Note that <code>Float80.significandBitCount</code> is 63, even though 64 bits are
used to store the significand in the memory representation of a
<code>Float80</code> (unlike other floating-point types, <code>Float80</code> explicitly
stores the leading integral significand bit, but the
<code>BinaryFloatingPoint</code> APIs provide an abstraction so that users don&#39;t
need to be aware of this detail).</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var significandBitCount: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="static-var-greatestfinitemagnitude_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-greatestfinitemagnitude_-self">static var greatestFiniteMagnitude: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-greatestfinitemagnitude_-self"><div class="p">
    <p>The greatest finite number representable by this type.</p>

<p>This value compares greater than or equal to all finite numbers, but less
than <code>infinity</code>.</p>

<p>This value corresponds to type-specific C macros such as <code>FLT_MAX</code> and
<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because
<code>infinity</code> is greater than this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var greatestFiniteMagnitude: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-infinity_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-infinity_-self">static var infinity: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-infinity_-self"><div class="p">
    <p>Positive infinity.</p>

<p>Infinity compares greater than all finite numbers and equal to other
infinite values.</p>

<pre><code class="language-swift">let x = Double.greatestFiniteMagnitude
let y = x * 2
// y == Double.infinity
// y &gt; x</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">static var infinity: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-leastnonzeromagnitude_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-leastnonzeromagnitude_-self">static var leastNonzeroMagnitude: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-leastnonzeromagnitude_-self"><div class="p">
    <p>The least positive number.</p>

<p>This value compares less than or equal to all positive numbers, but
greater than zero. If the type supports subnormal values,
<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;
otherwise they are equal.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var leastNonzeroMagnitude: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-leastnormalmagnitude_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-leastnormalmagnitude_-self">static var leastNormalMagnitude: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-leastnormalmagnitude_-self"><div class="p">
    <p>The least positive normal number.</p>

<p>This value compares less than or equal to all positive normal numbers.
There may be smaller positive numbers, but they are <em>subnormal</em>, meaning
that they are represented with less precision than normal numbers.</p>

<p>This value corresponds to type-specific C macros such as <code>FLT_MIN</code> and
<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because
subnormals, zeros, and negative numbers are smaller than this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var leastNormalMagnitude: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-nan_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-nan_-self">static var nan: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-nan_-self"><div class="p">
    <p>A quiet NaN (&quot;not a number&quot;).</p>

<p>A NaN compares not equal, not greater than, and not less than every
value, including itself. Passing a NaN to an operation generally results
in NaN.</p>

<pre><code class="language-swift">let x = 1.21
// x &gt; Double.nan == false
// x &lt; Double.nan == false
// x == Double.nan == false</code></pre>

<p>Because a NaN always compares not equal to itself, to test whether a
floating-point value is NaN, use its <code>isNaN</code> property instead of the
equal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.</p>

<pre><code class="language-swift">let y = x + Double.nan
print(y == Double.nan)
// Prints &quot;false&quot;
print(y.isNaN)
// Prints &quot;true&quot;</code></pre>

<p><strong>See Also:</strong> <code>isNaN</code>, <code>signalingNaN</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var nan: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-pi_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-pi_-self">static var pi: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-pi_-self"><div class="p">
    <p>The mathematical constant pi.</p>

<p>This value should be rounded toward zero to keep user computations with
angles from inadvertently ending up in the wrong quadrant. A type that
conforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at
its best possible precision.</p>

<pre><code class="language-swift">print(Double.pi)
// Prints &quot;3.14159265358979&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">static var pi: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-radix_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-radix_-int">static var radix: Int</a><div class="comment collapse" id="comment-static-var-radix_-int"><div class="p">
    <p>The radix, or base of exponentiation, for a floating-point type.</p>

<p>The magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated
by using the following formula, where <code>**</code> is exponentiation:</p>

<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent</code></pre>

<p>A conforming type may use any integer radix, but values other than 2 (for
binary floating-point types) or 10 (for decimal floating-point types)
are extraordinarily rare in practice.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var radix: Int { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-signalingnan_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-signalingnan_-self">static var signalingNaN: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-signalingnan_-self"><div class="p">
    <p>A signaling NaN (&quot;not a number&quot;).</p>

<p>The default IEEE 754 behavior of operations involving a signaling NaN is
to raise the Invalid flag in the floating-point environment and return a
quiet NaN.</p>

<p>Operations on types conforming to the <code>FloatingPoint</code> protocol should
support this behavior, but they might also support other options. For
example, it would be reasonable to implement alternative operations in
which operating on a signaling NaN triggers a runtime error or results
in a diagnostic for debugging purposes. Types that implement alternative
behaviors for a signaling NaN must document the departure.</p>

<p>Other than these signaling operations, a signaling NaN behaves in the
same manner as a quiet NaN.</p>

<p><strong>See Also:</strong> <code>nan</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var signalingNaN: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-ulpofone_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-ulpofone_-self">static var ulpOfOne: Self</a><div class="comment collapse" id="comment-static-var-ulpofone_-self"><div class="p">
    <p>The unit in the last place of 1.0.</p>

<p>The positive difference between 1.0 and the next greater representable
number. The <code>ulpOfOne</code> constant corresponds to the C macros
<code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, and others with a similar purpose.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var ulpOfOne: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>

<h3>Instance Variables</h3>
<div class="declaration" id="var-binade_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-binade_-self">var binade: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-binade_-self"><div class="p">
    <p>The floating-point value with the same sign and exponent as this value,
but with a significand of 1.0.</p>

<p>A <em>binade</em> is a set of binary floating-point values that all have the
same sign and exponent. The <code>binade</code> property is a member of the same
binade as this value, but with a unit significand.</p>

<p>In this example, <code>x</code> has a value of <code>21.5</code>, which is stored as
<code>1.34375 * 2**4</code>, where <code>**</code> is exponentiation. Therefore, <code>x.binade</code> is
equal to <code>1.0 * 2**4</code>, or <code>16.0</code>.</p>

<pre><code class="language-swift">let x = 21.5
// x.significand == 1.34375
// x.exponent == 4

let y = x.binade
// y == 16.0
// y.significand == 1.0
// y.exponent == 4</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var binade: Self { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-exponentbitpattern_-self-rawexponent">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-exponentbitpattern_-self-rawexponent">var exponentBitPattern: Self.RawExponent</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-exponentbitpattern_-self-rawexponent"><div class="p">
    <p>The raw encoding of the value&#39;s exponent field.</p>

<p>This value is unadjusted by the type&#39;s exponent bias.</p>

<p><strong>See Also:</strong> <code>exponentBitCount</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">var exponentBitPattern: Self.RawExponent { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-significandbitpattern_-self-rawsignificand">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-significandbitpattern_-self-rawsignificand">var significandBitPattern: Self.RawSignificand</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-significandbitpattern_-self-rawsignificand"><div class="p">
    <p>The raw encoding of the value&#39;s significand field.</p>

<p>The <code>significandBitPattern</code> property does not include the leading
integral bit of the significand, even for types like <code>Float80</code> that
store it explicitly.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var significandBitPattern: Self.RawSignificand { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-significandwidth_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-significandwidth_-int">var significandWidth: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-significandwidth_-int"><div class="p">
    <p>The number of bits required to represent the value&#39;s significand.</p>

<p>If this value is a finite nonzero number, <code>significandWidth</code> is the
number of fractional bits required to represent the value of
<code>significand</code>; otherwise, <code>significandWidth</code> is -1. The value of
<code>significandWidth</code> is always -1 or between zero and
<code>significandBitCount</code>. For example:</p>

<ul><li>For any representable power of two, <code>significandWidth</code> is zero, because
<code>significand</code> is <code>1.0</code>.</li><li>If <code>x</code> is 10, <code>x.significand</code> is <code>1.01</code> in binary, so
<code>x.significandWidth</code> is 2.</li><li>If <code>x</code> is Float.pi, <code>x.significand</code> is <code>1.10010010000111111011011</code> in
binary, and <code>x.significandWidth</code> is 23.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var significandWidth: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="var-magnitude_-self-magnitude">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-magnitude_-self-magnitude">var magnitude: Self.Magnitude</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-magnitude_-self-magnitude"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">var magnitude: Self.Magnitude { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-exponent_-self-exponent">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-exponent_-self-exponent">var exponent: Self.Exponent</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-exponent_-self-exponent"><div class="p">
    <p>The exponent of the floating-point value.</p>

<p>The <em>exponent</em> of a floating-point value is the integer part of the
logarithm of the value&#39;s magnitude. For a value <code>x</code> of a floating-point
type <code>F</code>, the magnitude can be calculated as the following, where <code>**</code>
is exponentiation:</p>

<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent</code></pre>

<p>In the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as
<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.</p>

<pre><code class="language-swift">let y: Double = 21.5
// y.significand == 1.34375
// y.exponent == 4
// Double.radix == 2</code></pre>

<p>The <code>exponent</code> property has the following edge cases:</p>

<ul><li>If <code>x</code> is zero, then <code>x.exponent</code> is <code>Int.min</code>.</li><li>If <code>x</code> is +/-infinity or NaN, then <code>x.exponent</code> is <code>Int.max</code></li></ul>

<p>This property implements the <code>logB</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var exponent: Self.Exponent { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-floatingpointclass_-floatingpointclassification">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-floatingpointclass_-floatingpointclassification">var floatingPointClass: FloatingPointClassification</a><div class="comment collapse" id="comment-var-floatingpointclass_-floatingpointclassification"><div class="p">
    <p>The classification of this value.</p>

<p>A value&#39;s <code>floatingPointClass</code> property describes its &quot;class&quot; as
described by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var floatingPointClass: FloatingPointClassification { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-iscanonical_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-iscanonical_-bool">var isCanonical: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-iscanonical_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance&#39;s representation is in
the canonical form.</p>

<p>The <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a> defines a <em>canonical</em>, or preferred,
encoding of a floating-point value&#39;s representation. Every <code>Float</code> or
<code>Double</code> value is canonical, but noncanonical values of the <code>Float80</code>
type exist, and noncanonical values may exist for other types that
conform to the <code>FloatingPoint</code> protocol.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isCanonical: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-isfinite_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isfinite_-bool">var isFinite: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-isfinite_-bool"><div class="p">
    <p>A Boolean value indicating whether this instance is finite.</p>

<p>All values other than NaN and infinity are considered finite, whether
normal or subnormal.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isFinite: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-isinfinite_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isinfinite_-bool">var isInfinite: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-isinfinite_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is infinite.</p>

<p>Note that <code>isFinite</code> and <code>isInfinite</code> do not form a dichotomy, because
they are not total: If <code>x</code> is <code>NaN</code>, then both properties are <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isInfinite: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-isnan_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isnan_-bool">var isNaN: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-isnan_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is NaN (&quot;not a number&quot;).</p>

<p>Because NaN is not equal to any value, including NaN, use this property
instead of the equal-to operator (<code>==</code>) or not-equal-to operator (<code>!=</code>)
to test whether a value is or is not NaN. For example:</p>

<pre><code class="language-swift">let x = 0.0
let y = x * .infinity
// y is a NaN

// Comparing with the equal-to operator never returns &#39;true&#39;
print(x == Double.nan)
// Prints &quot;false&quot;
print(y == Double.nan)
// Prints &quot;false&quot;

// Test with the &#39;isNaN&#39; property instead
print(x.isNaN)
// Prints &quot;false&quot;
print(y.isNaN)
// Prints &quot;true&quot;</code></pre>

<p>This property is <code>true</code> for both quiet and signaling NaNs.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isNaN: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-isnormal_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isnormal_-bool">var isNormal: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-isnormal_-bool"><div class="p">
    <p>A Boolean value indicating whether this instance is normal.</p>

<p>A <em>normal</em> value is a finite number that uses the full precision
available to values of a type. Zero is neither a normal nor a subnormal
number.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isNormal: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-issignalingnan_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-issignalingnan_-bool">var isSignalingNaN: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-issignalingnan_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is a signaling NaN.</p>

<p>Signaling NaNs typically raise the Invalid flag when used in general
computing operations.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isSignalingNaN: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-issubnormal_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-issubnormal_-bool">var isSubnormal: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-issubnormal_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is subnormal.</p>

<p>A <em>subnormal</em> value is a nonzero number that has a lesser magnitude than
the smallest normal number. Subnormal values do not use the full
precision available to values of a type.</p>

<p>Zero is neither a normal nor a subnormal number. Subnormal numbers are
often called <em>denormal</em> or <em>denormalized</em>---these are different names
for the same concept.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isSubnormal: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-iszero_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-iszero_-bool">var isZero: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-iszero_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is equal to zero.</p>

<p>The <code>isZero</code> property of a value <code>x</code> is <code>true</code> when <code>x</code> represents either
<code>-0.0</code> or <code>+0.0</code>. <code>x.isZero</code> is equivalent to the following comparison:
<code>x == 0.0</code>.</p>

<pre><code class="language-swift">let x = -0.0
x.isZero        // true
x == 0.0        // true</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var isZero: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-nextdown_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-nextdown_-self">var nextDown: Self</a><div class="comment collapse" id="comment-var-nextdown_-self"><div class="p">
    <p>The greatest representable value that compares less than this value.</p>

<p>For any finite value <code>x</code>, <code>x.nextDown</code> is greater than <code>x</code>. For <code>nan</code> or
<code>-infinity</code>, <code>x.nextDown</code> is <code>x</code> itself. The following special cases
also apply:</p>

<ul><li>If <code>x</code> is <code>infinity</code>, then <code>x.nextDown</code> is <code>greatestFiniteMagnitude</code>.</li><li>If <code>x</code> is <code>leastNonzeroMagnitude</code>, then <code>x.nextDown</code> is <code>0.0</code>.</li><li>If <code>x</code> is zero, then <code>x.nextDown</code> is <code>-leastNonzeroMagnitude</code>.</li><li>If <code>x</code> is <code>-greatestFiniteMagnitude</code>, then <code>x.nextDown</code> is <code>-infinity</code>.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var nextDown: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-nextup_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-nextup_-self">var nextUp: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-nextup_-self"><div class="p">
    <p>The least representable value that compares greater than this value.</p>

<p>For any finite value <code>x</code>, <code>x.nextUp</code> is greater than <code>x</code>. For <code>nan</code> or
<code>infinity</code>, <code>x.nextUp</code> is <code>x</code> itself. The following special cases also
apply:</p>

<ul><li>If <code>x</code> is <code>-infinity</code>, then <code>x.nextUp</code> is <code>-greatestFiniteMagnitude</code>.</li><li>If <code>x</code> is <code>-leastNonzeroMagnitude</code>, then <code>x.nextUp</code> is <code>-0.0</code>.</li><li>If <code>x</code> is zero, then <code>x.nextUp</code> is <code>leastNonzeroMagnitude</code>.</li><li>If <code>x</code> is <code>greatestFiniteMagnitude</code>, then <code>x.nextUp</code> is <code>infinity</code>.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var nextUp: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-sign_-floatingpointsign">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-sign_-floatingpointsign">var sign: FloatingPointSign</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-sign_-floatingpointsign"><div class="p">
    <p>The sign of the floating-point value.</p>

<p>The <code>sign</code> property is <code>.minus</code> if the value&#39;s signbit is set, and
<code>.plus</code> otherwise. For example:</p>

<pre><code class="language-swift">let x = -33.375
// x.sign == .minus</code></pre>

<p>Do not use this property to check whether a floating point value is
negative. For a value <code>x</code>, the comparison <code>x.sign == .minus</code> is not
necessarily the same as <code>x &lt; 0</code>. In particular, <code>x.sign == .minus</code> if
<code>x</code> is -0, and while <code>x &lt; 0</code> is always <code>false</code> if <code>x</code> is NaN, <code>x.sign</code>
could be either <code>.plus</code> or <code>.minus</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var sign: FloatingPointSign { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-significand_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-significand_-self">var significand: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-significand_-self"><div class="p">
    <p>The significand of the floating-point value.</p>

<p>The magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated
by using the following formula, where <code>**</code> is exponentiation:</p>

<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent</code></pre>

<p>In the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as
<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.</p>

<pre><code class="language-swift">let y: Double = 21.5
// y.significand == 1.34375
// y.exponent == 4
// Double.radix == 2</code></pre>

<p>If a type&#39;s radix is 2, then for finite nonzero numbers, the significand
is in the range <code>1.0 ..&lt; 2.0</code>. For other values of <code>x</code>, <code>x.significand</code>
is defined as follows:</p>

<ul><li>If <code>x</code> is zero, then <code>x.significand</code> is 0.0.</li><li>If <code>x</code> is infinity, then <code>x.significand</code> is 1.0.</li><li>If <code>x</code> is NaN, then <code>x.significand</code> is NaN.
<strong>Note:</strong> The significand is frequently also called the <em>mantissa</em>, but
significand is the preferred terminology in the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>, to allay confusion with the use of mantissa for
the fractional part of a logarithm.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var significand: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-ulp_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-ulp_-self">var ulp: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-ulp_-self"><div class="p">
    <p>The unit in the last place of this value.</p>

<p>This is the unit of the least significant digit in this value&#39;s
significand. For most numbers <code>x</code>, this is the difference between <code>x</code>
and the next greater (in magnitude) representable number. There are some
edge cases to be aware of:</p>

<ul><li>If <code>x</code> is not a finite number, then <code>x.ulp</code> is NaN.</li><li>If <code>x</code> is very small in magnitude, then <code>x.ulp</code> may be a subnormal
number. If a type does not support subnormals, <code>x.ulp</code> may be rounded
to zero.</li><li><code>greatestFiniteMagnitude.ulp</code> is a finite number, even though the next
greater representable value is <code>infinity</code>.</li></ul>

<p>This quantity, or a related quantity, is sometimes called <em>epsilon</em> or
<em>machine epsilon.</em> Avoid that name because it has different meanings in
different languages, which can lead to confusion, and because it
suggests that it is a good tolerance to use for comparisons, which it
almost never is.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var ulp: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>


<h3>Static Methods</h3>
<div class="declaration inherited" id="func-abs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-abs_">static func abs(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-abs_"><div class="p">
    <p>Returns the absolute value of <code>x</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func abs(_ x: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/AbsoluteValuable/"><code>AbsoluteValuable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-maximum__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-maximum__">static func maximum(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-maximum__"><div class="p">
    <p>Returns the greater of the two given values.</p>

<p>This method returns the maximum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>maximum(x, y)</code> is <code>x</code> if <code>x &gt; y</code>, <code>y</code> if <code>x &lt;= y</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>

<pre><code class="language-swift">Double.maximum(10.0, -25.0)
// 10.0
Double.maximum(10.0, .nan)
// 10.0
Double.maximum(.nan, -25.0)
// -25.0
Double.maximum(.nan, .nan)
// nan</code></pre>

<p>The <code>maximum</code> method implements the <code>maxNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> The greater of <code>x</code> and <code>y</code>, or whichever is a number if the
  other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func maximum(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-maximummagnitude__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-maximummagnitude__">static func maximumMagnitude(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-maximummagnitude__"><div class="p">
    <p>Returns the value with greater magnitude.</p>

<p>This method returns the value with greater magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>maximumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &gt; y.magnitude</code>, <code>y</code> if <code>x.magnitude &lt;= y.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>

<pre><code class="language-swift">Double.maximumMagnitude(10.0, -25.0)
// -25.0
Double.maximumMagnitude(10.0, .nan)
// 10.0
Double.maximumMagnitude(.nan, -25.0)
// -25.0
Double.maximumMagnitude(.nan, .nan)
// nan</code></pre>

<p>The <code>maximumMagnitude</code> method implements the <code>maxNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has greater magnitude, or whichever is
  a number if the other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func maximumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-minimum__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-minimum__">static func minimum(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-minimum__"><div class="p">
    <p>Returns the lesser of the two given values.</p>

<p>This method returns the minimum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>minimum(x, y)</code> is <code>x</code> if <code>x &lt;= y</code>, <code>y</code> if <code>y &lt; x</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>

<pre><code class="language-swift">Double.minimum(10.0, -25.0)
// -25.0
Double.minimum(10.0, .nan)
// 10.0
Double.minimum(.nan, -25.0)
// -25.0
Double.minimum(.nan, .nan)
// nan</code></pre>

<p>The <code>minimum</code> method implements the <code>minNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> The minimum of <code>x</code> and <code>y</code>, or whichever is a number if the
  other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func minimum(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-minimummagnitude__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-minimummagnitude__">static func minimumMagnitude(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-minimummagnitude__"><div class="p">
    <p>Returns the value with lesser magnitude.</p>

<p>This method returns the value with lesser magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>minimumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &lt;= y.magnitude</code>, <code>y</code> if <code>y.magnitude &lt; x.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>

<pre><code class="language-swift">Double.minimumMagnitude(10.0, -25.0)
// 10.0
Double.minimumMagnitude(10.0, .nan)
// 10.0
Double.minimumMagnitude(.nan, -25.0)
// -25.0
Double.minimumMagnitude(.nan, .nan)
// nan</code></pre>

<p>The <code>minimumMagnitude</code> method implements the <code>minNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has lesser magnitude, or whichever is
  a number if the other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func minimumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>

<h3>Instance Methods</h3>
<div class="declaration inherited" id="func-lt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-lt_rhs_">func &lt;(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-lt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.</p>

<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-lteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-lteq_rhs_">func &lt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-lteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-eqeq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-eqeq_rhs_">func ==(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-eqeq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether two values are equal.</p>

<p>Equality is the inverse of inequality. For any values <code>a</code> and <code>b</code>,
<code>a == b</code> implies that <code>a != b</code> is <code>false</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ==(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Equatable/"><code>Equatable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-gt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-gt_rhs_">func &gt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-gt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-gteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-gteq_rhs_">func &gt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-gteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-mns_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-mns_">prefix func -(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-mns_"><div class="p">
    <p>Returns the result of negating <code>x</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func -(x: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SignedNumber/"><code>SignedNumber</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-mns_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-mns_rhs_">func -(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-mns_rhs_"><div class="p">
    <p>Returns the difference between <code>lhs</code> and <code>rhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func -(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SignedNumber/"><code>SignedNumber</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-add_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-add_">mutating func add(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-add_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func add(_ rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-addproduct__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-addproduct__">mutating func addProduct(<wbr>_:<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-addproduct__"><div class="p">
    <p>Adds the product of the two given values to this value in place, computed
without intermediate rounding.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> One of the values to multiply before adding to this value.
  <strong>rhs:</strong> The other value to multiply.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func addProduct(_ lhs: Self, _ rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-adding_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-adding_">func adding(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-adding_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func adding(_ rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-addingproduct__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-addingproduct__">func addingProduct(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-addingproduct__"><div class="p">
    <p>Returns the result of adding the product of the two given values to this
value, computed without intermediate rounding.</p>

<p>This method is equivalent to the C <code>fma</code> function and implements the
<code>fusedMultiplyAdd</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> One of the values to multiply before adding to this value.
  <strong>rhs:</strong> The other value to multiply.
<strong>Returns:</strong> The product of <code>lhs</code> and <code>rhs</code>, added to this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func addingProduct(_ lhs: Self, _ rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-advanced-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-advanced-by_">func advanced(<wbr>by:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-advanced-by_"><div class="p">
    <p>Returns a <code>Self</code> <code>x</code> such that <code>self.distance(to: x)</code> approximates <code>n</code>.</p>

<p>If <code>Stride</code> conforms to <code>Integer</code>, then <code>self.distance(to: x) == n</code>.</p>

<p><strong>Complexity:</strong> O(1).</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func advanced(by n: Self.Stride) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-distance-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-distance-to_">func distance(<wbr>to:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-distance-to_"><div class="p">
    <p>Returns a stride <code>x</code> such that <code>self.advanced(by: x)</code> approximates
<code>other</code>.</p>

<p>If <code>Stride</code> conforms to <code>Integer</code>, then <code>self.advanced(by: x) == other</code>.</p>

<p><strong>Complexity:</strong> O(1).</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance(to other: Self) -&gt; Self.Stride</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-divide-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-divide-by_">mutating func divide(<wbr>by:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-divide-by_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func divide(by rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-divided-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-divided-by_">func divided(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-divided-by_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func divided(by rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formremainder-dividingby_">mutating func formRemainder(<wbr>dividingBy:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-formremainder-dividingby_"><div class="p">
    <p>Replaces this value with the remainder of itself divided by the given
value.</p>

<p>For two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by
<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to
<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is
chosen to be even. Note that <code>q</code> is <em>not</em> <code>x / y</code> computed in
floating-point arithmetic, and that <code>q</code> may not be representable in any
available integer type.</p>

<p>The following example calculates the remainder of dividing 8.625 by 0.75:</p>

<pre><code class="language-swift">var x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.toNearestOrEven)
// q == 12.0
x.formRemainder(dividingBy: 0.75)
// x == -0.375

let x1 = 0.75 * q + x
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are finite numbers, the remainder is in the
closed range <code>-abs(other / 2)...abs(other / 2)</code>. The
<code>remainder(dividingBy:)</code> method is always exact.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.</p>

<p><strong>See Also:</strong> <code>remainder(dividingBy:)</code>,
  <code>formTruncatingRemainder(dividingBy:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formRemainder(dividingBy other: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formsquareroot">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formsquareroot">mutating func formSquareRoot()</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-formsquareroot"><div class="p">
    <p>Replaces this value with its square root, rounded to a representable
value.</p>

<p><strong>See Also:</strong> <code>sqrt(_:)</code>, <code>squareRoot()</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formSquareRoot()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formtruncatingremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formtruncatingremainder-dividingby_">mutating func formTruncatingRemainder(<wbr>dividingBy:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-formtruncatingremainder-dividingby_"><div class="p">
    <p>Replaces this value with the remainder of itself divided by the given
value using truncating division.</p>

<p>Performing truncating division with floating-point values results in a
truncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and
their truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies
<code>x == y * q + r</code>.</p>

<p>The following example calculates the truncating remainder of dividing
8.625 by 0.75:</p>

<pre><code class="language-swift">var x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.towardZero)
// q == 11.0
x.formTruncatingRemainder(dividingBy: 0.75)
// x == 0.375

let x1 = 0.75 * q + x
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are both finite numbers, the truncating
remainder has the same sign as this value and is strictly smaller in
magnitude than <code>other</code>. The <code>formTruncatingRemainder(dividingBy:)</code>
method is always exact.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.</p>

<p><strong>See Also:</strong> <code>truncatingRemainder(dividingBy:)</code>,
  <code>formRemainder(dividingBy:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formTruncatingRemainder(dividingBy other: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-isequal-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isequal-to_">func isEqual(<wbr>to:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-isequal-to_"><div class="p">
    <p>Returns a Boolean value indicating whether this instance is equal to the
given value.</p>

<p>This method serves as the basis for the equal-to operator (<code>==</code>) for
floating-point values. When comparing two values with this method, <code>-0</code>
is equal to <code>+0</code>. NaN is not equal to any value, including itself. For
example:</p>

<pre><code class="language-swift">let x = 15.0
x.isEqual(to: 15.0)
// true
x.isEqual(to: .nan)
// false
Double.nan.isEqual(to: .nan)
// false</code></pre>

<p>The <code>isEqual(to:)</code> method implements the equality predicate defined by
the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to compare with this value.
<strong>Returns:</strong> <code>true</code> if <code>other</code> has the same value as this instance;
  otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isEqual(to other: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-isless-than_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isless-than_">func isLess(<wbr>than:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-isless-than_"><div class="p">
    <p>Returns a Boolean value indicating whether this instance is less than the
given value.</p>

<p>This method serves as the basis for the less-than operator (<code>&lt;</code>) for
floating-point values. Some special cases apply:</p>

<ul><li>Because NaN compares not less than nor greater than any value, this
method returns <code>false</code> when called on NaN or when NaN is passed as
<code>other</code>.</li><li><code>-infinity</code> compares less than all values except for itself and NaN.</li><li><p>Every value except for NaN and <code>+infinity</code> compares less than
<code>+infinity</code>.</p><p>let x = 15.0
x.isLess(than: 20.0)
// true
x.isLess(than: .nan)
// false
Double.nan.isLess(than: x)
// false</p></li></ul>

<p>The <code>isLess(than:)</code> method implements the less-than predicate defined by
the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to compare with this value.
<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isLess(than other: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-islessthanorequalto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-islessthanorequalto_">func isLessThanOrEqualTo(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-islessthanorequalto_"><div class="p">
    <p>Returns a Boolean value indicating whether this instance is less than or
equal to the given value.</p>

<p>This method serves as the basis for the less-than-or-equal-to operator
(<code>&lt;=</code>) for floating-point values. Some special cases apply:</p>

<ul><li>Because NaN is incomparable with any value, this method returns <code>false</code>
when called on NaN or when NaN is passed as <code>other</code>.</li><li><code>-infinity</code> compares less than or equal to all values except NaN.</li><li><p>Every value except NaN compares less than or equal to <code>+infinity</code>.</p><p>let x = 15.0
x.isLessThanOrEqualTo(20.0)
// true
x.isLessThanOrEqualTo(.nan)
// false
Double.nan.isLessThanOrEqualTo(x)
// false</p></li></ul>

<p>The <code>isLessThanOrEqualTo(_:)</code> method implements the less-than-or-equal
predicate defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to compare with this value.
<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isLessThanOrEqualTo(_ other: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-istotallyordered-beloworequalto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-istotallyordered-beloworequalto_">func isTotallyOrdered(<wbr>belowOrEqualTo:)</a>
        
<div class="comment collapse" id="comment-func-istotallyordered-beloworequalto_"><div class="p">
    <p>Returns a Boolean value indicating whether this instance should precede the
given value in an ascending sort.</p>

<p>This relation is a refinement of the less-than-or-equal-to operator
(<code>&lt;=</code>) that provides a total order on all values of the type, including
noncanonical encodings, signed zeros, and NaNs. Because it is used much
less frequently than the usual comparisons, there is no operator form of
this relation.</p>

<p>The following example uses <code>isTotallyOrdered(below:)</code> to sort an array of
floating-point values, including some that are NaN:</p>

<pre><code class="language-swift">var numbers = [2.5, 21.25, 3.0, .nan, -9.5]
numbers.sort { $0.isTotallyOrdered(below: $1) }
// numbers == [-9.5, 2.5, 3.0, 21.25, nan]</code></pre>

<p>The <code>isTotallyOrdered(belowOrEqualTo:)</code> method implements the total order
relation as defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  A floating-point value to compare to this value.
<strong>Returns:</strong> <code>true</code> if this value is ordered below <code>other</code> in a total
  ordering of the floating-point type; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isTotallyOrdered(belowOrEqualTo other: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-multiplied-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-multiplied-by_">func multiplied(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-multiplied-by_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func multiplied(by rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-multiply-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-multiply-by_">mutating func multiply(<wbr>by:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-multiply-by_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func multiply(by rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-negate">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-negate">mutating func negate()</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-negate"><div class="p">
    <p>Replaces this value with its additive inverse.</p>

<p>The result is always exact. This example uses the <code>negate()</code> method to
negate the value of the variable <code>x</code>:</p>

<pre><code class="language-swift">var x = 21.5
x.negate()
// x == -21.5</code></pre>

<p><strong>See Also:</strong> <code>negated()</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func negate()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-negated">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-negated">func negated()</a>
        
<div class="comment collapse" id="comment-func-negated"><div class="p">
    <p>Returns the additive inverse of this value.</p>

<p>The result is always exact. This method serves as the basis for the
negation operator (prefixed <code>-</code>). For example:</p>

<pre><code class="language-swift">let x = 21.5
let y = x.negated()
// y == -21.5</code></pre>

<p><strong>Returns:</strong> The additive inverse of this value.</p>

<p><strong>See Also:</strong> <code>negate()</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func negated() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-remainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-remainder-dividingby_">func remainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func-remainder-dividingby_"><div class="p">
    <p>Returns the remainder of this value divided by the given value.</p>

<p>For two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by
<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to
<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is
chosen to be even. Note that <code>q</code> is <em>not</em> <code>x / y</code> computed in
floating-point arithmetic, and that <code>q</code> may not be representable in any
available integer type.</p>

<p>The following example calculates the remainder of dividing 8.625 by 0.75:</p>

<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.toNearestOrEven)
// q == 12.0
let r = x.remainder(dividingBy: 0.75)
// r == -0.375

let x1 = 0.75 * q + r
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are finite numbers, the remainder is in the
closed range <code>-abs(other / 2)...abs(other / 2)</code>. The
<code>remainder(dividingBy:)</code> method is always exact. This method implements
the remainder operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.
<strong>Returns:</strong> The remainder of this value divided by <code>other</code>.</p>

<p><strong>See Also:</strong> <code>formRemainder(dividingBy:)</code>,
  <code>truncatingRemainder(dividingBy:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func remainder(dividingBy other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-round_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-round_">mutating func round(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-round_"><div class="p">
    <p>Rounds the value to an integral value using the specified rounding rule.</p>

<p>The following example rounds a value using four different rounding rules:</p>

<pre><code class="language-swift">// Equivalent to the C &#39;round&#39; function:
var w = 6.5
w.round(.toNearestOrAwayFromZero)
// w == 7.0

// Equivalent to the C &#39;trunc&#39; function:
var x = 6.5
x.round(.towardZero)
// x == 6.0

// Equivalent to the C &#39;ceil&#39; function:
var y = 6.5
y.round(.up)
// y == 7.0

// Equivalent to the C &#39;floor&#39; function:
var z = 6.5
z.round(.down)
// z == 6.0</code></pre>

<p>For more information about the available rounding rules, see the
<code>FloatingPointRoundingRule</code> enumeration. To round a value using the
default &quot;schoolbook rounding&quot;, you can use the shorter <code>round()</code> method
instead.</p>

<pre><code class="language-swift">var w1 = 6.5
w1.round()
// w1 == 7.0</code></pre>

<p><strong><code>rule</code>:</strong>  The rounding rule to use.</p>

<p><strong>See Also:</strong> <code>round()</code>, <code>rounded(_:)</code>, <code>FloatingPointRoundingRule</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func round(_ rule: FloatingPointRoundingRule)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-rounded_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-rounded_">func rounded(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-rounded_"><div class="p">
    <p>Returns this value rounded to an integral value using the specified
rounding rule.</p>

<p>The following example rounds a value using four different rounding rules:</p>

<pre><code class="language-swift">let x = 6.5

// Equivalent to the C &#39;round&#39; function:
print(x.rounded(.toNearestOrAwayFromZero))
// Prints &quot;7.0&quot;

// Equivalent to the C &#39;trunc&#39; function:
print(x.rounded(.towardZero))
// Prints &quot;6.0&quot;

// Equivalent to the C &#39;ceil&#39; function:
print(x.rounded(.up))
// Prints &quot;7.0&quot;

// Equivalent to the C &#39;floor&#39; function:
print(x.rounded(.down))
// Prints &quot;6.0&quot;</code></pre>

<p>For more information about the available rounding rules, see the
<code>FloatingPointRoundingRule</code> enumeration. To round a value using the
default &quot;schoolbook rounding&quot;, you can use the shorter <code>rounded()</code>
method instead.</p>

<pre><code class="language-swift">print(x.rounded())
// Prints &quot;7.0&quot;</code></pre>

<p><strong><code>rule</code>:</strong>  The rounding rule to use.
<strong>Returns:</strong> The integral value found by rounding using <code>rule</code>.</p>

<p><strong>See Also:</strong> <code>rounded()</code>, <code>round(_:)</code>, <code>FloatingPointRoundingRule</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func rounded(_ rule: FloatingPointRoundingRule) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-squareroot">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-squareroot">func squareRoot()</a>
        
<div class="comment collapse" id="comment-func-squareroot"><div class="p">
    <p>Returns the square root of the value, rounded to a representable value.</p>

<p>The following example declares a function that calculates the length of
the hypotenuse of a right triangle given its two perpendicular sides.</p>

<pre><code class="language-swift">func hypotenuse(_ a: Double, _ b: Double) -&gt; Double {
    return (a * a + b * b).squareRoot()
}

let (dx, dy) = (3.0, 4.0)
let distance = hypotenuse(dx, dy)
// distance == 5.0</code></pre>

<p><strong>Returns:</strong> The square root of the value.</p>

<p><strong>See Also:</strong> <code>sqrt(_:)</code>, <code>formSquareRoot()</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func squareRoot() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subtract_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subtract_">mutating func subtract(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-subtract_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func subtract(_ rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subtracting_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subtracting_">func subtracting(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subtracting_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func subtracting(_ rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-truncatingremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-truncatingremainder-dividingby_">func truncatingRemainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func-truncatingremainder-dividingby_"><div class="p">
    <p>Returns the remainder of this value divided by the given value using
truncating division.</p>

<p>Performing truncating division with floating-point values results in a
truncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and
their truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies
<code>x == y * q + r</code>.</p>

<p>The following example calculates the truncating remainder of dividing
8.625 by 0.75:</p>

<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.towardZero)
// q == 11.0
let r = x.truncatingRemainder(dividingBy: 0.75)
// r == 0.375

let x1 = 0.75 * q + r
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are both finite numbers, the truncating
remainder has the same sign as this value and is strictly smaller in
magnitude than <code>other</code>. The <code>truncatingRemainder(dividingBy:)</code> method
is always exact.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.
<strong>Returns:</strong> The remainder of this value divided by <code>other</code> using
  truncating division.</p>

<p><strong>See Also:</strong> <code>formTruncatingRemainder(dividingBy:)</code>,
  <code>remainder(dividingBy:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func truncatingRemainder(dividingBy other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>


<h3>Default Implementations</h3>




<div class="declaration inherited" id="-init">
<a class="toggle-link" data-toggle="collapse" href="#comment--init">init()</a><div class="comment collapse" id="comment--init"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">init()</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="-init-integerliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-integerliteral_">init(<wbr>integerLiteral:)</a><div class="comment collapse" id="comment--init-integerliteral_"><div class="p">
    <p>Create an instance initialized to <code>value</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(integerLiteral value: Self)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>
        ,    <a href="../../protocol/AbsoluteValuable/"><code>AbsoluteValuable</code></a>
        ,    <a href="../../protocol/ExpressibleByIntegerLiteral/"><code>ExpressibleByIntegerLiteral</code></a>
        </div></div>
</div>
<div class="declaration" id="-init-signof_magnitudeof_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-signof_magnitudeof_">init(<wbr>signOf:<wbr>magnitudeOf:)</a><div class="comment collapse" id="comment--init-signof_magnitudeof_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">init(signOf: Self, magnitudeOf: Self)</code>

    </div></div>
</div>

<div class="declaration" id="-static-var-radix_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment--static-var-radix_-int">static var radix: Int</a><div class="comment collapse" id="comment--static-var-radix_-int"><div class="p">
    <p>The radix, or base of exponentiation, for this floating-point type.</p>

<p>All binary floating-point types have a radix of 2. The magnitude of a
floating-point value <code>x</code> of type <code>F</code> can be calculated by using the
following formula, where <code>**</code> is exponentiation:</p>

<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">static var radix: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="-static-var-ulpofone_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment--static-var-ulpofone_-self">static var ulpOfOne: Self</a><div class="comment collapse" id="comment--static-var-ulpofone_-self"><div class="p">
    <p>The unit in the last place of 1.0.</p>

<p>The positive difference between 1.0 and the next greater representable
number. The <code>ulpOfOne</code> constant corresponds to the C macros
<code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, and others with a similar purpose.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var ulpOfOne: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="-var-floatingpointclass_-floatingpointclassification">
<a class="toggle-link" data-toggle="collapse" href="#comment--var-floatingpointclass_-floatingpointclassification">var floatingPointClass: FloatingPointClassification</a><div class="comment collapse" id="comment--var-floatingpointclass_-floatingpointclassification"><div class="p">
    <p>The classification of this value.</p>

<p>A value&#39;s <code>floatingPointClass</code> property describes its &quot;class&quot; as
described by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var floatingPointClass: FloatingPointClassification { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="-var-nextdown_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment--var-nextdown_-self">var nextDown: Self</a><div class="comment collapse" id="comment--var-nextdown_-self"><div class="p">
    <p>The greatest representable value that compares less than this value.</p>

<p>For any finite value <code>x</code>, <code>x.nextDown</code> is greater than <code>x</code>. For <code>nan</code> or
<code>-infinity</code>, <code>x.nextDown</code> is <code>x</code> itself. The following special cases
also apply:</p>

<ul><li>If <code>x</code> is <code>infinity</code>, then <code>x.nextDown</code> is <code>greatestFiniteMagnitude</code>.</li><li>If <code>x</code> is <code>leastNonzeroMagnitude</code>, then <code>x.nextDown</code> is <code>0.0</code>.</li><li>If <code>x</code> is zero, then <code>x.nextDown</code> is <code>-leastNonzeroMagnitude</code>.</li><li>If <code>x</code> is <code>-greatestFiniteMagnitude</code>, then <code>x.nextDown</code> is <code>-infinity</code>.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var nextDown: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>


<div class="declaration inherited" id="func--adding_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--adding_">func adding(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--adding_"><div class="p">
    <p>Returns the sum of this value and the given value, rounded to a
representable value.</p>

<p>This method serves as the basis for the addition operator (<code>+</code>). For
example:</p>

<pre><code class="language-swift">let x = 1.5
print(x.adding(2.25))
// Prints &quot;3.75&quot;
print(x + 2.25)
// Prints &quot;3.75&quot;</code></pre>

<p>The <code>adding(_:)</code> method implements the addition operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to add.
<strong>Returns:</strong> The sum of this value and <code>other</code>, rounded to a representable
  value.</p>

<p><strong>See Also:</strong> <code>add(_:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func adding(_ other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--addingproduct__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--addingproduct__">func addingProduct(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--addingproduct__"><div class="p">
    <p>Returns the result of adding the product of the two given values to this
value, computed without intermediate rounding.</p>

<p>This method is equivalent to the C <code>fma</code> function and implements the
<code>fusedMultiplyAdd</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> One of the values to multiply before adding to this value.
  <strong>rhs:</strong> The other value to multiply.
<strong>Returns:</strong> The product of <code>lhs</code> and <code>rhs</code>, added to this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func addingProduct(_ lhs: Self, _ rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--divided-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--divided-by_">func divided(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func--divided-by_"><div class="p">
    <p>Returns the quotient of this value and the given value, rounded to a
representable value.</p>

<p>This method serves as the basis for the division operator (<code>/</code>). For
example:</p>

<pre><code class="language-swift">let x = 7.5
let y = x.divided(by: 2.25)
// y == 16.875
let z = x * 2.25
// z == 16.875</code></pre>

<p>The <code>divided(by:)</code> method implements the division operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.
<strong>Returns:</strong> The quotient of this value and <code>other</code>, rounded to a
  representable value.</p>

<p><strong>See Also:</strong> <code>divide(by:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func divided(by other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>    
</div></div>
</div>
<div class="declaration" id="func--istotallyordered-beloworequalto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--istotallyordered-beloworequalto_">func isTotallyOrdered(<wbr>belowOrEqualTo:)</a>
        
<div class="comment collapse" id="comment-func--istotallyordered-beloworequalto_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func isTotallyOrdered(belowOrEqualTo other: Self) -&gt; Bool</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func--maximum__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--maximum__">static func maximum(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--maximum__"><div class="p">
    <p>Returns the greater of the two given values.</p>

<p>This method returns the maximum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>maximum(x, y)</code> is <code>x</code> if <code>x &gt; y</code>, <code>y</code> if <code>x &lt;= y</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>

<pre><code class="language-swift">Double.maximum(10.0, -25.0)
// 10.0
Double.maximum(10.0, .nan)
// 10.0
Double.maximum(.nan, -25.0)
// -25.0
Double.maximum(.nan, .nan)
// nan</code></pre>

<p>The <code>maximum</code> method implements the <code>maxNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> The greater of <code>x</code> and <code>y</code>, or whichever is a number if the
  other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func maximum(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--maximummagnitude__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--maximummagnitude__">static func maximumMagnitude(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--maximummagnitude__"><div class="p">
    <p>Returns the value with greater magnitude.</p>

<p>This method returns the value with greater magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>maximumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &gt; y.magnitude</code>, <code>y</code> if <code>x.magnitude &lt;= y.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>

<pre><code class="language-swift">Double.maximumMagnitude(10.0, -25.0)
// -25.0
Double.maximumMagnitude(10.0, .nan)
// 10.0
Double.maximumMagnitude(.nan, -25.0)
// -25.0
Double.maximumMagnitude(.nan, .nan)
// nan</code></pre>

<p>The <code>maximumMagnitude</code> method implements the <code>maxNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has greater magnitude, or whichever is
  a number if the other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func maximumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--minimum__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--minimum__">static func minimum(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--minimum__"><div class="p">
    <p>Returns the lesser of the two given values.</p>

<p>This method returns the minimum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>minimum(x, y)</code> is <code>x</code> if <code>x &lt;= y</code>, <code>y</code> if <code>y &lt; x</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>

<pre><code class="language-swift">Double.minimum(10.0, -25.0)
// -25.0
Double.minimum(10.0, .nan)
// 10.0
Double.minimum(.nan, -25.0)
// -25.0
Double.minimum(.nan, .nan)
// nan</code></pre>

<p>The <code>minimum</code> method implements the <code>minNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> The minimum of <code>x</code> and <code>y</code>, or whichever is a number if the
  other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func minimum(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--minimummagnitude__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--minimummagnitude__">static func minimumMagnitude(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--minimummagnitude__"><div class="p">
    <p>Returns the value with lesser magnitude.</p>

<p>This method returns the value with lesser magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>minimumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &lt;= y.magnitude</code>, <code>y</code> if <code>y.magnitude &lt; x.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>

<pre><code class="language-swift">Double.minimumMagnitude(10.0, -25.0)
// 10.0
Double.minimumMagnitude(10.0, .nan)
// 10.0
Double.minimumMagnitude(.nan, -25.0)
// -25.0
Double.minimumMagnitude(.nan, .nan)
// nan</code></pre>

<p>The <code>minimumMagnitude</code> method implements the <code>minNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has lesser magnitude, or whichever is
  a number if the other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func minimumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--multiplied-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--multiplied-by_">func multiplied(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func--multiplied-by_"><div class="p">
    <p>Returns the product of this value and the given value, rounded to a
representable value.</p>

<p>This method serves as the basis for the multiplication operator (<code>*</code>).
For example:</p>

<pre><code class="language-swift">let x = 7.5
print(x.multiplied(by: 2.25))
// Prints &quot;16.875&quot;
print(x * 2.25)
// Prints &quot;16.875&quot;</code></pre>

<p>The <code>multiplied(by:)</code> method implements the multiplication operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to multiply by this value.
<strong>Returns:</strong> The product of this value and <code>other</code>, rounded to a
  representable value.</p>

<p><strong>See Also:</strong> <code>multiply(by:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func multiplied(by other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--negated">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--negated">func negated()</a>
        
<div class="comment collapse" id="comment-func--negated"><div class="p">
    <p>Returns the additive inverse of this value.</p>

<p>The result is always exact. This method serves as the basis for the
negation operator (prefixed <code>-</code>). For example:</p>

<pre><code class="language-swift">let x = 21.5
let y = x.negated()
// y == -21.5</code></pre>

<p><strong>Returns:</strong> The additive inverse of this value.</p>

<p><strong>See Also:</strong> <code>negate()</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func negated() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--remainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--remainder-dividingby_">func remainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func--remainder-dividingby_"><div class="p">
    <p>Returns the remainder of this value divided by the given value.</p>

<p>For two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by
<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to
<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is
chosen to be even. Note that <code>q</code> is <em>not</em> <code>x / y</code> computed in
floating-point arithmetic, and that <code>q</code> may not be representable in any
available integer type.</p>

<p>The following example calculates the remainder of dividing 8.625 by 0.75:</p>

<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.toNearestOrEven)
// q == 12.0
let r = x.remainder(dividingBy: 0.75)
// r == -0.375

let x1 = 0.75 * q + r
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are finite numbers, the remainder is in the
closed range <code>-abs(other / 2)...abs(other / 2)</code>. The
<code>remainder(dividingBy:)</code> method is always exact. This method implements
the remainder operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.
<strong>Returns:</strong> The remainder of this value divided by <code>other</code>.</p>

<p><strong>See Also:</strong> <code>formRemainder(dividingBy:)</code>,
  <code>truncatingRemainder(dividingBy:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func remainder(dividingBy rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--round">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--round">mutating func round()</a>
        
<div class="comment collapse" id="comment-func--round"><div class="p">
    <p>Rounds this value to an integral value using &quot;schoolbook rounding.&quot;</p>

<p>The <code>round()</code> method uses the <code>.toNearestOrAwayFromZero</code> rounding rule,
where a value halfway between two integral values is rounded to the one
with greater magnitude. The following example rounds several values
using this default rule:</p>

<pre><code class="language-swift">var x = 5.2
x.round()
// x == 5.0
var y = 5.5
y.round()
// y == 6.0
var z = -5.5
z.round()
// z == -6.0</code></pre>

<p>To specify an alternative rule for rounding, use the <code>round(_:)</code> method
instead.</p>

<p><strong>See Also:</strong> <code>round(_:)</code>, <code>rounded()</code>, <code>FloatingPointRoundingRule</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func round()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--rounded">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--rounded">func rounded()</a>
        
<div class="comment collapse" id="comment-func--rounded"><div class="p">
    <p>Returns this value rounded to an integral value using &quot;schoolbook
rounding.&quot;</p>

<p>The <code>rounded()</code> method uses the <code>.toNearestOrAwayFromZero</code> rounding rule,
where a value halfway between two integral values is rounded to the one
with greater magnitude. The following example rounds several values
using this default rule:</p>

<pre><code class="language-swift">(5.2).rounded()
// 5.0
(5.5).rounded()
// 6.0
(-5.2).rounded()
// -5.0
(-5.5).rounded()
// -6.0</code></pre>

<p>To specify an alternative rule for rounding, use the <code>rounded(_:)</code> method
instead.</p>

<p><strong>Returns:</strong> The nearest integral value, or, if two integral values are
  equally close, the integral value with greater magnitude.</p>

<p><strong>See Also:</strong> <code>rounded(_:)</code>, <code>round()</code>, <code>FloatingPointRoundingRule</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func rounded() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--rounded_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--rounded_">func rounded(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--rounded_"><div class="p">
    <p>Returns this value rounded to an integral value using the specified
rounding rule.</p>

<p>The following example rounds a value using four different rounding rules:</p>

<pre><code class="language-swift">let x = 6.5

// Equivalent to the C &#39;round&#39; function:
print(x.rounded(.toNearestOrAwayFromZero))
// Prints &quot;7.0&quot;

// Equivalent to the C &#39;trunc&#39; function:
print(x.rounded(.towardZero))
// Prints &quot;6.0&quot;

// Equivalent to the C &#39;ceil&#39; function:
print(x.rounded(.up))
// Prints &quot;7.0&quot;

// Equivalent to the C &#39;floor&#39; function:
print(x.rounded(.down))
// Prints &quot;6.0&quot;</code></pre>

<p>For more information about the available rounding rules, see the
<code>FloatingPointRoundingRule</code> enumeration. To round a value using the
default &quot;schoolbook rounding&quot;, you can use the shorter <code>rounded()</code>
method instead.</p>

<pre><code class="language-swift">print(x.rounded())
// Prints &quot;7.0&quot;</code></pre>

<p><strong><code>rule</code>:</strong>  The rounding rule to use.
<strong>Returns:</strong> The integral value found by rounding using <code>rule</code>.</p>

<p><strong>See Also:</strong> <code>rounded()</code>, <code>round(_:)</code>, <code>FloatingPointRoundingRule</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func rounded(_ rule: FloatingPointRoundingRule) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--squareroot">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--squareroot">func squareRoot()</a>
        
<div class="comment collapse" id="comment-func--squareroot"><div class="p">
    <p>Returns the square root of the value, rounded to a representable value.</p>

<p>The following example declares a function that calculates the length of
the hypotenuse of a right triangle given its two perpendicular sides.</p>

<pre><code class="language-swift">func hypotenuse(_ a: Double, _ b: Double) -&gt; Double {
    return (a * a + b * b).squareRoot()
}

let (dx, dy) = (3.0, 4.0)
let distance = hypotenuse(dx, dy)
// distance == 5.0</code></pre>

<p><strong>Returns:</strong> The square root of the value.</p>

<p><strong>See Also:</strong> <code>sqrt(_:)</code>, <code>formSquareRoot()</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func squareRoot() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--subtracting_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--subtracting_">func subtracting(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--subtracting_"><div class="p">
    <p>Returns the difference of this value and the given value, rounded to a
representable value.</p>

<p>This method serves as the basis for the subtraction operator (<code>-</code>). For
example:</p>

<pre><code class="language-swift">let x = 7.5
print(x.subtracting(2.25))
// Prints &quot;5.25&quot;
print(x - 2.25)
// Prints &quot;5.25&quot;</code></pre>

<p>The <code>subtracting(_:)</code> method implements the subtraction operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to subtract from this value.
<strong>Returns:</strong> The difference of this value and <code>other</code>, rounded to a
  representable value.</p>

<p><strong>See Also:</strong> <code>subtract(_:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func subtracting(_ other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Arithmetic/"><code>Arithmetic</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--truncatingremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--truncatingremainder-dividingby_">func truncatingRemainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func--truncatingremainder-dividingby_"><div class="p">
    <p>Returns the remainder of this value divided by the given value using
truncating division.</p>

<p>Performing truncating division with floating-point values results in a
truncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and
their truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies
<code>x == y * q + r</code>.</p>

<p>The following example calculates the truncating remainder of dividing
8.625 by 0.75:</p>

<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.towardZero)
// q == 11.0
let r = x.truncatingRemainder(dividingBy: 0.75)
// r == 0.375

let x1 = 0.75 * q + r
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are both finite numbers, the truncating
remainder has the same sign as this value and is strictly smaller in
magnitude than <code>other</code>. The <code>truncatingRemainder(dividingBy:)</code> method
is always exact.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.
<strong>Returns:</strong> The remainder of this value divided by <code>other</code> using
  truncating division.</p>

<p><strong>See Also:</strong> <code>formTruncatingRemainder(dividingBy:)</code>,
  <code>remainder(dividingBy:)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func truncatingRemainder(dividingBy other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>





