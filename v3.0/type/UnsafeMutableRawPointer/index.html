---
layout: "default"
title: "UnsafeMutableRawPointer"
description: "Swift documentation for 'UnsafeMutableRawPointer': A raw pointer for accessing untyped data. This provides no."
keywords: "UnsafeMutableRawPointer,struct,swift,documentation,advanced,allocate,assumingMemoryBound,bindMemory,copyBytes,deallocate,distance,initializeMemory,initializeMemory,initializeMemory,load,moveInitializeMemory,storeBytes,customMirror,customPlaygroundQuickLook,debugDescription,hashValue"
root: "/v3.0"
---

<div class="intro-declaration"><code class="language-swift">struct UnsafeMutableRawPointer</code></div>

<div class="discussion comment">
    <p>A raw pointer for accessing untyped data. This provides no
automatic memory management, no type safety, and no alignment
guarantees. This implements Strideable to provide a view
of byte-addressable memory.</p>
</div>

<table class="standard">
<tr>
<th id="inheritance">Inheritance</th>
<td>
<code class="inherits">Comparable, CustomDebugStringConvertible, CustomPlaygroundQuickLookable, CustomReflectable, Equatable, Hashable, Strideable</code>
<span class="viz"><a href="hierarchy/">View Protocol Hierarchy &rarr;</a></span>
</td>
</tr>



<tr>
<th>Import</th>
<td><code class="language-swift">import Swift</code></td>
</tr>

</table>


<h3>Initializers</h3>
<div class="declaration" id="init_-opaquepointer">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-opaquepointer">init(<wbr>_: OpaquePointer)</a><div class="comment collapse" id="comment-init_-opaquepointer"><div class="p">
    <p>Converts an opaque pointer to an <code>UnsafeMutableRawPointer</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ other: OpaquePointer)</code>

    </div></div>
</div>
<div class="declaration" id="init_-unsafemutablerawpointer">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-unsafemutablerawpointer">init(<wbr>_: UnsafeMutableRawPointer)</a><div class="comment collapse" id="comment-init_-unsafemutablerawpointer"><div class="p">
    <p>Creates an <code>UnsafeMutableRawPointer</code> from another <code>UnsafeMutableRawPointer</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ other: UnsafeMutableRawPointer)</code>

    </div></div>
</div>
<div class="declaration" id="init-t_-autoreleasingunsafemutablepointer-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-t_-autoreleasingunsafemutablepointer-t">init&lt;T&gt;(<wbr>_: AutoreleasingUnsafeMutablePointer&lt;T&gt;)</a><div class="comment collapse" id="comment-init-t_-autoreleasingunsafemutablepointer-t"><div class="p">
    <p>Convert from <code>AutoreleasingUnsafeMutablePointer</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;T&gt;(_ other: AutoreleasingUnsafeMutablePointer&lt;T&gt;)</code>

    </div></div>
</div>
<div class="declaration" id="init-t_-unsafemutablepointer-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-t_-unsafemutablepointer-t">init&lt;T&gt;(<wbr>_: UnsafeMutablePointer&lt;T&gt;)</a><div class="comment collapse" id="comment-init-t_-unsafemutablepointer-t"><div class="p">
    <p>Converts an UnsafeMutablePointer to an <code>UnsafeMutableRawPointer</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;T&gt;(_ other: UnsafeMutablePointer&lt;T&gt;)</code>

    </div></div>
</div>
<div class="declaration" id="init-mutating_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-mutating_">init(<wbr>mutating:)</a><div class="comment collapse" id="comment-init-mutating_"><div class="p">
    <p>Converts an UnsafeRawPointer to an <code>UnsafeMutableRawPointer</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(mutating other: UnsafeRawPointer)</code>

    </div></div>
</div>
<div class="declaration" id="init_-opaquepointer">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-opaquepointer">init?(<wbr>_: OpaquePointer?)</a><div class="comment collapse" id="comment-init_-opaquepointer"><div class="p">
    <p>Converts an opaque pointer to an <code>UnsafeMutableRawPointer</code>.</p>

<p>Returns <code>nil</code> if <code>from</code> is <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?(_ other: OpaquePointer?)</code>

    </div></div>
</div>
<div class="declaration" id="init_-unsafemutablerawpointer">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-unsafemutablerawpointer">init?(<wbr>_: UnsafeMutableRawPointer?)</a><div class="comment collapse" id="comment-init_-unsafemutablerawpointer"><div class="p">
    <p>Creates an <code>UnsafeMutableRawPointer</code> from another <code>UnsafeMutableRawPointer</code>.</p>

<p>Returns <code>nil</code> if <code>other</code> is <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?(_ other: UnsafeMutableRawPointer?)</code>

    </div></div>
</div>
<div class="declaration" id="init-t_-autoreleasingunsafemutablepointer-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-t_-autoreleasingunsafemutablepointer-t">init?&lt;T&gt;(<wbr>_: AutoreleasingUnsafeMutablePointer&lt;T&gt;?)</a><div class="comment collapse" id="comment-init-t_-autoreleasingunsafemutablepointer-t"><div class="p">
    <p>Convert other <code>AutoreleasingUnsafeMutablePointer</code>.</p>

<p>Returns nil if <code>other</code> is nil.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?&lt;T&gt;(_ other: AutoreleasingUnsafeMutablePointer&lt;T&gt;?)</code>

    </div></div>
</div>
<div class="declaration" id="init-t_-unsafemutablepointer-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-t_-unsafemutablepointer-t">init?&lt;T&gt;(<wbr>_: UnsafeMutablePointer&lt;T&gt;?)</a><div class="comment collapse" id="comment-init-t_-unsafemutablepointer-t"><div class="p">
    <p>Converts an UnsafeMutablePointer to an <code>UnsafeMutableRawPointer</code>.</p>

<p>Returns <code>nil</code> if <code>other</code> is <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?&lt;T&gt;(_ other: UnsafeMutablePointer&lt;T&gt;?)</code>

    </div></div>
</div>
<div class="declaration" id="init-bitpattern_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-bitpattern_-int">init?(<wbr>bitPattern: Int)</a><div class="comment collapse" id="comment-init-bitpattern_-int"><div class="p">
    <p>Converts a pattern of bits to an <code>UnsafeMutableRawPointer</code>.</p>

<p>Returns <code>nil</code> if <code>bitPattern</code> is zero.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?(bitPattern: Int)</code>

    </div></div>
</div>
<div class="declaration" id="init-bitpattern_-uint">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-bitpattern_-uint">init?(<wbr>bitPattern: UInt)</a><div class="comment collapse" id="comment-init-bitpattern_-uint"><div class="p">
    <p>Converts a pattern of bits to an <code>UnsafeMutableRawPointer</code>.</p>

<p>Returns <code>nil</code> if <code>bitPattern</code> is zero.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?(bitPattern: UInt)</code>

    </div></div>
</div>
<div class="declaration" id="init-mutating_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-mutating_">init?(<wbr>mutating:)</a><div class="comment collapse" id="comment-init-mutating_"><div class="p">
    <p>Converts an UnsafeRawPointer to an <code>UnsafeMutableRawPointer</code>.</p>

<p>Returns <code>nil</code> if <code>other</code> is <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?(mutating other: UnsafeRawPointer?)</code>

    </div></div>
</div>


<h3>Instance Variables</h3>
<div class="declaration" id="var-custommirror_-mirror">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-custommirror_-mirror">var customMirror: Mirror</a><div class="comment collapse" id="comment-var-custommirror_-mirror"><div class="p">
    <p>The custom mirror for this instance.</p>

<p>If this type has value semantics, the mirror should be unaffected by
subsequent mutations of the instance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var customMirror: Mirror { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-customplaygroundquicklook_-playgroundquicklook">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-customplaygroundquicklook_-playgroundquicklook">var customPlaygroundQuickLook: PlaygroundQuickLook</a><div class="comment collapse" id="comment-var-customplaygroundquicklook_-playgroundquicklook"><div class="p">
    <p>A custom playground Quick Look for this instance.</p>

<p>If this type has value semantics, the <code>PlaygroundQuickLook</code> instance
should be unaffected by subsequent mutations.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-debugdescription_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-debugdescription_-string">var debugDescription: String</a><div class="comment collapse" id="comment-var-debugdescription_-string"><div class="p">
    <p>A textual representation of the pointer, suitable for debugging.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var debugDescription: String { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-hashvalue_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-hashvalue_-int">var hashValue: Int</a><div class="comment collapse" id="comment-var-hashvalue_-int"><div class="p">
    <p>The pointer&#39;s hash value.</p>

<p>The hash value is not guaranteed to be stable across different
invocations of the same program.  Do not persist the hash value across
program runs.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var hashValue: Int { get }</code>

    </div></div>
</div>


<h3>Static Methods</h3>
<div class="declaration" id="func-allocate-bytes_alignedto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-allocate-bytes_alignedto_">static func allocate(<wbr>bytes:<wbr>alignedTo:)</a>
        
<div class="comment collapse" id="comment-func-allocate-bytes_alignedto_"><div class="p">
    <p>Allocates and points at uninitialized memory for <code>size</code> bytes with
<code>alignedTo</code> alignment.</p>

<p><strong>Postcondition:</strong> The memory is allocated, but not initialized.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func allocate(bytes size: Int, alignedTo: Int) -&gt; UnsafeMutableRawPointer</code>
    
    
</div></div>
</div>

<h3>Instance Methods</h3>
<div class="declaration" id="func-advanced-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-advanced-by_">func advanced(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-advanced-by_"><div class="p">
    <p>Returns <code>self + n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func advanced(by n: Int) -&gt; UnsafeMutableRawPointer</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-assumingmemorybound_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-assumingmemorybound_">func assumingMemoryBound(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-assumingmemorybound_"><div class="p">
    <p>Converts from an <code>UnsafeMutableRawPointer</code> to UnsafeMutablePointer&lt;T&gt; given that
the region of memory starting at <code>self</code> is already bound to type <code>T</code>.</p>

<p><strong>Precondition:</strong> The memory is bound to &#39;T&#39; starting at <code>self</code> for some
  unspecified capacity.</p>

<p><strong>Warning:</strong> Accessing memory via the returned pointer is undefined if the
  if the memory has not been bound to <code>T</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func assumingMemoryBound&lt;T&gt;(to: T.Type) -&gt; UnsafeMutablePointer&lt;T&gt;</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-bindmemory-to_capacity_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-bindmemory-to_capacity_">func bindMemory(<wbr>to:<wbr>capacity:)</a>
        
<div class="comment collapse" id="comment-func-bindmemory-to_capacity_"><div class="p">
    <p>Binds the allocated memory to type <code>T</code> and returns an
<code>UnsafeMutablePointer&lt;T&gt;</code> to the bound memory at <code>self</code>.</p>

<p><strong>Precondition:</strong> The memory is uninitialized.
<strong>Postcondition:</strong> The memory is bound to &#39;T&#39; starting at <code>self</code> continuing
  through <code>self</code> + <code>count</code> * <code>MemoryLayout&lt;T&gt;.stride</code>
<strong>Warning:</strong> A memory location may only be bound to one type at a time.
  The behavior of accessing memory as type <code>U</code> while it is bound to an
  unrelated type <code>T</code> is undefined.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func bindMemory&lt;T&gt;(to type: T.Type, capacity count: Int) -&gt; UnsafeMutablePointer&lt;T&gt;</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-copybytes-from_count_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-copybytes-from_count_">func copyBytes(<wbr>from:<wbr>count:)</a>
        
<div class="comment collapse" id="comment-func-copybytes-from_count_"><div class="p">
    <p>Copies <code>count</code> bytes from <code>source</code> into memory at <code>self</code>.</p>

<p><strong>Precondition:</strong> <code>count</code> is non-negative.</p>

<p><strong>Precondition:</strong> The memory at <code>source..&lt;source + count</code> is
  initialized to some trivial type <code>T</code>.</p>

<p><strong>Precondition:</strong> If the memory at <code>self..&lt;self+count</code> is bound to
  a type <code>U</code>, then <code>U</code> is a trivial type, the underlying
  pointers <code>source</code> and <code>self</code> are properly aligned for type
  <code>U</code>, and <code>count</code> is a multiple of <code>MemoryLayout&lt;U&gt;.stride</code>.</p>

<p><strong>Postcondition:</strong> The memory at <code>self..&lt;self+count</code> is
  initialized to raw bytes. If the memory is bound to type <code>U</code>,
  then it contains values of type <code>U</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func copyBytes(from source: UnsafeRawPointer, count: Int)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-deallocate_alignedto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-deallocate_alignedto_">func deallocate(<wbr>_:<wbr>alignedTo:)</a>
        
<div class="comment collapse" id="comment-func-deallocate_alignedto_"><div class="p">
    <p>Deallocates uninitialized memory allocated for <code>bytes</code> number of bytes
with <code>alignedTo</code> alignment.</p>

<p><strong>Precondition:</strong> The memory is not initialized.
<strong>Postcondition:</strong> The memory has been deallocated.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func deallocate(bytes: Int, alignedTo: Int)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-distance-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-distance-to_">func distance(<wbr>to:)</a>
        
<div class="comment collapse" id="comment-func-distance-to_"><div class="p">
    <p>Returns <code>x - self</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance(to x: UnsafeMutableRawPointer) -&gt; Int</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-initializememory_from_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-initializememory_from_">func initializeMemory(<wbr>_:<wbr>from:)</a>
        
<div class="comment collapse" id="comment-func-initializememory_from_"><div class="p">
    <p>Initializes memory starting at <code>self</code> with the elements of
<code>source</code> and binds the initialized memory to type <code>T</code>.</p>

<p>Returns an <code>UnsafeMutablePointer&lt;T&gt;</code> this memory.</p>

<p><strong>Precondition:</strong> The memory at <code>self..&lt;self + source.count *
  MemoryLayout&lt;T&gt;.stride</code> is uninitialized.</p>

<p><strong>Postcondition:</strong> The memory at <code>self..&lt;self + source.count *
  MemoryLayout&lt;T&gt;.stride</code> is bound to type <code>T</code>.</p>

<p><strong>Postcondition:</strong> The <code>T</code> values at <code>self..&lt;self + source.count *
  MemoryLayout&lt;T&gt;.stride</code> are initialized.</p>

<p>TODO: Optimize where <code>C</code> is a <code>ContiguousArrayBuffer</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func initializeMemory&lt;C : Collection&gt;(as: C.Iterator.Element.Type, from source: C) -&gt; UnsafeMutablePointer&lt;C.Iterator.Element&gt;</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-initializememory-as_at_count_to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-initializememory-as_at_count_to_">func initializeMemory(<wbr>as:<wbr>at:<wbr>count:<wbr>to:)</a>
        
<div class="comment collapse" id="comment-func-initializememory-as_at_count_to_"><div class="p">
    <p>Initializes this memory location <code>self + strideof(T) * index</code>
with <code>count</code> consecutive copies of <code>value</code> and binds the
initialized memory to type <code>T</code>.</p>

<p>Returns an <code>UnsafeMutablePointer&lt;T&gt;</code> to this memory.</p>

<p><strong>Precondition:</strong> The memory at
 <code>self + index * strideof(T)..&lt;self + (index + count) * strideof(T)</code>
 is uninitialized.</p>

<p><strong>Precondition:</strong> The underlying pointer is properly aligned for
                accessing <code>T</code>.</p>

<p><strong>Precondition:</strong> <code>index</code> is non-negative.</p>

<p><strong>Precondition:</strong> <code>count</code> is non-negative.</p>

<p><strong>Postcondition:</strong> The memory at
 <code>(self + strideof(T) * index)..&lt;(self + strideof(T) * index) + count</code>
 is bound to type <code>T</code> and initialized; the value should eventually be
 destroyed or moved from to avoid leaks.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func initializeMemory&lt;T&gt;(as type: T.Type, at index: Int = default, count: Int = default, to value: T) -&gt; UnsafeMutablePointer&lt;T&gt;</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-initializememory-as_from_count_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-initializememory-as_from_count_">func initializeMemory(<wbr>as:<wbr>from:<wbr>count:)</a>
        
<div class="comment collapse" id="comment-func-initializememory-as_from_count_"><div class="p">
    <p>Initializes memory starting at <code>self</code> with <code>count</code> <code>T</code> values beginning
at <code>source</code> and binds the initialized memory to type <code>T</code>.</p>

<p>Returns an <code>UnsafeMutablePointer&lt;T&gt;</code> this memory.</p>

<p><strong>Precondition:</strong> <code>count &gt;= 0</code>
<strong>Precondition:</strong> The memory regions <code>source..&lt;source + count</code> and
  <code>self..&lt;self + count * MemoryLayout&lt;T&gt;.stride</code> do not overlap.
<strong>Precondition:</strong> The memory at
  <code>self..&lt;self + count * MemoryLayout&lt;T&gt;.stride</code> is uninitialized, and
  the <code>T</code> values at <code>source..&lt;source + count</code> are initialized.
<strong>Precondition:</strong> The underlying pointer is properly aligned for accessing
  <code>T</code>.
<strong>Postcondition:</strong> The memory at
  <code>self..&lt;self + count * MemoryLayout&lt;T&gt;.stride</code> is bound to type <code>T</code>.
<strong>Postcondition:</strong> The <code>T</code> values at
  <code>self..&lt;self + count * MemoryLayout&lt;T&gt;.stride</code> and
  <code>source..&lt;source + count</code> are initialized.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func initializeMemory&lt;T&gt;(as type: T.Type, from source: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeMutablePointer&lt;T&gt;</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-load-frombyteoffset_as_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-load-frombyteoffset_as_">func load(<wbr>fromByteOffset:<wbr>as:)</a>
        
<div class="comment collapse" id="comment-func-load-frombyteoffset_as_"><div class="p">
    <p>Reads raw bytes from memory at <code>self + offset</code> and constructs a
value of type <code>T</code>.</p>

<p><strong>Precondition:</strong> The underlying pointer plus <code>offset</code> is properly
  aligned for accessing <code>T</code>.</p>

<p><strong>Precondition:</strong> The memory is initialized to a value of some type, <code>U</code>,
  such that <code>T</code> is layout compatible with <code>U</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func load&lt;T&gt;(fromByteOffset offset: Int = default, as type: T.Type) -&gt; T</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-moveinitializememory-as_from_count_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-moveinitializememory-as_from_count_">func moveInitializeMemory(<wbr>as:<wbr>from:<wbr>count:)</a>
        
<div class="comment collapse" id="comment-func-moveinitializememory-as_from_count_"><div class="p">
    <p>Initializes memory starting at <code>self</code> with <code>count</code> <code>T</code> values
beginning at <code>source</code>, binds the initialized memory to type <code>T</code>,
and returns the source memory to an uninitialized state.</p>

<p>Returns an <code>UnsafeMutablePointer&lt;T&gt;</code> this memory.</p>

<p><strong>Precondition:</strong> <code>count &gt;= 0</code></p>

<p><strong>Precondition:</strong> The memory at <code>self..&lt;self + count *
  MemoryLayout&lt;T&gt;.stride</code> is uninitialized and the <code>T</code> values at
  <code>source..&lt;source + count</code> are initialized.</p>

<p><strong>Postcondition:</strong> The memory at <code>self..&lt;self + count *
  MemoryLayout&lt;T&gt;.stride</code> is bound to type <code>T</code>.</p>

<p><strong>Postcondition:</strong> The <code>T</code> values at <code>self..&lt;self + count *
  MemoryLayout&lt;T&gt;.stride</code> are initialized and the memory at
  <code>source..&lt;source + count</code> is uninitialized.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func moveInitializeMemory&lt;T&gt;(as type: T.Type, from source: UnsafeMutablePointer&lt;T&gt;, count: Int) -&gt; UnsafeMutablePointer&lt;T&gt;</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-storebytes-of_tobyteoffset_as_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-storebytes-of_tobyteoffset_as_">func storeBytes(<wbr>of:<wbr>toByteOffset:<wbr>as:)</a>
        
<div class="comment collapse" id="comment-func-storebytes-of_tobyteoffset_as_"><div class="p">
    <p>Stores a value&#39;s bytes into raw memory at <code>self + offset</code>.</p>

<p><strong>Precondition:</strong> The underlying pointer plus <code>offset</code> is properly
  aligned for storing type <code>T</code>.</p>

<p><strong>Precondition:</strong> <code>T</code> is a trivial type.</p>

<p><strong>Precondition:</strong> The memory is uninitialized, or initialized to
  some trivial type <code>U</code> such that <code>T</code> and <code>U</code> are mutually layout
  compatible.</p>

<p><strong>Postcondition:</strong> The memory is initialized to raw bytes. If the
  memory is bound to type <code>U</code>, then it now contains a value of
  type <code>U</code>.</p>

<p><strong>Note:</strong> A trivial type can be copied with just a bit-for-bit
  copy without any indirection or reference-counting operations.
  Generally, native Swift types that do not contain strong or
  weak references or other forms of indirection are trivial, as
  are imported C structs and enums.</p>

<p><strong>Note:</strong> Storing a copy of a nontrivial value into memory
  requires that the user know the type of value previously in
  memory, and requires initialization or assignment of the
  memory. This can be achieved via a typed <code>UnsafeMutablePointer</code>
  or via a raw pointer <code>self</code>, as follows, where <code>U</code> is the
  previous type and <code>T</code> is the copied value&#39;s type:
  <code>let typedPtr = self.bindMemory(to: U.self, capacity: 1)</code>
  <code>typedPtr.deinitialize(count: 1)</code>
  <code>self.initializeMemory(as: T.self, to: newValue)</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func storeBytes&lt;T&gt;(of value: T, toByteOffset offset: Int = default, as: T.Type)</code>
    
    
</div></div>
</div>


