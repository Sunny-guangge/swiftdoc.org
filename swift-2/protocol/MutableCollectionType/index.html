---
layout: "default"
title: "MutableCollectionType"
description: "Swift documentation for 'MutableCollectionType': A collection that supports subscript assignment."
keywords: "MutableCollectionType,protocol,swift,documentation"
root: "/swift-2"
---

<code class="language-swift">protocol MutableCollectionType { ... }</code>

<div class="comment">
    <p>A <em>collection</em> that supports subscript assignment.</p>

<p>For any instance <code>a</code> of a type conforming to
<code>MutableCollectionType</code>, :</p>

<pre><code class="language-swift">a[i] = x
let y = a[i]</code></pre>

<p>is equivalent to:</p>

<pre><code class="language-swift">a[i] = x
let y = x</code></pre>
</div>

<h3>Inheritance</h3>
<code class="inherits">CollectionType</code>
<span class="viz"><a href="hierarchy/">Protocol hierarchy</a></span>









<h3>Subscripts</h3>
<div class="declaration">
<code class="language-swift">subscript(position: Self.Index) -> Self.Generator.Element { get set }</code>
</div>


<h3>Default Implementations</h3>



<div class="declaration">
<code class="language-swift">@warn_unused_result(mutable_variant="sortInPlace")
     func sort(isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool) -> [Self.Generator.Element]</code>
<div class="comment">
    <p>Return an <code>Array</code> containing the sorted elements of <code>source</code>
according to <code>isOrderedBefore</code>.</p>

<p>The sorting algorithm is not stable (can change the relative order of
elements for which <code>isOrderedBefore</code> does not establish an order).</p>

<p><strong>Requires:</strong> <code>isOrderedBefore</code> is a
  <a href="http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings">strict weak ordering</a>
  over the elements in <code>self</code>.</p>
</div>
</div>





<h4>Where Index : RandomAccessIndexType</h4>

<div class="declaration">
<code class="language-swift">mutating func partition(range: Range&lt;Self.Index&gt;, isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool) -> Self.Index</code>
<div class="comment">
    <p>Re-order the given <code>range</code> of elements in <code>self</code> and return
a pivot index <em>p</em>.</p>

<p><strong>Postcondition:</strong> for all <em>i</em> in <code>range.startIndex..&lt;</code><em>p</em>, and <em>j</em>
  in <em>p</em><code>..&lt;range.endIndex</code>, <code>less(self[</code><em>i</em><code>],
  self[</code><em>j</em><code>]) &amp;&amp; !less(self[</code><em>j</em><code>], self[</code><em>p</em><code>])</code>.
  Only returns <code>range.endIndex</code> when <code>self</code> is empty.</p>

<p><strong>Requires:</strong> <code>isOrderedBefore</code> is a
  <a href="http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings">strict weak ordering</a>
  over the elements in <code>self</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func sortInPlace(isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool)</code>
<div class="comment">
    <p>Sort <code>self</code> in-place according to <code>isOrderedBefore</code>.</p>

<p>The sorting algorithm is not stable (can change the relative order of
elements for which <code>isOrderedBefore</code> does not establish an order).</p>

<p><strong>Requires:</strong> <code>isOrderedBefore</code> is a
  <a href="http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings">strict weak ordering</a>
  over the elements in <code>self</code>.</p>
</div>
</div>





<h4>Where Index : RandomAccessIndexType, Generator.Element : Comparable</h4>

<div class="declaration">
<code class="language-swift">mutating func partition(range: Range&lt;Self.Index&gt;) -> Self.Index</code>
<div class="comment">
    <p>Re-order the given <code>range</code> of elements in <code>self</code> and return
a pivot index <em>p</em>.</p>

<p><strong>Postcondition:</strong> for all <em>i</em> in <code>range.startIndex..&lt;</code><em>p</em>, and <em>j</em>
  in <em>p</em><code>..&lt;range.endIndex</code>, <code>less(self[</code><em>i</em><code>],
  self[</code><em>j</em><code>]) &amp;&amp; !less(self[</code><em>j</em><code>], self[</code><em>p</em><code>])</code>.
  Only returns <code>range.endIndex</code> when <code>self</code> is empty.</p>

<p><strong>Requires:</strong> The less-than operator (<code>func &lt;</code>) defined in
  the <code>Comparable</code> conformance is a
  <a href="http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings">strict weak ordering</a>
  over the elements in <code>self</code>.</p>
</div>
</div>





<h4>Where Generator.Element : Comparable</h4>

<div class="declaration">
<code class="language-swift">@warn_unused_result(mutable_variant="sortInPlace")
     func sort() -> [Self.Generator.Element]</code>
<div class="comment">
    <p>Return an <code>Array</code> containing the sorted elements of <code>source</code>.</p>

<p>The sorting algorithm is not stable (can change the relative order of
elements that compare equal).</p>

<p><strong>Requires:</strong> The less-than operator (<code>func &lt;</code>) defined in
  the <code>Comparable</code> conformance is a
  <a href="http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings">strict weak ordering</a>
  over the elements in <code>self</code>.</p>
</div>
</div>







<h4>Where Index : RandomAccessIndexType, Self.Generator.Element : Comparable</h4>

<div class="declaration">
<code class="language-swift">mutating func sortInPlace()</code>
<div class="comment">
    <p>Sort <code>self</code> in-place.</p>

<p>The sorting algorithm is not stable (can change the relative order of
elements that compare equal).</p>

<p><strong>Requires:</strong> The less-than operator (<code>func &lt;</code>) defined in
  the <code>Comparable</code> conformance is a
  <a href="http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings">strict weak ordering</a>
  over the elements in <code>self</code>.</p>
</div>
</div>




