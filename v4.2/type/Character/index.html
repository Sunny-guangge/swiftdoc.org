---
layout: "default"
title: "Character"
description: "Swift documentation for 'Character': A single extended grapheme cluster that approximates a user-perceived."
keywords: "Character,struct,swift,documentation,write,customMirror,customPlaygroundQuickLook,debugDescription,description,hashValue,unicodeScalars"
root: "/v4.2"
---

<div class="intro-declaration"><code class="language-swift">struct Character</code></div>

<div class="discussion comment">
    <p>A single extended grapheme cluster that approximates a user-perceived
character.</p>

<p>The <code>Character</code> type represents a character made up of one or more Unicode
scalar values, grouped by a Unicode boundary algorithm. Generally, a
<code>Character</code> instance matches what the reader of a string will perceive as
a single character. Strings are collections of <code>Character</code> instances, so
the number of visible characters is generally the most natural way to
count the length of a string.</p>

<pre><code class="language-swift">let greeting = &quot;Hello! üê•&quot;
print(&quot;Length: \(greeting.count)&quot;)
// Prints &quot;Length: 8&quot;</code></pre>

<p>Because each character in a string can be made up of one or more Unicode
scalar values, the number of characters in a string may not match the
length of the Unicode scalar value representation or the length of the
string in a particular binary representation.</p>

<pre><code class="language-swift">print(&quot;Unicode scalar value count: \(greeting.unicodeScalars.count)&quot;)
// Prints &quot;Unicode scalar value count: 15&quot;

print(&quot;UTF-8 representation count: \(greeting.utf8.count)&quot;)
// Prints &quot;UTF-8 representation count: 18&quot;</code></pre>

<p>Every <code>Character</code> instance is composed of one or more Unicode scalar values
that are grouped together as an <em>extended grapheme cluster</em>. The way these
scalar values are grouped is defined by a canonical, localized, or
otherwise tailored Unicode segmentation algorithm.</p>

<p>For example, a country&#39;s Unicode flag character is made up of two regional
indicator scalar values that correspond to that country&#39;s ISO 3166-1
alpha-2 code. The alpha-2 code for The United States is &quot;US&quot;, so its flag
character is made up of the Unicode scalar values <code>&quot;\u{1F1FA}&quot;</code> (REGIONAL
INDICATOR SYMBOL LETTER U) and <code>&quot;\u{1F1F8}&quot;</code> (REGIONAL INDICATOR SYMBOL
LETTER S). When placed next to each other in a string literal, these two
scalar values are combined into a single grapheme cluster, represented by
a <code>Character</code> instance in Swift.</p>

<pre><code class="language-swift">let usFlag: Character = &quot;\u{1F1FA}\u{1F1F8}&quot;
print(usFlag)
// Prints &quot;üá∫üá∏&quot;</code></pre>

<p>For more information about the Unicode terms used in this discussion, see
the <a href="http://www.unicode.org/glossary/">Unicode.org glossary</a>. In particular, this discussion
mentions <a href="http://www.unicode.org/glossary/#extended_grapheme_cluster">extended grapheme clusters</a> and <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar
values</a>.</p>
</div>

<table class="standard">
<tr>
<th id="inheritance">Inheritance</th>
<td>
<code class="inherits">Comparable, CustomDebugStringConvertible, CustomPlaygroundQuickLookable, CustomReflectable, CustomStringConvertible, Equatable, ExpressibleByExtendedGraphemeClusterLiteral, ExpressibleByUnicodeScalarLiteral, Hashable, LosslessStringConvertible, TextOutputStreamable</code>
<span class="viz"><a href="hierarchy/">View Protocol Hierarchy &rarr;</a></span>
</td>
</tr>


<tr>
<th>Nested Types</th>
<td><code class="nested">Character.UnicodeScalarView, Character.UnicodeScalarView.Index, Character.UnicodeScalarView.Iterator</code></td>
</tr>

<tr>
<th>Import</th>
<td><code class="language-swift">import Swift</code></td>
</tr>

</table>


<h3>Initializers</h3>
<div class="declaration" id="init_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-string">init(<wbr>_: String)</a><div class="comment collapse" id="comment-init_-string"><div class="p">
    <p>Creates a character from a single-character string.</p>

<p>The following example creates a new character from the uppercase version
of a string that only holds one character.</p>

<pre><code class="language-swift">let a = &quot;a&quot;
let capitalA = Character(a.uppercased())</code></pre>

<p><strong><code>s</code>:</strong>  The single-character string to convert to a <code>Character</code>
  instance. <code>s</code> must contain exactly one extended grapheme cluster.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ s: String)</code>

    </div></div>
</div>
<div class="declaration" id="init_-unicode-scalar">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-unicode-scalar">init(<wbr>_: Unicode.Scalar)</a><div class="comment collapse" id="comment-init_-unicode-scalar"><div class="p">
    <p>Creates a character containing the given Unicode scalar value.</p>

<p><strong><code>content</code>:</strong>  The Unicode scalar value to convert into a character.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ content: Unicode.Scalar)</code>

    </div></div>
</div>
<div class="declaration" id="init-extendedgraphemeclusterliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-extendedgraphemeclusterliteral_">init(<wbr>extendedGraphemeClusterLiteral:)</a><div class="comment collapse" id="comment-init-extendedgraphemeclusterliteral_"><div class="p">
    <p>Creates a character with the specified value.</p>

<p>Do not call this initalizer directly. It is used by the compiler when
you use a string literal to initialize a <code>Character</code> instance. For
example:</p>

<pre><code class="language-swift">let oBreve: Character = &quot;o\u{306}&quot;
print(oBreve)
// Prints &quot;≈è&quot;</code></pre>

<p>The assignment to the <code>oBreve</code> constant calls this initializer behind the
scenes.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(extendedGraphemeClusterLiteral value: Character)</code>

    </div></div>
</div>


<h3>Instance Variables</h3>
<div class="declaration" id="var-custommirror_-mirror">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-custommirror_-mirror">var customMirror: Mirror</a><div class="comment collapse" id="comment-var-custommirror_-mirror"><div class="p">
    <p>A mirror that reflects the <code>Character</code> instance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var customMirror: Mirror { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-customplaygroundquicklook_-playgroundquicklook">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-customplaygroundquicklook_-playgroundquicklook">var customPlaygroundQuickLook: PlaygroundQuickLook</a><div class="comment collapse" id="comment-var-customplaygroundquicklook_-playgroundquicklook"><div class="p">
    <p>A custom playground Quick Look for the <code>Character</code> instance.</p>

<p><em>Deprecated:</em> Character.customPlaygroundQuickLook will be removed in a future Swift version.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-debugdescription_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-debugdescription_-string">var debugDescription: String</a><div class="comment collapse" id="comment-var-debugdescription_-string"><div class="p">
    <p>A textual representation of the character, suitable for debugging.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var debugDescription: String { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-description_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-description_-string">var description: String</a><div class="comment collapse" id="comment-var-description_-string"><div class="p">
    <p>A textual representation of this instance.</p>

<p>Calling this property directly is discouraged. Instead, convert an
instance of any type to a string by using the <code>String(describing:)</code>
initializer. This initializer works with any type, and uses the custom
<code>description</code> property for types that conform to
<code>CustomStringConvertible</code>:</p>

<pre><code class="language-swift">struct Point: CustomStringConvertible {
    let x: Int, y: Int

    var description: String {
        return &quot;(\(x), \(y))&quot;
    }
}

let p = Point(x: 21, y: 30)
let s = String(describing: p)
print(s)
// Prints &quot;(21, 30)&quot;</code></pre>

<p>The conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the
<code>Point</code> type&#39;s <code>description</code> property.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var description: String { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-hashvalue_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-hashvalue_-int">var hashValue: Int</a><div class="comment collapse" id="comment-var-hashvalue_-int"><div class="p">
    <p>The character&#39;s hash value.</p>

<p>Hash values are not guaranteed to be equal across different executions of
your program. Do not save hash values to use during a future execution.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var hashValue: Int { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-unicodescalars_-character-unicodescalarview">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-unicodescalars_-character-unicodescalarview">var unicodeScalars: Character.UnicodeScalarView</a><div class="comment collapse" id="comment-var-unicodescalars_-character-unicodescalarview"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">var unicodeScalars: Character.UnicodeScalarView { get }</code>

    </div></div>
</div>



<h3>Instance Methods</h3>
<div class="declaration" id="func-write-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-write-to_">func write(<wbr>to:)</a>
        
<div class="comment collapse" id="comment-func-write-to_"><div class="p">
    <p>Writes the character into the given output stream.</p>

<p><strong><code>target</code>:</strong>  An output stream.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func write&lt;Target&gt;(to target: inout Target)</code>
    
    
</div></div>
</div>


<h3>Conditionally Inherited Items</h3>

<p class="comment">The initializers, methods, and properties listed below may be available on this type under certain conditions (such as methods that are available on <code>Array</code> when its elements are <code>Equatable</code>) or may not ever be available if that determination is beyond SwiftDoc.org's capabilities. Please <a href="https://github.com/SwiftDocOrg/swiftdoc.org/issues">open an issue on GitHub</a> if you see something out of place!</p>





<h4>Where ExtendedGraphemeClusterLiteralType == UnicodeScalarLiteralType</h4>

<div class="declaration inherited" id="extendedgraphemeclusterliteraltype-unicodescalarliteraltype-init-unicodescalarliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-extendedgraphemeclusterliteraltype-unicodescalarliteraltype-init-unicodescalarliteral_">init(<wbr>unicodeScalarLiteral:)</a><div class="comment collapse" id="comment-extendedgraphemeclusterliteraltype-unicodescalarliteraltype-init-unicodescalarliteral_"><div class="p">
    <p>Creates an instance initialized to the given value.</p>

<p><strong><code>value</code>:</strong>  The value of the new instance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(unicodeScalarLiteral value: Character.ExtendedGraphemeClusterLiteralType)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/ExpressibleByExtendedGraphemeClusterLiteral/"><code>ExpressibleByExtendedGraphemeClusterLiteral</code></a>
        </div></div>
</div>






