---
layout: "default"
title: "FixedWidthInteger"
description: "Swift documentation for 'FixedWidthInteger': An integer type that uses a fixed size for every instance."
keywords: "FixedWidthInteger,protocol,swift,documentation,%,%=,&,&<<,&<<=,&=,&>>,&>>=,*,*=,+,+=,/,/=,<,<<,<<=,<=,==,>,>=,>>,>>=,^,^=,|,|=,~,-,-=,addingReportingOverflow,advanced,distance,dividedReportingOverflow,dividingFullWidth,hash,multipliedFullWidth,multipliedReportingOverflow,quotientAndRemainder,remainderReportingOverflow,signum,subtractingReportingOverflow,bigEndian,bitWidth,byteSwapped,leadingZeroBitCount,littleEndian,max,min,nonzeroBitCount,isSigned,trailingZeroBitCount,words,description,hashValue,magnitude,Words,IntegerLiteralType,Magnitude,Stride"
root: "/v4.2"
---

<div class="intro-declaration"><code class="language-swift">protocol FixedWidthInteger</code></div>

<div class="discussion comment">
    <p>An integer type that uses a fixed size for every instance.</p>

<p>The <code>FixedWidthInteger</code> protocol adds binary bitwise operations, bit
shifts, and overflow handling to the operations supported by the
<code>BinaryInteger</code> protocol.</p>

<p>Use the <code>FixedWidthInteger</code> protocol as a constraint or extension point
when writing operations that depend on bit shifting, performing bitwise
operations, catching overflows, or having access to the maximum or minimum
representable value of a type. For example, the following code provides a
<code>binaryString</code> property on every fixed-width integer that represents the
number&#39;s binary representation, split into 8-bit chunks.</p>

<pre><code class="language-swift">extension FixedWidthInteger {
    var binaryString: String {
        var result: [String] = []
        for i in 0..&lt;(Self.bitWidth / 8) {
            let byte = UInt8(truncatingIfNeeded: self &gt;&gt; (i * 8))
            let byteString = String(byte, radix: 2)
            let padding = String(repeating: &quot;0&quot;,
                                 count: 8 - byteString.count)
            result.append(padding + byteString)
        }
        return &quot;0b&quot; + result.reversed().joined(separator: &quot;_&quot;)
    }
}

print(Int16.max.binaryString)
// Prints &quot;0b01111111_11111111&quot;
print((101 as UInt8).binaryString)
// Prints &quot;0b11001001&quot;</code></pre>

<p>The <code>binaryString</code> implementation uses the static <code>bitWidth</code> property and
the right shift operator (<code>&lt;&lt;</code>), both of which are available to any type
that conforms to the <code>FixedWidthInteger</code> protocol.</p>

<p>The next example declares a generic <code>squared</code> function, which accepts an
instance <code>x</code> of any fixed-width integer type. The function uses the
<code>multipliedReportingOverflow(by:)</code> method to multiply <code>x</code> by itself and
check whether the result is too large to represent in the same type.</p>

<pre><code class="language-swift">func squared&lt;T: FixedWidthInteger&gt;(_ x: T) -&gt; T? {
    let (result, overflow) = x.multipliedReportingOverflow(by: x)
    if overflow {
        return nil
    }
    return result
}

let (x, y): (Int8, Int8) = (9, 123)
print(squared(x))
// Prints &quot;Optional(81)&quot;
print(squared(y))
// Prints &quot;nil&quot;</code></pre>

<h1>Conforming to the FixedWidthInteger Protocol</h1>

<p>To make your own custom type conform to the <code>FixedWidthInteger</code> protocol,
declare the required initializers, properties, and methods. The required
methods that are suffixed with <code>ReportingOverflow</code> serve as the
customization points for arithmetic operations. When you provide just those
methods, the standard library provides default implementations for all
other arithmetic methods and operators.</p>
</div>

<table class="standard">
<tr>
<th id="inheritance">Inheritance</th>
<td>
<code class="inherits">BinaryInteger, Comparable, CustomStringConvertible, Equatable, ExpressibleByIntegerLiteral, Hashable, LosslessStringConvertible, Numeric, Strideable, _BitwiseOperations</code>
<span class="viz"><a href="hierarchy/">View Protocol Hierarchy &rarr;</a></span>
</td>
</tr>

<tr>
<th id="aliases">Associated Types</th>
<td>
<span id="aliasesmark"></span>
<div class="declaration inherited">
<code class="language-swift">Words : Sequence</code>
<div class="comment">
    <p>A type that represents the words of a binary integer.</p>

<p>The <code>Words</code> type must conform to the <code>Collection</code> protocol with an
<code>Element</code> type of <code>UInt</code>.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral</code>
<div class="comment">
    <p>A type that represents an integer literal.</p>

<p>The standard library integer and floating-point types are all valid types
for <code>IntegerLiteralType</code>.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">Magnitude : Comparable, Numeric</code>
<div class="comment">
    <p>A type that can represent the absolute value of any possible value of the
conforming type.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">Stride : Comparable, SignedNumeric</code>
<div class="comment">
    <p>A type that represents the distance between two values.</p>
</div>
</div>
</td>
</tr>


<tr>
<th>Import</th>
<td><code class="language-swift">import Swift</code></td>
</tr>

</table>


<h3>Initializers</h3>
<div class="declaration" id="init-bigendian_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-bigendian_">init(<wbr>bigEndian:)</a><div class="comment collapse" id="comment-init-bigendian_"><div class="p">
    <p>Creates an integer from its big-endian representation, changing the byte
order if necessary.</p>

<p><strong><code>value</code>:</strong>  A value to use as the big-endian representation of the
  new integer.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(bigEndian value: Self)</code>

    </div></div>
</div>
<div class="declaration" id="init-littleendian_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-littleendian_">init(<wbr>littleEndian:)</a><div class="comment collapse" id="comment-init-littleendian_"><div class="p">
    <p>Creates an integer from its little-endian representation, changing the
byte order if necessary.</p>

<p><strong><code>value</code>:</strong>  A value to use as the little-endian representation of
  the new integer.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(littleEndian value: Self)</code>

    </div></div>
</div>
<div class="declaration inherited" id="init-t_-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-t_-t">init&lt;T&gt;(<wbr>_: T)</a><div class="comment collapse" id="comment-init-t_-t"><div class="p">
    <p>Creates an integer from the given floating-point value, rounding toward
zero.</p>

<p>Any fractional part of the value passed as <code>source</code> is removed, rounding
the value toward zero.</p>

<pre><code class="language-swift">let x = Int(21.5)
// x == 21
let y = Int(-21.5)
// y == -21</code></pre>

<p>If <code>source</code> is outside the bounds of this type after rounding toward
zero, a runtime error may occur.</p>

<pre><code class="language-swift">let z = UInt(-21.5)
// Error: ...the result would be less than UInt.min</code></pre>

<p><strong><code>source</code>:</strong>  A floating-point value to convert to an integer.
  <code>source</code> must be representable in this type after rounding toward
  zero.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;T&gt;(_ source: T)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-clamping_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-clamping_">init(<wbr>clamping:)</a><div class="comment collapse" id="comment-init-clamping_"><div class="p">
    <p>Creates a new instance with the representable value that&#39;s closest to the
given integer.</p>

<p>If the value passed as <code>source</code> is greater than the maximum representable
value in this type, the result is the type&#39;s <code>max</code> value. If <code>source</code> is
less than the smallest representable value in this type, the result is
the type&#39;s <code>min</code> value.</p>

<p>In this example, <code>x</code> is initialized as an <code>Int8</code> instance by clamping
<code>500</code> to the range <code>-128...127</code>, and <code>y</code> is initialized as a <code>UInt</code>
instance by clamping <code>-500</code> to the range <code>0...UInt.max</code>.</p>

<pre><code class="language-swift">let x = Int8(clamping: 500)
// x == 127
// x == Int8.max

let y = UInt(clamping: -500)
// y == 0</code></pre>

<p><strong><code>source</code>:</strong>  An integer to convert to this type.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;T&gt;(clamping source: T)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-truncatingifneeded_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-truncatingifneeded_">init(<wbr>truncatingIfNeeded:)</a><div class="comment collapse" id="comment-init-truncatingifneeded_"><div class="p">
    <p>Creates a new instance from the bit pattern of the given instance by
sign-extending or truncating to fit this type.</p>

<p>When the bit width of <code>T</code> (the type of <code>source</code>) is equal to or greater
than this type&#39;s bit width, the result is the truncated
least-significant bits of <code>source</code>. For example, when converting a
16-bit value to an 8-bit type, only the lower 8 bits of <code>source</code> are
used.</p>

<pre><code class="language-swift">let p: Int16 = -500
// &#39;p&#39; has a binary representation of 11111110_00001100
let q = Int8(truncatingIfNeeded: p)
// q == 12
// &#39;q&#39; has a binary representation of 00001100</code></pre>

<p>When the bit width of <code>T</code> is less than this type&#39;s bit width, the result
is <em>sign-extended</em> to fill the remaining bits. That is, if <code>source</code> is
negative, the result is padded with ones; otherwise, the result is
padded with zeros.</p>

<pre><code class="language-swift">let u: Int8 = 21
// &#39;u&#39; has a binary representation of 00010101
let v = Int16(truncatingIfNeeded: u)
// v == 21
// &#39;v&#39; has a binary representation of 00000000_00010101

let w: Int8 = -21
// &#39;w&#39; has a binary representation of 11101011
let x = Int16(truncatingIfNeeded: w)
// x == -21
// &#39;x&#39; has a binary representation of 11111111_11101011
let y = UInt16(truncatingIfNeeded: w)
// y == 65515
// &#39;y&#39; has a binary representation of 11111111_11101011</code></pre>

<p><strong><code>source</code>:</strong>  An integer to convert to this type.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;T&gt;(truncatingIfNeeded source: T)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-exactly_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-exactly_">init?(<wbr>exactly:)</a><div class="comment collapse" id="comment-init-exactly_"><div class="p">
    <p>Creates an integer from the given floating-point value, if it can be
represented exactly.</p>

<p>If the value passed as <code>source</code> is not representable exactly, the result
is <code>nil</code>. In the following example, the constant <code>x</code> is successfully
created from a value of <code>21.0</code>, while the attempt to initialize the
constant <code>y</code> from <code>21.5</code> fails:</p>

<pre><code class="language-swift">let x = Int(exactly: 21.0)
// x == Optional(21)
let y = Int(exactly: 21.5)
// y == nil</code></pre>

<p><strong><code>source</code>:</strong>  A floating-point value to convert to an integer.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?&lt;T&gt;(exactly source: T)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        ,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-integerliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-integerliteral_">init(<wbr>integerLiteral:)</a><div class="comment collapse" id="comment-init-integerliteral_"><div class="p">
    <p>Creates an instance initialized to the specified integer value.</p>

<p>Do not call this initializer directly. Instead, initialize a variable or
constant using an integer literal. For example:</p>

<pre><code class="language-swift">let x = 23</code></pre>

<p>In this example, the assignment to the <code>x</code> constant calls this integer
literal initializer behind the scenes.</p>

<p><strong><code>value</code>:</strong>  The value to create.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(integerLiteral value: Self.IntegerLiteralType)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/ExpressibleByIntegerLiteral/"><code>ExpressibleByIntegerLiteral</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_">init?(<wbr>_:)</a><div class="comment collapse" id="comment-init_"><div class="p">
    <p>Instantiates an instance of the conforming type from a string
representation.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?(_ description: String)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/LosslessStringConvertible/"><code>LosslessStringConvertible</code></a>
        </div></div>
</div>

<h3>Static Variables</h3>
<div class="declaration" id="static-var-bitwidth_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-bitwidth_-int">static var bitWidth: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-bitwidth_-int"><div class="p">
    <p>The number of bits used for the underlying binary representation of
values of this type.</p>

<p>An unsigned, fixed-width integer type can represent values from 0 through
<code>(2 ** bitWidth) - 1</code>, where <code>**</code> is exponentiation. A signed,
fixed-width integer type can represent values from
<code>-(2 ** (bitWidth - 1))</code> through <code>(2 ** (bitWidth - 1)) - 1</code>. For example,
the <code>Int8</code> type has a <code>bitWidth</code> value of 8 and can store any integer in
the range <code>-128...127</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var bitWidth: Int { get }</code>

    </div></div>
</div>
<div class="declaration" id="static-var-max_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-max_-self">static var max: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-max_-self"><div class="p">
    <p>The maximum representable integer in this type.</p>

<p>For unsigned integer types, this value is <code>(2 ** bitWidth) - 1</code>, where
<code>**</code> is exponentiation. For signed integer types, this value is
<code>(2 ** (bitWidth - 1)) - 1</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var max: Self { get }</code>

    </div></div>
</div>
<div class="declaration" id="static-var-min_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-min_-self">static var min: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-min_-self"><div class="p">
    <p>The minimum representable integer in this type.</p>

<p>For unsigned integer types, this value is always <code>0</code>. For signed integer
types, this value is <code>-(2 ** (bitWidth - 1))</code>, where <code>**</code> is
exponentiation.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var min: Self { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="static-var-issigned_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-issigned_-bool">static var isSigned: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-issigned_-bool"><div class="p">
    <p>A Boolean value indicating whether this type is a signed integer type.</p>

<p><em>Signed</em> integer types can represent both positive and negative values.
<em>Unsigned</em> integer types can represent only nonnegative values.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var isSigned: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        </div></div>
</div>

<h3>Instance Variables</h3>
<div class="declaration" id="var-bigendian_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-bigendian_-self">var bigEndian: Self</a><div class="comment collapse" id="comment-var-bigendian_-self"><div class="p">
    <p>The big-endian representation of this integer.</p>

<p>If necessary, the byte order of this value is reversed from the typical
byte order of this integer type. On a big-endian platform, for any
integer <code>x</code>, <code>x == x.bigEndian</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var bigEndian: Self { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-byteswapped_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-byteswapped_-self">var byteSwapped: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-byteswapped_-self"><div class="p">
    <p>A representation of this integer with the byte order swapped.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var byteSwapped: Self { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-leadingzerobitcount_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-leadingzerobitcount_-int">var leadingZeroBitCount: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-leadingzerobitcount_-int"><div class="p">
    <p>The number of leading zeros in this value&#39;s binary representation.</p>

<p>For example, in a fixed-width integer type with a <code>bitWidth</code> value of 8,
the number <em>31</em> has three leading zeros.</p>

<pre><code class="language-swift">let x: Int8 = 0b0001_1111
// x == 31
// x.leadingZeroBitCount == 3</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var leadingZeroBitCount: Int { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-littleendian_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-littleendian_-self">var littleEndian: Self</a><div class="comment collapse" id="comment-var-littleendian_-self"><div class="p">
    <p>The little-endian representation of this integer.</p>

<p>If necessary, the byte order of this value is reversed from the typical
byte order of this integer type. On a little-endian platform, for any
integer <code>x</code>, <code>x == x.littleEndian</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var littleEndian: Self { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-nonzerobitcount_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-nonzerobitcount_-int">var nonzeroBitCount: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-nonzerobitcount_-int"><div class="p">
    <p>The number of bits equal to 1 in this value&#39;s binary representation.</p>

<p>For example, in a fixed-width integer type with a <code>bitWidth</code> value of 8,
the number <em>31</em> has five bits equal to <em>1</em>.</p>

<pre><code class="language-swift">let x: Int8 = 0b0001_1111
// x == 31
// x.nonzeroBitCount == 5</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var nonzeroBitCount: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="var-trailingzerobitcount_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-trailingzerobitcount_-int">var trailingZeroBitCount: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-trailingzerobitcount_-int"><div class="p">
    <p>The number of trailing zeros in this value&#39;s binary representation.</p>

<p>For example, in a fixed-width integer type with a <code>bitWidth</code> value of 8,
the number -8 has three trailing zeros.</p>

<pre><code class="language-swift">let x = Int8(bitPattern: 0b1111_1000)
// x == -8
// x.trailingZeroBitCount == 3</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var trailingZeroBitCount: Int { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-words_-self-words">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-words_-self-words">var words: Self.Words</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-words_-self-words"><div class="p">
    <p>A collection containing the words of this value&#39;s binary
representation, in order from the least significant to most significant.</p>

<p>Negative values are returned in two&#39;s complement representation,
regardless of the type&#39;s underlying implementation.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var words: Self.Words { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-description_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-description_-string">var description: String</a><div class="comment collapse" id="comment-var-description_-string"><div class="p">
    <p>A textual representation of this instance.</p>

<p>Calling this property directly is discouraged. Instead, convert an
instance of any type to a string by using the <code>String(describing:)</code>
initializer. This initializer works with any type, and uses the custom
<code>description</code> property for types that conform to
<code>CustomStringConvertible</code>:</p>

<pre><code class="language-swift">struct Point: CustomStringConvertible {
    let x: Int, y: Int

    var description: String {
        return &quot;(\(x), \(y))&quot;
    }
}

let p = Point(x: 21, y: 30)
let s = String(describing: p)
print(s)
// Prints &quot;(21, 30)&quot;</code></pre>

<p>The conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the
<code>Point</code> type&#39;s <code>description</code> property.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var description: String { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/CustomStringConvertible/"><code>CustomStringConvertible</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-hashvalue_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-hashvalue_-int">var hashValue: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-hashvalue_-int"><div class="p">
    <p>The hash value.</p>

<p>Hash values are not guaranteed to be equal across different executions of
your program. Do not save hash values to use during a future execution.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var hashValue: Int { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Hashable/"><code>Hashable</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-magnitude_-self-magnitude">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-magnitude_-self-magnitude">var magnitude: Self.Magnitude</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-magnitude_-self-magnitude"><div class="p">
    <p>The magnitude of this value.</p>

<p>For any numeric value <code>x</code>, <code>x.magnitude</code> is the absolute value of <code>x</code>.
You can use the <code>magnitude</code> property in operations that are simpler to
implement in terms of unsigned values, such as printing the value of an
integer, which is just printing a &#39;-&#39; character in front of an absolute
value.</p>

<pre><code class="language-swift">let x = -200
// x.magnitude == 200</code></pre>

<p>The global <code>abs(_:)</code> function provides more familiar syntax when you need
to find an absolute value. In addition, because <code>abs(_:)</code> always returns
a value of the same type, even in a generic context, using the function
instead of the <code>magnitude</code> property is encouraged.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var magnitude: Self.Magnitude { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Numeric/"><code>Numeric</code></a>
        </div></div>
</div>



<h3>Instance Methods</h3>
<div class="declaration inherited" id="func-pct_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-pct_rhs_">func %(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-pct_rhs_"><div class="p">
    <p>Returns the remainder of dividing the first value by the second.</p>

<p>The result of the modulo operator (<code>%</code>) has the same sign as <code>lhs</code> and is
less than <code>rhs.magnitude</code>.</p>

<pre><code class="language-swift">let x = 22 % 5
// x == 2
let y = 22 % -5
// y == 2
let z = -22 % -5
// z == -2</code></pre>

<p>For any two integers <code>a</code> and <code>b</code>, their quotient <code>q</code>, and their remainder
<code>r</code>, <code>a == b * q + r</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to divide.
  <strong>rhs:</strong> The value to divide <code>lhs</code> by. <code>rhs</code> must not be zero.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func %(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-pcteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-pcteq_rhs_">func %=(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-pcteq_rhs_"><div class="p">
    <p>Divides the first value by the second and stores the remainder in the
left-hand-side variable.</p>

<p>The result has the same sign as <code>lhs</code> and is less than <code>rhs.magnitude</code>.</p>

<pre><code class="language-swift">var x = 22
x %= 5
// x == 2

var y = 22
y %= -5
// y == 2

var z = -22
z %= -5
// z == -2</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to divide.
  <strong>rhs:</strong> The value to divide <code>lhs</code> by. <code>rhs</code> must not be zero.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func %=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-amp_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-amp_rhs_">func &amp;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-amp_rhs_"><div class="p">
    <p>Returns the result of performing a bitwise AND operation on the two given
values.</p>

<p>A bitwise AND operation results in a value that has each bit set to <code>1</code>
where <em>both</em> of its arguments have that bit set to <code>1</code>. For example:</p>

<pre><code class="language-swift">let x: UInt8 = 5          // 0b00000101
let y: UInt8 = 14         // 0b00001110
let z = x &amp; y             // 0b00000100
// z == 4</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer value.
  <strong>rhs:</strong> Another integer value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func-ampltlt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-ampltlt_rhs_">func &amp;&lt;&lt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-ampltlt_rhs_"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the left, masking the shift amount to the
type&#39;s bit width.</p>

<p>Use the masking left shift operator (<code>&amp;&lt;&lt;</code>) when you need to perform a
shift and are sure that the shift amount is in the range
<code>0..&lt;lhs.bitWidth</code>. Before shifting, the masking left shift operator
masks the shift to this range. The shift is performed using this masked
value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &amp;&lt;&lt; 2
// y == 120                       // 0b01111000</code></pre>

<p>However, if you use <code>8</code> as the shift amount, the method first masks the
shift amount to zero, and then performs the shift, resulting in no change
to the original value.</p>

<pre><code class="language-swift">let z = x &amp;&lt;&lt; 8
// z == 30                        // 0b00011110</code></pre>

<p>If the bit width of the shifted integer type is a power of two, masking
is performed using a bitmask; otherwise, masking is performed using a
modulo operation.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the left. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&lt;&lt;(lhs: Self, rhs: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-ampltlteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-ampltlteq_rhs_">func &amp;&lt;&lt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-ampltlteq_rhs_"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the left, masking the shift amount to the
type&#39;s bit width, and stores the result in the left-hand-side variable.</p>

<p>The <code>&amp;&lt;&lt;=</code> operator performs a <em>masking shift</em>, where the value used as
<code>rhs</code> is masked to produce a value in the range <code>0..&lt;lhs.bitWidth</code>. The
shift is performed using this masked value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">var x: UInt8 = 30                 // 0b00011110
x &amp;&lt;&lt;= 2
// x == 120                       // 0b01111000</code></pre>

<p>However, if you pass <code>19</code> as <code>rhs</code>, the method first bitmasks <code>rhs</code> to
<code>3</code>, and then uses that masked value as the number of bits to shift <code>lhs</code>.</p>

<pre><code class="language-swift">var y: UInt8 = 30                 // 0b00011110
y &amp;&lt;&lt;= 19
// y == 240                       // 0b11110000</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the left. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&lt;&lt;=(lhs: inout Self, rhs: Self)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-ampeq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-ampeq_rhs_">func &amp;=(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-ampeq_rhs_"><div class="p">
    <p>Stores the result of performing a bitwise AND operation on the two given
values in the left-hand-side variable.</p>

<p>A bitwise AND operation results in a value that has each bit set to <code>1</code>
where <em>both</em> of its arguments have that bit set to <code>1</code>. For example:</p>

<pre><code class="language-swift">var x: UInt8 = 5          // 0b00000101
let y: UInt8 = 14         // 0b00001110
x &amp;= y                    // 0b00000100</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer value.
  <strong>rhs:</strong> Another integer value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func-ampgtgt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-ampgtgt_rhs_">func &amp;&gt;&gt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-ampgtgt_rhs_"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the right, masking the shift amount to the
type&#39;s bit width.</p>

<p>Use the masking right shift operator (<code>&amp;&gt;&gt;</code>) when you need to perform a
shift and are sure that the shift amount is in the range
<code>0..&lt;lhs.bitWidth</code>. Before shifting, the masking right shift operator
masks the shift to this range. The shift is performed using this masked
value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &amp;&gt;&gt; 2
// y == 7                         // 0b00000111</code></pre>

<p>However, if you use <code>8</code> as the shift amount, the method first masks the
shift amount to zero, and then performs the shift, resulting in no change
to the original value.</p>

<pre><code class="language-swift">let z = x &amp;&gt;&gt; 8
// z == 30                        // 0b00011110</code></pre>

<p>If the bit width of the shifted integer type is a power of two, masking
is performed using a bitmask; otherwise, masking is performed using a
modulo operation.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the right. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&gt;&gt;(lhs: Self, rhs: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-ampgtgteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-ampgtgteq_rhs_">func &amp;&gt;&gt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-ampgtgteq_rhs_"><div class="p">
    <p>Calculates the result of shifting a value&#39;s binary representation the
specified number of digits to the right, masking the shift amount to the
type&#39;s bit width, and stores the result in the left-hand-side variable.</p>

<p>The <code>&amp;&gt;&gt;=</code> operator performs a <em>masking shift</em>, where the value passed as
<code>rhs</code> is masked to produce a value in the range <code>0..&lt;lhs.bitWidth</code>. The
shift is performed using this masked value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">var x: UInt8 = 30                 // 0b00011110
x &amp;&gt;&gt;= 2
// x == 7                         // 0b00000111</code></pre>

<p>However, if you use <code>19</code> as <code>rhs</code>, the operation first bitmasks <code>rhs</code> to
<code>3</code>, and then uses that masked value as the number of bits to shift <code>lhs</code>.</p>

<pre><code class="language-swift">var y: UInt8 = 30                 // 0b00011110
y &amp;&gt;&gt;= 19
// y == 3                         // 0b00000011</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the right. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&gt;&gt;=(lhs: inout Self, rhs: Self)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-star_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-star_rhs_">func *(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-star_rhs_"><div class="p">
    <p>Multiplies two values and produces their product.</p>

<p>The multiplication operator (<code>*</code>) calculates the product of its two
arguments. For example:</p>

<pre><code class="language-swift">2 * 3                   // 6
100 * 21                // 2100
-10 * 15                // -150
3.5 * 2.25              // 7.875</code></pre>

<p>You cannot use <code>*</code> with arguments of different types. To multiply values
of different types, convert one of the values to the other value&#39;s type.</p>

<pre><code class="language-swift">let x: Int8 = 21
let y: Int = 1000000
Int(x) * y              // 21000000</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to multiply.
  <strong>rhs:</strong> The second value to multiply.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func *(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-stareq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-stareq_rhs_">func *=(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-stareq_rhs_"><div class="p">
    <p>Multiplies two values and stores the result in the left-hand-side
variable.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to multiply.
  <strong>rhs:</strong> The second value to multiply.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func *=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-pls_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-pls_rhs_">func +(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-pls_rhs_"><div class="p">
    <p>Adds two values and produces their sum.</p>

<p>The addition operator (<code>+</code>) calculates the sum of its two arguments. For
example:</p>

<pre><code class="language-swift">1 + 2                   // 3
-10 + 15                // 5
-15 + -5                // -20
21.5 + 3.25             // 24.75</code></pre>

<p>You cannot use <code>+</code> with arguments of different types. To add values of
different types, convert one of the values to the other value&#39;s type.</p>

<pre><code class="language-swift">let x: Int8 = 21
let y: Int = 1000000
Int(x) + y              // 1000021</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to add.
  <strong>rhs:</strong> The second value to add.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func +(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-plseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-plseq_rhs_">func +=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-plseq_rhs_"><div class="p">
    <p>Adds two values and stores the result in the left-hand-side variable.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to add.
  <strong>rhs:</strong> The second value to add.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func +=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-slash_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-slash_rhs_">func /(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-slash_rhs_"><div class="p">
    <p>Returns the quotient of dividing the first value by the second.</p>

<p>For integer types, any remainder of the division is discarded.</p>

<pre><code class="language-swift">let x = 21 / 5
// x == 4</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to divide.
  <strong>rhs:</strong> The value to divide <code>lhs</code> by. <code>rhs</code> must not be zero.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func /(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-slasheq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-slasheq_rhs_">func /=(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-slasheq_rhs_"><div class="p">
    <p>Divides the first value by the second and stores the quotient in the
left-hand-side variable.</p>

<p>For integer types, any remainder of the division is discarded.</p>

<pre><code class="language-swift">var x = 21
x /= 5
// x == 4</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to divide.
  <strong>rhs:</strong> The value to divide <code>lhs</code> by. <code>rhs</code> must not be zero.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func /=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-lt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-lt_rhs_">func &lt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-lt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.</p>

<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-ltlt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-ltlt_rhs_">func &lt;&lt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-ltlt_rhs_"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the left.</p>

<p>The <code>&lt;&lt;</code> operator performs a <em>smart shift</em>, which defines a result for a
shift of any value.</p>

<ul><li>Using a negative value for <code>rhs</code> performs a right shift using
<code>abs(rhs)</code>.</li><li>Using a value for <code>rhs</code> that is greater than or equal to the bit width
of <code>lhs</code> is an <em>overshift</em>, resulting in zero.</li><li>Using any other value for <code>rhs</code> performs a left shift on <code>lhs</code> by that
amount.</li></ul>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the value is shifted left by two bits.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &lt;&lt; 2
// y == 120                       // 0b01111000</code></pre>

<p>If you use <code>11</code> as <code>rhs</code>, <code>x</code> is overshifted such that all of its bits
are set to zero.</p>

<pre><code class="language-swift">let z = x &lt;&lt; 11
// z == 0                         // 0b00000000</code></pre>

<p>Using a negative value as <code>rhs</code> is the same as performing a right shift
with <code>abs(rhs)</code>.</p>

<pre><code class="language-swift">let a = x &lt;&lt; -3
// a == 3                         // 0b00000011
let b = x &gt;&gt; 3
// b == 3                         // 0b00000011</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the left.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;&lt;&lt;RHS&gt;(lhs: Self, rhs: RHS) -&gt; Self where RHS : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-ltlteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-ltlteq_rhs_">func &lt;&lt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-ltlteq_rhs_"><div class="p">
    <p>Stores the result of shifting a value&#39;s binary representation the
specified number of digits to the left in the left-hand-side variable.</p>

<p>The <code>&lt;&lt;</code> operator performs a <em>smart shift</em>, which defines a result for a
shift of any value.</p>

<ul><li>Using a negative value for <code>rhs</code> performs a right shift using
<code>abs(rhs)</code>.</li><li>Using a value for <code>rhs</code> that is greater than or equal to the bit width
of <code>lhs</code> is an <em>overshift</em>, resulting in zero.</li><li>Using any other value for <code>rhs</code> performs a left shift on <code>lhs</code> by that
amount.</li></ul>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the value is shifted left by two bits.</p>

<pre><code class="language-swift">var x: UInt8 = 30                 // 0b00011110
x &lt;&lt;= 2
// x == 120                       // 0b01111000</code></pre>

<p>If you use <code>11</code> as <code>rhs</code>, <code>x</code> is overshifted such that all of its bits
are set to zero.</p>

<pre><code class="language-swift">var y: UInt8 = 30                 // 0b00011110
y &lt;&lt;= 11
// y == 0                         // 0b00000000</code></pre>

<p>Using a negative value as <code>rhs</code> is the same as performing a right shift
with <code>abs(rhs)</code>.</p>

<pre><code class="language-swift">var a: UInt8 = 30                 // 0b00011110
a &lt;&lt;= -3
// a == 3                         // 0b00000011

var b: UInt8 = 30                 // 0b00011110
b &gt;&gt;= 3
// b == 3                         // 0b00000011</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the left.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;&lt;=&lt;RHS&gt;(lhs: inout Self, rhs: RHS)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-lteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-lteq_rhs_">func &lt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-lteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-eqeq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-eqeq_rhs_">func ==(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-eqeq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether two values are equal.</p>

<p>Equality is the inverse of inequality. For any values <code>a</code> and <code>b</code>,
<code>a == b</code> implies that <code>a != b</code> is <code>false</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ==(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Equatable/"><code>Equatable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-gt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-gt_rhs_">func &gt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-gt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-gteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-gteq_rhs_">func &gt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-gteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-gtgt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-gtgt_rhs_">func &gt;&gt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-gtgt_rhs_"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the right.</p>

<p>The <code>&gt;&gt;</code> operator performs a <em>smart shift</em>, which defines a result for a
shift of any value.</p>

<ul><li>Using a negative value for <code>rhs</code> performs a left shift using
<code>abs(rhs)</code>.</li><li>Using a value for <code>rhs</code> that is greater than or equal to the bit width
of <code>lhs</code> is an <em>overshift</em>. An overshift results in <code>-1</code> for a
negative value of <code>lhs</code> or <code>0</code> for a nonnegative value.</li><li>Using any other value for <code>rhs</code> performs a right shift on <code>lhs</code> by that
amount.</li></ul>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the value is shifted right by two bits.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &gt;&gt; 2
// y == 7                         // 0b00000111</code></pre>

<p>If you use <code>11</code> as <code>rhs</code>, <code>x</code> is overshifted such that all of its bits
are set to zero.</p>

<pre><code class="language-swift">let z = x &gt;&gt; 11
// z == 0                         // 0b00000000</code></pre>

<p>Using a negative value as <code>rhs</code> is the same as performing a left shift
using <code>abs(rhs)</code>.</p>

<pre><code class="language-swift">let a = x &gt;&gt; -3
// a == 240                       // 0b11110000
let b = x &lt;&lt; 3
// b == 240                       // 0b11110000</code></pre>

<p>Right shift operations on negative values &quot;fill in&quot; the high bits with
ones instead of zeros.</p>

<pre><code class="language-swift">let q: Int8 = -30                 // 0b11100010
let r = q &gt;&gt; 2
// r == -8                        // 0b11111000

let s = q &gt;&gt; 11
// s == -1                        // 0b11111111</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the right.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;&gt;&lt;RHS&gt;(lhs: Self, rhs: RHS) -&gt; Self where RHS : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-gtgteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-gtgteq_rhs_">func &gt;&gt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-gtgteq_rhs_"><div class="p">
    <p>Stores the result of shifting a value&#39;s binary representation the
specified number of digits to the right in the left-hand-side variable.</p>

<p>The <code>&gt;&gt;=</code> operator performs a <em>smart shift</em>, which defines a result for a
shift of any value.</p>

<ul><li>Using a negative value for <code>rhs</code> performs a left shift using
<code>abs(rhs)</code>.</li><li>Using a value for <code>rhs</code> that is greater than or equal to the bit width
of <code>lhs</code> is an <em>overshift</em>. An overshift results in <code>-1</code> for a
negative value of <code>lhs</code> or <code>0</code> for a nonnegative value.</li><li>Using any other value for <code>rhs</code> performs a right shift on <code>lhs</code> by that
amount.</li></ul>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the value is shifted right by two bits.</p>

<pre><code class="language-swift">var x: UInt8 = 30                 // 0b00011110
x &gt;&gt;= 2
// x == 7                         // 0b00000111</code></pre>

<p>If you use <code>11</code> as <code>rhs</code>, <code>x</code> is overshifted such that all of its bits
are set to zero.</p>

<pre><code class="language-swift">var y: UInt8 = 30                 // 0b00011110
y &gt;&gt;= 11
// y == 0                         // 0b00000000</code></pre>

<p>Using a negative value as <code>rhs</code> is the same as performing a left shift
using <code>abs(rhs)</code>.</p>

<pre><code class="language-swift">var a: UInt8 = 30                 // 0b00011110
a &gt;&gt;= -3
// a == 240                       // 0b11110000

var b: UInt8 = 30                 // 0b00011110
b &lt;&lt;= 3
// b == 240                       // 0b11110000</code></pre>

<p>Right shift operations on negative values &quot;fill in&quot; the high bits with
ones instead of zeros.</p>

<pre><code class="language-swift">var q: Int8 = -30                 // 0b11100010
q &gt;&gt;= 2
// q == -8                        // 0b11111000

var r: Int8 = -30                 // 0b11100010
r &gt;&gt;= 11
// r == -1                        // 0b11111111</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the right.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;&gt;=&lt;RHS&gt;(lhs: inout Self, rhs: RHS)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-crt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-crt_rhs_">func ^(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-crt_rhs_"><div class="p">
    <p>Returns the result of performing a bitwise XOR operation on the two given
values.</p>

<p>A bitwise XOR operation, also known as an exclusive OR operation, results
in a value that has each bit set to <code>1</code> where <em>one or the other but not
both</em> of its arguments had that bit set to <code>1</code>. For example:</p>

<pre><code class="language-swift">let x: UInt8 = 5          // 0b00000101
let y: UInt8 = 14         // 0b00001110
let z = x ^ y             // 0b00001011
// z == 11</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer value.
  <strong>rhs:</strong> Another integer value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ^(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-crteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-crteq_rhs_">func ^=(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-crteq_rhs_"><div class="p">
    <p>Stores the result of performing a bitwise XOR operation on the two given
values in the left-hand-side variable.</p>

<p>A bitwise XOR operation, also known as an exclusive OR operation, results
in a value that has each bit set to <code>1</code> where <em>one or the other but not
both</em> of its arguments had that bit set to <code>1</code>. For example:</p>

<pre><code class="language-swift">var x: UInt8 = 5          // 0b00000101
let y: UInt8 = 14         // 0b00001110
x ^= y                    // 0b00001011</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer value.
  <strong>rhs:</strong> Another integer value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ^=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-bar_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-bar_rhs_">func |(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-bar_rhs_"><div class="p">
    <p>Returns the result of performing a bitwise OR operation on the two given
values.</p>

<p>A bitwise OR operation results in a value that has each bit set to <code>1</code>
where <em>one or both</em> of its arguments have that bit set to <code>1</code>. For
example:</p>

<pre><code class="language-swift">let x: UInt8 = 5          // 0b00000101
let y: UInt8 = 14         // 0b00001110
let z = x | y             // 0b00001111
// z == 15</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer value.
  <strong>rhs:</strong> Another integer value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func |(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-bareq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-bareq_rhs_">func |=(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-bareq_rhs_"><div class="p">
    <p>Stores the result of performing a bitwise OR operation on the two given
values in the left-hand-side variable.</p>

<p>A bitwise OR operation results in a value that has each bit set to <code>1</code>
where <em>one or both</em> of its arguments have that bit set to <code>1</code>. For
example:</p>

<pre><code class="language-swift">var x: UInt8 = 5          // 0b00000101
let y: UInt8 = 14         // 0b00001110
x |= y                    // 0b00001111</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer value.
  <strong>rhs:</strong> Another integer value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func |=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-tilde_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-tilde_">prefix func ~(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-tilde_"><div class="p">
    <p>Returns the inverse of the bits set in the argument.</p>

<p>The bitwise NOT operator (<code>~</code>) is a prefix operator that returns a value
in which all the bits of its argument are flipped: Bits that are <code>1</code> in
the argument are <code>0</code> in the result, and bits that are <code>0</code> in the argument
are <code>1</code> in the result. This is equivalent to the inverse of a set. For
example:</p>

<pre><code class="language-swift">let x: UInt8 = 5        // 0b00000101
let notX = ~x           // 0b11111010</code></pre>

<p>Performing a bitwise NOT operation on 0 returns a value with every bit
set to <code>1</code>.</p>

<pre><code class="language-swift">let allOnes = ~UInt8.min   // 0b11111111</code></pre>

<p><strong>Complexity:</strong> O(1).</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func ~(x: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-mns_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-mns_rhs_">func -(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-mns_rhs_"><div class="p">
    <p>Subtracts one value from another and produces their difference.</p>

<p>The subtraction operator (<code>-</code>) calculates the difference of its two
arguments. For example:</p>

<pre><code class="language-swift">8 - 3                   // 5
-10 - 5                 // -15
100 - -5                // 105
10.5 - 100.0            // -89.5</code></pre>

<p>You cannot use <code>-</code> with arguments of different types. To subtract values
of different types, convert one of the values to the other value&#39;s type.</p>

<pre><code class="language-swift">let x: UInt8 = 21
let y: UInt = 1000000
y - UInt(x)             // 999979</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A numeric value.
  <strong>rhs:</strong> The value to subtract from <code>lhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func -(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-mnseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-mnseq_rhs_">func -=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-mnseq_rhs_"><div class="p">
    <p>Subtracts the second value from the first and stores the difference in the
left-hand-side variable.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A numeric value.
  <strong>rhs:</strong> The value to subtract from <code>lhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func -=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration" id="func-addingreportingoverflow_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-addingreportingoverflow_">func addingReportingOverflow(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-addingreportingoverflow_"><div class="p">
    <p>Returns the sum of this value and the given value, along with a Boolean
value indicating whether overflow occurred in the operation.</p>

<p><strong><code>rhs</code>:</strong>  The value to add to this value.
<strong>Returns:</strong> A tuple containing the result of the addition along with a
  Boolean value indicating whether overflow occurred. If the <code>overflow</code>
  component is <code>false</code>, the <code>partialValue</code> component contains the entire
  sum. If the <code>overflow</code> component is <code>true</code>, an overflow occurred and
  the <code>partialValue</code> component contains the truncated sum of this value
  and <code>rhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func addingReportingOverflow(_ rhs: Self) -&gt; (partialValue: Self, overflow: Bool)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-advanced-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-advanced-by_">func advanced(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-advanced-by_"><div class="p">
    <p>Returns a value that is offset the specified distance from this value.</p>

<p>Use the <code>advanced(by:)</code> method in generic code to offset a value by a
specified distance. If you&#39;re working directly with numeric values, use
the addition operator (<code>+</code>) instead of this method.</p>

<pre><code class="language-swift">func addOne&lt;T: Strideable&gt;(to x: T) -&gt; T
    where T.Stride : ExpressibleByIntegerLiteral
{
    return x.advanced(by: 1)
}

let x = addOne(to: 5)
// x == 6
let y = addOne(to: 3.5)
// y = 4.5</code></pre>

<p>If this type&#39;s <code>Stride</code> type conforms to <code>BinaryInteger</code>, then for a
value <code>x</code>, a distance <code>n</code>, and a value <code>y = x.advanced(by: n)</code>,
<code>x.distance(to: y) == n</code>. Using this method with types that have a
noninteger <code>Stride</code> may result in an approximation.</p>

<p><strong><code>n</code>:</strong>  The distance to advance this value.
<strong>Returns:</strong> A value that is offset from this value by <code>n</code>.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func advanced(by n: Self.Stride) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-distance-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-distance-to_">func distance(<wbr>to:)</a>
        
<div class="comment collapse" id="comment-func-distance-to_"><div class="p">
    <p>Returns the distance from this value to the given value, expressed as a 
stride.</p>

<p>If this type&#39;s <code>Stride</code> type conforms to <code>BinaryInteger</code>, then for two
values <code>x</code> and <code>y</code>, and a distance <code>n = x.distance(to: y)</code>,
<code>x.advanced(by: n) == y</code>. Using this method with types that have a
noninteger <code>Stride</code> may result in an approximation.</p>

<p><strong><code>other</code>:</strong>  The value to calculate the distance to.
<strong>Returns:</strong> The distance from this value to <code>other</code>.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance(to other: Self) -&gt; Self.Stride</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration" id="func-dividedreportingoverflow-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-dividedreportingoverflow-by_">func dividedReportingOverflow(<wbr>by:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-dividedreportingoverflow-by_"><div class="p">
    <p>Returns the quotient obtained by dividing this value by the given value,
along with a Boolean value indicating whether overflow occurred in the
operation.</p>

<p>Dividing by zero is not an error when using this method. For a value <code>x</code>,
the result of <code>x.dividedReportingOverflow(by: 0)</code> is <code>(x, true)</code>.</p>

<p><strong><code>rhs</code>:</strong>  The value to divide this value by.
<strong>Returns:</strong> A tuple containing the result of the division along with a
  Boolean value indicating whether overflow occurred. If the <code>overflow</code>
  component is <code>false</code>, the <code>partialValue</code> component contains the entire
  quotient. If the <code>overflow</code> component is <code>true</code>, an overflow occurred
  and the <code>partialValue</code> component contains either the truncated quotient
  or, if the quotient is undefined, the dividend.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dividedReportingOverflow(by rhs: Self) -&gt; (partialValue: Self, overflow: Bool)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-dividingfullwidth-dividend_-high_-self_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-dividingfullwidth-dividend_-high_-self_">func dividingFullWidth(<wbr>_ dividend: (<wbr>high:<wbr> Self,:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-dividingfullwidth-dividend_-high_-self_"><div class="p">
    <p>Returns a tuple containing the quotient and remainder obtained by dividing
the given value by this value.</p>

<p>The resulting quotient must be representable within the bounds of the
type. If the quotient is too large to represent in the type, a runtime
error may occur.</p>

<p>The following example divides a value that is too large to be represented
using a single <code>Int</code> instance by another <code>Int</code> value. Because the quotient
is representable as an <code>Int</code>, the division succeeds.</p>

<pre><code class="language-swift">// &#39;dividend&#39; represents the value 0x506f70652053616e74612049494949
let dividend = (22640526660490081, 7959093232766896457 as UInt)
let divisor = 2241543570477705381

let (quotient, remainder) = divisor.dividingFullWidth(dividend)
// quotient == 186319822866995413
// remainder == 0</code></pre>

<p><strong><code>dividend</code>:</strong>  A tuple containing the high and low parts of a
  double-width integer.
<strong>Returns:</strong> A tuple containing the quotient and remainder obtained by
  dividing <code>dividend</code> by this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude)) -&gt; (quotient: Self, remainder: Self)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-hash-into_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-hash-into_">func hash(<wbr>into:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-hash-into_"><div class="p">
    <p>Hashes the essential components of this value by feeding them into the
given hasher.</p>

<p>Implement this method to conform to the <code>Hashable</code> protocol. The
components used for hashing must be the same as the components compared
in your type&#39;s <code>==</code> operator implementation. Call <code>hasher.combine(_:)</code>
with each of these components.</p>

<p><strong>Important:</strong> Never call <code>finalize()</code> on <code>hasher</code>. Doing so may become a
  compile-time error in the future.</p>

<p><strong><code>hasher</code>:</strong>  The hasher to use when combining the components
  of this instance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func hash(into hasher: inout Hasher)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Hashable/"><code>Hashable</code></a>    
</div></div>
</div>
<div class="declaration" id="func-multipliedfullwidth-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-multipliedfullwidth-by_">func multipliedFullWidth(<wbr>by:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-multipliedfullwidth-by_"><div class="p">
    <p>Returns a tuple containing the high and low parts of the result of
multiplying this value by the given value.</p>

<p>Use this method to calculate the full result of a product that would
otherwise overflow. Unlike traditional truncating multiplication, the
<code>multipliedFullWidth(by:)</code> method returns a tuple containing both the
<code>high</code> and <code>low</code> parts of the product of this value and <code>other</code>. The
following example uses this method to multiply two <code>Int8</code> values that
normally overflow when multiplied:</p>

<pre><code class="language-swift">let x: Int8 = 48
let y: Int8 = -40
let result = x.multipliedFullWidth(by: y)
// result.high == -8
// result.low  == 128</code></pre>

<p>The product of <code>x</code> and <code>y</code> is <code>-1920</code>, which is too large to represent in
an <code>Int8</code> instance. The <code>high</code> and <code>low</code> compnents of the <code>result</code> value
represent <code>-1920</code> when concatenated to form a double-width integer; that
is, using <code>result.high</code> as the high byte and <code>result.low</code> as the low byte
of an <code>Int16</code> instance.</p>

<pre><code class="language-swift">let z = Int16(result.high) &lt;&lt; 8 | Int16(result.low)
// z == -1920</code></pre>

<p><strong><code>other</code>:</strong>  The value to multiply this value by.
<strong>Returns:</strong> A tuple containing the high and low parts of the result of
  multiplying this value and <code>other</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func multipliedFullWidth(by other: Self) -&gt; (high: Self, low: Self.Magnitude)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-multipliedreportingoverflow-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-multipliedreportingoverflow-by_">func multipliedReportingOverflow(<wbr>by:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-multipliedreportingoverflow-by_"><div class="p">
    <p>Returns the product of this value and the given value, along with a
Boolean value indicating whether overflow occurred in the operation.</p>

<p><strong><code>rhs</code>:</strong>  The value to multiply by this value.
<strong>Returns:</strong> A tuple containing the result of the multiplication along with
  a Boolean value indicating whether overflow occurred. If the <code>overflow</code>
  component is <code>false</code>, the <code>partialValue</code> component contains the entire
  product. If the <code>overflow</code> component is <code>true</code>, an overflow occurred and
  the <code>partialValue</code> component contains the truncated product of this
  value and <code>rhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func multipliedReportingOverflow(by rhs: Self) -&gt; (partialValue: Self, overflow: Bool)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-quotientandremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-quotientandremainder-dividingby_">func quotientAndRemainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func-quotientandremainder-dividingby_"><div class="p">
    <p>Returns the quotient and remainder of this value divided by the given
value.</p>

<p>Use this method to calculate the quotient and remainder of a division at
the same time.</p>

<pre><code class="language-swift">let x = 1_000_000
let (q, r) = x.quotientAndRemainder(dividingBy: 933)
// q == 1071
// r == 757</code></pre>

<p><strong><code>rhs</code>:</strong>  The value to divide this value by.
<strong>Returns:</strong> A tuple containing the quotient and remainder of this value
  divided by <code>rhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func quotientAndRemainder(dividingBy rhs: Self) -&gt; (quotient: Self, remainder: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func-remainderreportingoverflow-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-remainderreportingoverflow-dividingby_">func remainderReportingOverflow(<wbr>dividingBy:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-remainderreportingoverflow-dividingby_"><div class="p">
    <p>Returns the remainder after dividing this value by the given value, along
with a Boolean value indicating whether overflow occurred during division.</p>

<p>Dividing by zero is not an error when using this method. For a value <code>x</code>,
the result of <code>x.remainderReportingOverflow(dividingBy: 0)</code> is
<code>(x, true)</code>.</p>

<p><strong><code>rhs</code>:</strong>  The value to divide this value by.
<strong>Returns:</strong> A tuple containing the result of the operation along with a
  Boolean value indicating whether overflow occurred. If the <code>overflow</code>
  component is <code>false</code>, the <code>partialValue</code> component contains the entire
  remainder. If the <code>overflow</code> component is <code>true</code>, an overflow occurred
  during division and the <code>partialValue</code> component contains either the
  entire remainder or, if the remainder is undefined, the dividend.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func remainderReportingOverflow(dividingBy rhs: Self) -&gt; (partialValue: Self, overflow: Bool)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-signum">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-signum">func signum()</a>
        
<div class="comment collapse" id="comment-func-signum"><div class="p">
    <p>Returns <code>-1</code> if this value is negative and <code>1</code> if it&#39;s positive;
otherwise, <code>0</code>.</p>

<p><strong>Returns:</strong> The sign of this number, expressed as an integer of the same
  type.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func signum() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func-subtractingreportingoverflow_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subtractingreportingoverflow_">func subtractingReportingOverflow(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-subtractingreportingoverflow_"><div class="p">
    <p>Returns the difference obtained by subtracting the given value from this
value, along with a Boolean value indicating whether overflow occurred in
the operation.</p>

<p><strong><code>rhs</code>:</strong>  The value to subtract from this value.
<strong>Returns:</strong> A tuple containing the result of the subtraction along with a
  Boolean value indicating whether overflow occurred. If the <code>overflow</code>
  component is <code>false</code>, the <code>partialValue</code> component contains the entire
  difference. If the <code>overflow</code> component is <code>true</code>, an overflow occurred
  and the <code>partialValue</code> component contains the truncated result of <code>rhs</code>
  subtracted from this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func subtractingReportingOverflow(_ rhs: Self) -&gt; (partialValue: Self, overflow: Bool)</code>
    
    
</div></div>
</div>


<h3>Default Implementations</h3>




<div class="declaration inherited" id="-init">
<a class="toggle-link" data-toggle="collapse" href="#comment--init">init()</a><div class="comment collapse" id="comment--init"><div class="p">
    <p>Creates a new value equal to zero.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init()</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        </div></div>
</div>
<div class="declaration" id="-init_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init_">init(<wbr>_:)</a><div class="comment collapse" id="comment--init_"><div class="p">
    <p>Creates an integer from the given floating-point value, rounding toward
zero. Any fractional part of the value passed as <code>source</code> is removed.</p>

<pre><code class="language-swift">let x = Int(21.5)
// x == 21
let y = Int(-21.5)
// y == -21</code></pre>

<p>If <code>source</code> is outside the bounds of this type after rounding toward
zero, a runtime error may occur.</p>

<pre><code class="language-swift">let z = UInt(-21.5)
// Error: ...outside the representable range</code></pre>

<p><strong><code>source</code>:</strong>  A floating-point value to convert to an integer.
  <code>source</code> must be representable in this type after rounding toward
  zero.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;T&gt;(_ source: T)</code>

    </div></div>
</div>
<div class="declaration" id="-init-bigendian_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-bigendian_">init(<wbr>bigEndian:)</a><div class="comment collapse" id="comment--init-bigendian_"><div class="p">
    <p>Creates an integer from its big-endian representation, changing the byte
order if necessary.</p>

<p><strong><code>value</code>:</strong>  A value to use as the big-endian representation of the
  new integer.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(bigEndian value: Self)</code>

    </div></div>
</div>
<div class="declaration" id="-init-clamping_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-clamping_">init(<wbr>clamping:)</a><div class="comment collapse" id="comment--init-clamping_"><div class="p">
    <p>Creates a new instance with the representable value that&#39;s closest to the
given integer.</p>

<p>If the value passed as <code>source</code> is greater than the maximum representable
value in this type, the result is the type&#39;s <code>max</code> value. If <code>source</code> is
less than the smallest representable value in this type, the result is
the type&#39;s <code>min</code> value.</p>

<p>In this example, <code>x</code> is initialized as an <code>Int8</code> instance by clamping
<code>500</code> to the range <code>-128...127</code>, and <code>y</code> is initialized as a <code>UInt</code>
instance by clamping <code>-500</code> to the range <code>0...UInt.max</code>.</p>

<pre><code class="language-swift">let x = Int8(clamping: 500)
// x == 127
// x == Int8.max

let y = UInt(clamping: -500)
// y == 0</code></pre>

<p><strong><code>source</code>:</strong>  An integer to convert to this type.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;Other&gt;(clamping source: Other)</code>

    </div></div>
</div>
<div class="declaration inherited" id="-init-integerliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-integerliteral_">init(<wbr>integerLiteral:)</a><div class="comment collapse" id="comment--init-integerliteral_"><div class="p">
    <p>Creates an instance initialized to the specified integer value.</p>

<p>Do not call this initializer directly. Instead, initialize a variable or
constant using an integer literal. For example:</p>

<pre><code class="language-swift">let x = 23</code></pre>

<p>In this example, the assignment to the <code>x</code> constant calls this integer
literal initializer behind the scenes.</p>

<p><strong><code>value</code>:</strong>  The value to create.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(integerLiteral value: Self)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        </div></div>
</div>
<div class="declaration" id="-init-littleendian_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-littleendian_">init(<wbr>littleEndian:)</a><div class="comment collapse" id="comment--init-littleendian_"><div class="p">
    <p>Creates an integer from its little-endian representation, changing the
byte order if necessary.</p>

<p><strong><code>value</code>:</strong>  A value to use as the little-endian representation of
  the new integer.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(littleEndian value: Self)</code>

    </div></div>
</div>
<div class="declaration" id="-init-truncatingifneeded_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-truncatingifneeded_">init(<wbr>truncatingIfNeeded:)</a><div class="comment collapse" id="comment--init-truncatingifneeded_"><div class="p">
    <p>Creates a new instance from the bit pattern of the given instance by
truncating or sign-extending if needed to fit this type.</p>

<p>When the bit width of <code>T</code> (the type of <code>source</code>) is equal to or greater
than this type&#39;s bit width, the result is the truncated
least-significant bits of <code>source</code>. For example, when converting a
16-bit value to an 8-bit type, only the lower 8 bits of <code>source</code> are
used.</p>

<pre><code class="language-swift">let p: Int16 = -500
// &#39;p&#39; has a binary representation of 11111110_00001100
let q = Int8(truncatingIfNeeded: p)
// q == 12
// &#39;q&#39; has a binary representation of 00001100</code></pre>

<p>When the bit width of <code>T</code> is less than this type&#39;s bit width, the result
is <em>sign-extended</em> to fill the remaining bits. That is, if <code>source</code> is
negative, the result is padded with ones; otherwise, the result is
padded with zeros.</p>

<pre><code class="language-swift">let u: Int8 = 21
// &#39;u&#39; has a binary representation of 00010101
let v = Int16(truncatingIfNeeded: u)
// v == 21
// &#39;v&#39; has a binary representation of 00000000_00010101

let w: Int8 = -21
// &#39;w&#39; has a binary representation of 11101011
let x = Int16(truncatingIfNeeded: w)
// x == -21
// &#39;x&#39; has a binary representation of 11111111_11101011
let y = UInt16(truncatingIfNeeded: w)
// y == 65515
// &#39;y&#39; has a binary representation of 11111111_11101011</code></pre>

<p><strong><code>source</code>:</strong>  An integer to convert to this type.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;T&gt;(truncatingIfNeeded source: T)</code>

    </div></div>
</div>
<div class="declaration" id="-init_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init_">init?(<wbr>_:)</a><div class="comment collapse" id="comment--init_"><div class="p">
    <p>Creates a new integer value from the given string.</p>

<p>The string passed as <code>description</code> may begin with a plus or minus sign
character (<code>+</code> or <code>-</code>), followed by one or more numeric digits (<code>0-9</code>).</p>

<pre><code class="language-swift">let x = Int(&quot;123&quot;)
// x == 123</code></pre>

<p>If <code>description</code> is in an invalid format, or if the value it denotes in
base 10 is not representable, the result is <code>nil</code>. For example, the
following conversions result in <code>nil</code>:</p>

<pre><code class="language-swift">Int(&quot; 100&quot;)                       // Includes whitespace
Int(&quot;21-50&quot;)                      // Invalid format
Int(&quot;ff6600&quot;)                     // Characters out of bounds
Int(&quot;10000000000000000000000000&quot;) // Out of range</code></pre>

<p><strong><code>description</code>:</strong>  The ASCII representation of a number.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?(_ description: String)</code>

    </div></div>
</div>
<div class="declaration" id="-init_radix_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init_radix_">init?(<wbr>_:<wbr>radix:)</a><div class="comment collapse" id="comment--init_radix_"><div class="p">
    <p>Creates a new integer value from the given string and radix.</p>

<p>The string passed as <code>text</code> may begin with a plus or minus sign character
(<code>+</code> or <code>-</code>), followed by one or more numeric digits (<code>0-9</code>) or letters
(<code>a-z</code> or <code>A-Z</code>). Parsing of the string is case insensitive.</p>

<pre><code class="language-swift">let x = Int(&quot;123&quot;)
// x == 123

let y = Int(&quot;-123&quot;, radix: 8)
// y == -83
let y = Int(&quot;+123&quot;, radix: 8)
// y == +83

let z = Int(&quot;07b&quot;, radix: 16)
// z == 123</code></pre>

<p>If <code>text</code> is in an invalid format or contains characters that are out of
bounds for the given <code>radix</code>, or if the value it denotes in the given
<code>radix</code> is not representable, the result is <code>nil</code>. For example, the
following conversions result in <code>nil</code>:</p>

<pre><code class="language-swift">Int(&quot; 100&quot;)                       // Includes whitespace
Int(&quot;21-50&quot;)                      // Invalid format
Int(&quot;ff6600&quot;)                     // Characters out of bounds
Int(&quot;zzzzzzzzzzzzz&quot;, radix: 36)   // Out of range</code></pre>

<p><strong>Parameters:</strong>
  <strong>text:</strong> The ASCII representation of a number in the radix passed as
    <code>radix</code>.
  <strong>radix:</strong> The radix, or base, to use for converting <code>text</code> to an integer
    value. <code>radix</code> must be in the range <code>2...36</code>. The default is 10.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?&lt;S&gt;(_ text: S, radix: Int = default)</code>

    </div></div>
</div>
<div class="declaration" id="-init-exactly_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-exactly_">init?(<wbr>exactly:)</a><div class="comment collapse" id="comment--init-exactly_"><div class="p">
    <p>Creates an integer from the given floating-point value, if it can be
represented exactly.</p>

<p>If the value passed as <code>source</code> is not representable exactly, the result
is <code>nil</code>. In the following example, the constant <code>x</code> is successfully
created from a value of <code>21.0</code>, while the attempt to initialize the
constant <code>y</code> from <code>21.5</code> fails:</p>

<pre><code class="language-swift">let x = Int(exactly: 21.0)
// x == Optional(21)
let y = Int(exactly: 21.5)
// y == nil</code></pre>

<p><strong><code>source</code>:</strong>  A floating-point value to convert to an integer.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?&lt;T&gt;(exactly source: T)</code>

    </div></div>
</div>

<div class="declaration" id="-var-bigendian_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment--var-bigendian_-self">var bigEndian: Self</a><div class="comment collapse" id="comment--var-bigendian_-self"><div class="p">
    <p>The big-endian representation of this integer.</p>

<p>If necessary, the byte order of this value is reversed from the typical
byte order of this integer type. On a big-endian platform, for any
integer <code>x</code>, <code>x == x.bigEndian</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var bigEndian: Self { get }</code>

    </div></div>
</div>
<div class="declaration" id="-var-bitwidth_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment--var-bitwidth_-int">var bitWidth: Int</a><div class="comment collapse" id="comment--var-bitwidth_-int"><div class="p">
    <p>The number of bits in the binary representation of this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var bitWidth: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="-var-description_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment--var-description_-string">var description: String</a><div class="comment collapse" id="comment--var-description_-string"><div class="p">
    <p>A textual representation of this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var description: String { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>
        </div></div>
</div>
<div class="declaration" id="-var-littleendian_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment--var-littleendian_-self">var littleEndian: Self</a><div class="comment collapse" id="comment--var-littleendian_-self"><div class="p">
    <p>The little-endian representation of this integer.</p>

<p>If necessary, the byte order of this value is reversed from the typical
byte order of this integer type. On a little-endian platform, for any
integer <code>x</code>, <code>x == x.littleEndian</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var littleEndian: Self { get }</code>

    </div></div>
</div>


<div class="declaration inherited" id="func--excleq_-self-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--excleq_-self-rhs_-self">func !=(<wbr>_:<wbr> Self, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--excleq_-self-rhs_-self"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func !=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--excleq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--excleq_rhs_">func !=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--excleq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether two values are not equal.</p>

<p>Inequality is the inverse of equality. For any values <code>a</code> and <code>b</code>, <code>a != b</code>
implies that <code>a == b</code> is <code>false</code>.</p>

<p>This is the default implementation of the not-equal-to operator (<code>!=</code>)
for any type that conforms to <code>Equatable</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func !=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--excleq-other_-self-rhs_-other">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--excleq-other_-self-rhs_-other">func != &lt;Other&gt;(<wbr>_:<wbr> Self, rhs: Other)</a>
        
<div class="comment collapse" id="comment-func--excleq-other_-self-rhs_-other"><div class="p">
    <p>Returns a Boolean value indicating whether the two given values are not
equal.</p>

<p>You can check the inequality of instances of any <code>BinaryInteger</code> types
using the not-equal-to operator (<code>!=</code>). For example, you can test
whether the first <code>UInt8</code> value in a string&#39;s UTF-8 encoding is not
equal to the first <code>UInt32</code> value in its Unicode scalar view:</p>

<pre><code class="language-swift">let gameName = &quot;Red Light, Green Light&quot;
if let firstUTF8 = gameName.utf8.first,
    let firstScalar = gameName.unicodeScalars.first?.value {
    print(&quot;First code values are different: \(firstUTF8 != firstScalar)&quot;)
}
// Prints &quot;First code values are different: false&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer to compare.
  <strong>rhs:</strong> Another integer to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func !=&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Bool where Other : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--amp_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--amp_rhs_">func &amp;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--amp_rhs_"><div class="p">
    <p>Returns the result of performing a bitwise AND operation on the two given
values.</p>

<p>A bitwise AND operation results in a value that has each bit set to <code>1</code>
where <em>both</em> of its arguments have that bit set to <code>1</code>. For example:</p>

<pre><code class="language-swift">let x: UInt8 = 5          // 0b00000101
let y: UInt8 = 14         // 0b00001110
let z = x &amp; y             // 0b00000100
// z == 4</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer value.
  <strong>rhs:</strong> Another integer value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func--ampstar_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampstar_rhs_">func &amp;*(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--ampstar_rhs_"><div class="p">
    <p>Returns the product of the two given values, discarding any overflow.</p>

<p>The masking multiplication operator (<code>&amp;*</code>) silently discards any overflow
that occurs during the operation. In the following example, the product
of <code>10</code> and <code>50</code> is greater than the maximum representable <code>Int8</code> value,
so the result is the overflowed value:</p>

<pre><code class="language-swift">let x: Int8 = 10 &amp;* 5
// x == 50
let y: Int8 = 10 &amp;* 50
// y == -12 (after overflow)</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to multiply.
  <strong>rhs:</strong> The second value to multiply.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;*(lhs: Self, rhs: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampstareq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampstareq_rhs_">func &amp;*=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--ampstareq_rhs_"><div class="p">
    <p>Multiplies two values and stores the result in the left-hand-side
variable, discarding any overflow.</p>

<p>The masking multiplication assignment operator (<code>&amp;*=</code>) silently discards 
any overflow that occurs during the operation. In the following example, 
the product of <code>10</code> and <code>50</code> is greater than the maximum representable 
<code>Int8</code> value, so the result is the overflowed value:</p>

<pre><code class="language-swift">var x: Int8 = 10
x &amp;*= 5
// x == 50
var y: Int8 = 10
y &amp;*= 50
// y == -12 (after overflow)</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to multiply.
  <strong>rhs:</strong> The second value to multiply.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;*=(lhs: inout Self, rhs: Self)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--amppls_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--amppls_rhs_">func &amp;+(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--amppls_rhs_"><div class="p">
    <p>Returns the sum of the two given values, discarding any overflow.</p>

<p>The masking addition operator (<code>&amp;+</code>) silently discards any overflow that
occurs during the operation. In the following example, the sum of <code>100</code>
and <code>121</code> is greater than the maximum representable <code>Int8</code> value, so the
result is the overflowed value:</p>

<pre><code class="language-swift">let x: Int8 = 10 &amp;+ 21
// x == 31
let y: Int8 = 100 &amp;+ 121
// y == -35 (after overflow)</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to add.
  <strong>rhs:</strong> The second value to add.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;+(lhs: Self, rhs: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampplseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampplseq_rhs_">func &amp;+=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--ampplseq_rhs_"><div class="p">
    <p>Adds two values and stores the result in the left-hand-side variable, 
discarding any overflow.</p>

<p>The masking addition assignment operator (<code>&amp;+=</code>) silently discards any 
overflow that occurs during the operation. In the following example, the 
sum of <code>100</code> and <code>121</code> is greater than the maximum representable <code>Int8</code> 
value, so the result is the overflowed value:</p>

<pre><code class="language-swift">var x: Int8 = 10
x &amp;+= 21
// x == 31
var y: Int8 = 100
y &amp;+= 121
// y == -35 (after overflow)</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to add.
  <strong>rhs:</strong> The second value to add.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;+=(lhs: inout Self, rhs: Self)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampltlt_-self-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampltlt_-self-rhs_-self">func &amp;&lt;&lt;(<wbr>_:<wbr> Self, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--ampltlt_-self-rhs_-self"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the left, masking the shift amount to the
type&#39;s bit width.</p>

<p>Use the masking left shift operator (<code>&amp;&lt;&lt;</code>) when you need to perform a
shift and are sure that the shift amount is in the range
<code>0..&lt;lhs.bitWidth</code>. Before shifting, the masking left shift operator
masks the shift to this range. The shift is performed using this masked
value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &amp;&lt;&lt; 2
// y == 120                       // 0b01111000</code></pre>

<p>However, if you use <code>8</code> as the shift amount, the method first masks the
shift amount to zero, and then performs the shift, resulting in no change
to the original value.</p>

<pre><code class="language-swift">let z = x &amp;&lt;&lt; 8
// z == 30                        // 0b00011110</code></pre>

<p>If the bit width of the shifted integer type is a power of two, masking
is performed using a bitmask; otherwise, masking is performed using a
modulo operation.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the left. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&lt;&lt;(lhs: Self, rhs: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampltlt-other_-self-rhs_-other">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampltlt-other_-self-rhs_-other">func &amp;&lt;&lt; &lt;Other&gt;(<wbr>_:<wbr> Self, rhs: Other)</a>
        
<div class="comment collapse" id="comment-func--ampltlt-other_-self-rhs_-other"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the left, masking the shift amount to the
type&#39;s bit width.</p>

<p>Use the masking left shift operator (<code>&amp;&lt;&lt;</code>) when you need to perform a
shift and are sure that the shift amount is in the range
<code>0..&lt;lhs.bitWidth</code>. Before shifting, the masking left shift operator
masks the shift to this range. The shift is performed using this masked
value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &amp;&lt;&lt; 2
// y == 120                       // 0b01111000</code></pre>

<p>However, if you use <code>8</code> as the shift amount, the method first masks the
shift amount to zero, and then performs the shift, resulting in no change
to the original value.</p>

<pre><code class="language-swift">let z = x &amp;&lt;&lt; 8
// z == 30                        // 0b00011110</code></pre>

<p>If the bit width of the shifted integer type is a power of two, masking
is performed using a bitmask; otherwise, masking is performed using a
modulo operation.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the left. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&lt;&lt;&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Self where Other : BinaryInteger</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampltlteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampltlteq_rhs_">func &amp;&lt;&lt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--ampltlteq_rhs_"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the left, masking the shift amount to the
type&#39;s bit width, and stores the result in the left-hand-side variable.</p>

<p>The <code>&amp;&lt;&lt;=</code> operator performs a <em>masking shift</em>, where the value used as
<code>rhs</code> is masked to produce a value in the range <code>0..&lt;lhs.bitWidth</code>. The
shift is performed using this masked value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">var x: UInt8 = 30                 // 0b00011110
x &amp;&lt;&lt;= 2
// x == 120                       // 0b01111000</code></pre>

<p>However, if you pass <code>19</code> as <code>rhs</code>, the method first bitmasks <code>rhs</code> to
<code>3</code>, and then uses that masked value as the number of bits to shift <code>lhs</code>.</p>

<pre><code class="language-swift">var y: UInt8 = 30                 // 0b00011110
y &amp;&lt;&lt;= 19
// y == 240                       // 0b11110000</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the left. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&lt;&lt;=&lt;Other&gt;(lhs: inout Self, rhs: Other)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampgtgt_-self-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampgtgt_-self-rhs_-self">func &amp;&gt;&gt;(<wbr>_:<wbr> Self, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--ampgtgt_-self-rhs_-self"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the right, masking the shift amount to the
type&#39;s bit width.</p>

<p>Use the masking right shift operator (<code>&amp;&gt;&gt;</code>) when you need to perform a
shift and are sure that the shift amount is in the range
<code>0..&lt;lhs.bitWidth</code>. Before shifting, the masking right shift operator
masks the shift to this range. The shift is performed using this masked
value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &amp;&gt;&gt; 2
// y == 7                         // 0b00000111</code></pre>

<p>However, if you use <code>8</code> as the shift amount, the method first masks the
shift amount to zero, and then performs the shift, resulting in no change
to the original value.</p>

<pre><code class="language-swift">let z = x &amp;&gt;&gt; 8
// z == 30                        // 0b00011110</code></pre>

<p>If the bit width of the shifted integer type is a power of two, masking
is performed using a bitmask; otherwise, masking is performed using a
modulo operation.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the right. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&gt;&gt;(lhs: Self, rhs: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampgtgt-other_-self-rhs_-other">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampgtgt-other_-self-rhs_-other">func &amp;&gt;&gt; &lt;Other&gt;(<wbr>_:<wbr> Self, rhs: Other)</a>
        
<div class="comment collapse" id="comment-func--ampgtgt-other_-self-rhs_-other"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the right, masking the shift amount to the
type&#39;s bit width.</p>

<p>Use the masking right shift operator (<code>&amp;&gt;&gt;</code>) when you need to perform a
shift and are sure that the shift amount is in the range
<code>0..&lt;lhs.bitWidth</code>. Before shifting, the masking right shift operator
masks the shift to this range. The shift is performed using this masked
value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &amp;&gt;&gt; 2
// y == 7                         // 0b00000111</code></pre>

<p>However, if you use <code>8</code> as the shift amount, the method first masks the
shift amount to zero, and then performs the shift, resulting in no change
to the original value.</p>

<pre><code class="language-swift">let z = x &amp;&gt;&gt; 8
// z == 30                        // 0b00011110</code></pre>

<p>If the bit width of the shifted integer type is a power of two, masking
is performed using a bitmask; otherwise, masking is performed using a
modulo operation.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the right. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&gt;&gt;&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Self where Other : BinaryInteger</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampgtgteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampgtgteq_rhs_">func &amp;&gt;&gt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--ampgtgteq_rhs_"><div class="p">
    <p>Calculates the result of shifting a value&#39;s binary representation the
specified number of digits to the right, masking the shift amount to the
type&#39;s bit width, and stores the result in the left-hand-side variable.</p>

<p>The <code>&amp;&gt;&gt;=</code> operator performs a <em>masking shift</em>, where the value passed as
<code>rhs</code> is masked to produce a value in the range <code>0..&lt;lhs.bitWidth</code>. The
shift is performed using this masked value.</p>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the shift amount requires no masking.</p>

<pre><code class="language-swift">var x: UInt8 = 30                 // 0b00011110
x &amp;&gt;&gt;= 2
// x == 7                         // 0b00000111</code></pre>

<p>However, if you use <code>19</code> as <code>rhs</code>, the operation first bitmasks <code>rhs</code> to
<code>3</code>, and then uses that masked value as the number of bits to shift <code>lhs</code>.</p>

<pre><code class="language-swift">var y: UInt8 = 30                 // 0b00011110
y &amp;&gt;&gt;= 19
// y == 3                         // 0b00000011</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the right. If <code>rhs</code> is
    outside the range <code>0..&lt;lhs.bitWidth</code>, it is masked to produce a
    value within that range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;&gt;&gt;=&lt;Other&gt;(lhs: inout Self, rhs: Other)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampmns_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampmns_rhs_">func &amp;-(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--ampmns_rhs_"><div class="p">
    <p>Returns the difference of the two given values, discarding any overflow.</p>

<p>The masking subtraction operator (<code>&amp;-</code>) silently discards any overflow
that occurs during the operation. In the following example, the
difference of <code>10</code> and <code>21</code> is less than zero, the minimum representable
<code>UInt</code> value, so the result is the overflowed value:</p>

<pre><code class="language-swift">let x: UInt8 = 21 &amp;- 10
// x == 11
let y: UInt8 = 10 &amp;- 21
// y == 245 (after overflow)</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A numeric value.
  <strong>rhs:</strong> The value to subtract from <code>lhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;-(lhs: Self, rhs: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--ampmnseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ampmnseq_rhs_">func &amp;-=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--ampmnseq_rhs_"><div class="p">
    <p>Subtracts the second value from the first and stores the difference in the
left-hand-side variable, discarding any overflow.</p>

<p>The masking subtraction assignment operator (<code>&amp;-=</code>) silently discards any
overflow that occurs during the operation. In the following example, the
difference of <code>10</code> and <code>21</code> is less than zero, the minimum representable
<code>UInt</code> value, so the result is the overflowed value:</p>

<pre><code class="language-swift">var x: Int8 = 21
x &amp;-= 10
// x == 11
var y: UInt8 = 10
y &amp;-= 21
// y == 245 (after overflow)</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A numeric value.
  <strong>rhs:</strong> The value to subtract from <code>lhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &amp;-=(lhs: inout Self, rhs: Self)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func--pls_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--pls_">prefix func +(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--pls_"><div class="p">
    <p>Returns the given number unchanged.</p>

<p>You can use the unary plus operator (<code>+</code>) to provide symmetry in your
code for positive numbers when also using the unary minus operator.</p>

<pre><code class="language-swift">let x = -21
let y = +21
// x == -21
// y == 21</code></pre>

<p><strong>Returns:</strong> The given argument without any changes.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func +(x: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--pls_-self-rhs_-self-stride">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--pls_-self-rhs_-self-stride">func +(<wbr>_:<wbr> Self, rhs: Self.Stride)</a>
        
<div class="comment collapse" id="comment-func--pls_-self-rhs_-self-stride"><div class="p">
    <p>Adds two values and produces their sum.</p>

<p>The addition operator (<code>+</code>) calculates the sum of its two arguments. For
example:</p>

<pre><code class="language-swift">1 + 2                   // 3
-10 + 15                // 5
-15 + -5                // -20
21.5 + 3.25             // 24.75</code></pre>

<p>You cannot use <code>+</code> with arguments of different types. To add values of
different types, convert one of the values to the other value&#39;s type.</p>

<pre><code class="language-swift">let x: Int8 = 21
let y: Int = 1000000
Int(x) + y              // 1000021</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to add.
  <strong>rhs:</strong> The second value to add.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func +(lhs: Self, rhs: Self.Stride) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--pls_-self-stride-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--pls_-self-stride-rhs_-self">func +(<wbr>_:<wbr> Self.Stride, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--pls_-self-stride-rhs_-self"><div class="p">
    <p>Adds two values and produces their sum.</p>

<p>The addition operator (<code>+</code>) calculates the sum of its two arguments. For
example:</p>

<pre><code class="language-swift">1 + 2                   // 3
-10 + 15                // 5
-15 + -5                // -20
21.5 + 3.25             // 24.75</code></pre>

<p>You cannot use <code>+</code> with arguments of different types. To add values of
different types, convert one of the values to the other value&#39;s type.</p>

<pre><code class="language-swift">let x: Int8 = 21
let y: Int = 1000000
Int(x) + y              // 1000021</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to add.
  <strong>rhs:</strong> The second value to add.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func +(lhs: Self.Stride, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--plseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--plseq_rhs_">func +=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--plseq_rhs_"><div class="p">
    <p>Adds two values and stores the result in the left-hand-side variable.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to add.
  <strong>rhs:</strong> The second value to add.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func +=(lhs: inout Self, rhs: Self.Stride)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--dotdotdot_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--dotdotdot_-self">prefix func ...(<wbr>_: Self)</a>
        
<div class="comment collapse" id="comment-func--dotdotdot_-self"><div class="p">
    <p>Returns a partial range up to, and including, its upper bound.</p>

<p>Use the prefix closed range operator (prefix <code>...</code>) to create a partial
range of any type that conforms to the <code>Comparable</code> protocol. This
example creates a <code>PartialRangeThrough&lt;Double&gt;</code> instance that includes
any value less than or equal to <code>5.0</code>.</p>

<pre><code class="language-swift">let throughFive = ...5.0

throughFive.contains(4.0)     // true
throughFive.contains(5.0)     // true
throughFive.contains(6.0)     // false</code></pre>

<p>You can use this type of partial range of a collection&#39;s indices to
represent the range from the start of the collection up to, and
including, the partial range&#39;s upper bound.</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60, 70]
print(numbers[...3])
// Prints &quot;[10, 20, 30, 40]&quot;</code></pre>

<p><strong><code>maximum</code>:</strong>  The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func ...(maximum: Self) -&gt; PartialRangeThrough&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--dotdotdot_maximum_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--dotdotdot_maximum_">func ...(<wbr>_:<wbr>maximum:)</a>
        
<div class="comment collapse" id="comment-func--dotdotdot_maximum_"><div class="p">
    <p>Returns a closed range that contains both of its bounds.</p>

<p>Use the closed range operator (<code>...</code>) to create a closed range of any type
that conforms to the <code>Comparable</code> protocol. This example creates a
<code>ClosedRange&lt;Character&gt;</code> from &quot;a&quot; up to, and including, &quot;z&quot;.</p>

<pre><code class="language-swift">let lowercase = &quot;a&quot;...&quot;z&quot;
print(lowercase.contains(&quot;z&quot;))
// Prints &quot;true&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>minimum:</strong> The lower bound for the range.
  <strong>maximum:</strong> The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ...(minimum: Self, maximum: Self) -&gt; ClosedRange&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--dotdotlt_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--dotdotlt_">prefix func ..&lt;(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--dotdotlt_"><div class="p">
    <p>Returns a partial range up to, but not including, its upper bound.</p>

<p>Use the prefix half-open range operator (prefix <code>..&lt;</code>) to create a
partial range of any type that conforms to the <code>Comparable</code> protocol.
This example creates a <code>PartialRangeUpTo&lt;Double&gt;</code> instance that includes
any value less than <code>5.0</code>.</p>

<pre><code class="language-swift">let upToFive = ..&lt;5.0

upToFive.contains(3.14)       // true
upToFive.contains(6.28)       // false
upToFive.contains(5.0)        // false</code></pre>

<p>You can use this type of partial range of a collection&#39;s indices to
represent the range from the start of the collection up to, but not
including, the partial range&#39;s upper bound.</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60, 70]
print(numbers[..&lt;3])
// Prints &quot;[10, 20, 30]&quot;</code></pre>

<p><strong><code>maximum</code>:</strong>  The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func ..&lt;(maximum: Self) -&gt; PartialRangeUpTo&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--dotdotlt_maximum_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--dotdotlt_maximum_">func ..&lt;(<wbr>_:<wbr>maximum:)</a>
        
<div class="comment collapse" id="comment-func--dotdotlt_maximum_"><div class="p">
    <p>Returns a half-open range that contains its lower bound but not its upper
bound.</p>

<p>Use the half-open range operator (<code>..&lt;</code>) to create a range of any type
that conforms to the <code>Comparable</code> protocol. This example creates a
<code>Range&lt;Double&gt;</code> from zero up to, but not including, 5.0.</p>

<pre><code class="language-swift">let lessThanFive = 0.0..&lt;5.0
print(lessThanFive.contains(3.14))  // Prints &quot;true&quot;
print(lessThanFive.contains(5.0))   // Prints &quot;false&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>minimum:</strong> The lower bound for the range.
  <strong>maximum:</strong> The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ..&lt;(minimum: Self, maximum: Self) -&gt; Range&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--lt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--lt_rhs_">func &lt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--lt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.</p>

<p>You can compare instances of any <code>BinaryInteger</code> types using the
less-than operator (<code>&lt;</code>), even if the two instances are of different
types.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer to compare.
  <strong>rhs:</strong> Another integer to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Bool where Other : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--lt_y_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--lt_y_">func &lt;(<wbr>_:<wbr>y:)</a>
        
<div class="comment collapse" id="comment-func--lt_y_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;(x: Self, y: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func--ltlt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ltlt_rhs_">func &lt;&lt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--ltlt_rhs_"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the left.</p>

<p>The <code>&lt;&lt;</code> operator performs a <em>smart shift</em>, which defines a result for a
shift of any value.</p>

<ul><li>Using a negative value for <code>rhs</code> performs a right shift using
<code>abs(rhs)</code>.</li><li>Using a value for <code>rhs</code> that is greater than or equal to the bit width
of <code>lhs</code> is an <em>overshift</em>, resulting in zero.</li><li>Using any other value for <code>rhs</code> performs a left shift on <code>lhs</code> by that
amount.</li></ul>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the value is shifted left by two bits.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &lt;&lt; 2
// y == 120                       // 0b01111000</code></pre>

<p>If you use <code>11</code> as <code>rhs</code>, <code>x</code> is overshifted such that all of its bits
are set to zero.</p>

<pre><code class="language-swift">let z = x &lt;&lt; 11
// z == 0                         // 0b00000000</code></pre>

<p>Using a negative value as <code>rhs</code> is the same as performing a right shift
with <code>abs(rhs)</code>.</p>

<pre><code class="language-swift">let a = x &lt;&lt; -3
// a == 3                         // 0b00000011
let b = x &gt;&gt; 3
// b == 3                         // 0b00000011</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the left.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;&lt;&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Self where Other : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FixedWidthInteger/"><code>FixedWidthInteger</code></a>,    <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func--ltlteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--ltlteq_rhs_">func &lt;&lt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--ltlteq_rhs_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;&lt;=&lt;Other&gt;(lhs: inout Self, rhs: Other)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func--lteq_-self-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--lteq_-self-rhs_-self">func &lt;=(<wbr>_:<wbr> Self, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--lteq_-self-rhs_-self"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--lteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--lteq_rhs_">func &lt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--lteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first argument
is less than or equal to that of the second argument.</p>

<p>This is the default implementation of the less-than-or-equal-to
operator (<code>&lt;=</code>) for any type that conforms to <code>Comparable</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--lteq-other_-self-rhs_-other">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--lteq-other_-self-rhs_-other">func &lt;= &lt;Other&gt;(<wbr>_:<wbr> Self, rhs: Other)</a>
        
<div class="comment collapse" id="comment-func--lteq-other_-self-rhs_-other"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than or equal to that of the second argument.</p>

<p>You can compare instances of any <code>BinaryInteger</code> types using the
less-than-or-equal-to operator (<code>&lt;=</code>), even if the two instances are of
different types.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer to compare.
  <strong>rhs:</strong> Another integer to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;=&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Bool where Other : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--eqeq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--eqeq_rhs_">func ==(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--eqeq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the two given values are
equal.</p>

<p>You can check the equality of instances of any <code>BinaryInteger</code> types
using the equal-to operator (<code>==</code>). For example, you can test whether
the first <code>UInt8</code> value in a string&#39;s UTF-8 encoding is equal to the
first <code>UInt32</code> value in its Unicode scalar view:</p>

<pre><code class="language-swift">let gameName = &quot;Red Light, Green Light&quot;
if let firstUTF8 = gameName.utf8.first,
    let firstScalar = gameName.unicodeScalars.first?.value {
    print(&quot;First code values are equal: \(firstUTF8 == firstScalar)&quot;)
}
// Prints &quot;First code values are equal: true&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer to compare.
  <strong>rhs:</strong> Another integer to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ==&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Bool where Other : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--eqeq_y_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--eqeq_y_">func ==(<wbr>_:<wbr>y:)</a>
        
<div class="comment collapse" id="comment-func--eqeq_y_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func ==(x: Self, y: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--gt_-self-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gt_-self-rhs_-self">func &gt;(<wbr>_:<wbr> Self, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--gt_-self-rhs_-self"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--gt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gt_rhs_">func &gt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--gt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first argument
is greater than that of the second argument.</p>

<p>This is the default implementation of the greater-than operator (<code>&gt;</code>) for
any type that conforms to <code>Comparable</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--gt-other_-self-rhs_-other">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gt-other_-self-rhs_-other">func &gt; &lt;Other&gt;(<wbr>_:<wbr> Self, rhs: Other)</a>
        
<div class="comment collapse" id="comment-func--gt-other_-self-rhs_-other"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than that of the second argument.</p>

<p>You can compare instances of any <code>BinaryInteger</code> types using the
greater-than operator (<code>&gt;</code>), even if the two instances are of different
types.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer to compare.
  <strong>rhs:</strong> Another integer to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Bool where Other : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--gteq_-self-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gteq_-self-rhs_-self">func &gt;=(<wbr>_:<wbr> Self, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--gteq_-self-rhs_-self"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--gteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gteq_rhs_">func &gt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--gteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first argument
is greater than or equal to that of the second argument.</p>

<p>This is the default implementation of the greater-than-or-equal-to operator
(<code>&gt;=</code>) for any type that conforms to <code>Comparable</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.
<strong>Returns:</strong> <code>true</code> if <code>lhs</code> is greater than or equal to <code>rhs</code>; otherwise,
  <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--gteq-other_-self-rhs_-other">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gteq-other_-self-rhs_-other">func &gt;= &lt;Other&gt;(<wbr>_:<wbr> Self, rhs: Other)</a>
        
<div class="comment collapse" id="comment-func--gteq-other_-self-rhs_-other"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than or equal to that of the second argument.</p>

<p>You can compare instances of any <code>BinaryInteger</code> types using the
greater-than-or-equal-to operator (<code>&gt;=</code>), even if the two instances are
of different types.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer to compare.
  <strong>rhs:</strong> Another integer to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;=&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Bool where Other : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func--gtgt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gtgt_rhs_">func &gt;&gt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--gtgt_rhs_"><div class="p">
    <p>Returns the result of shifting a value&#39;s binary representation the
specified number of digits to the right.</p>

<p>The <code>&gt;&gt;</code> operator performs a <em>smart shift</em>, which defines a result for a
shift of any value.</p>

<ul><li>Using a negative value for <code>rhs</code> performs a left shift using
<code>abs(rhs)</code>.</li><li>Using a value for <code>rhs</code> that is greater than or equal to the bit width
of <code>lhs</code> is an <em>overshift</em>. An overshift results in <code>-1</code> for a
negative value of <code>lhs</code> or <code>0</code> for a nonnegative value.</li><li>Using any other value for <code>rhs</code> performs a right shift on <code>lhs</code> by that
amount.</li></ul>

<p>The following example defines <code>x</code> as an instance of <code>UInt8</code>, an 8-bit,
unsigned integer type. If you use <code>2</code> as the right-hand-side value in an
operation on <code>x</code>, the value is shifted right by two bits.</p>

<pre><code class="language-swift">let x: UInt8 = 30                 // 0b00011110
let y = x &gt;&gt; 2
// y == 7                         // 0b00000111</code></pre>

<p>If you use <code>11</code> as <code>rhs</code>, <code>x</code> is overshifted such that all of its bits
are set to zero.</p>

<pre><code class="language-swift">let z = x &gt;&gt; 11
// z == 0                         // 0b00000000</code></pre>

<p>Using a negative value as <code>rhs</code> is the same as performing a left shift
using <code>abs(rhs)</code>.</p>

<pre><code class="language-swift">let a = x &gt;&gt; -3
// a == 240                       // 0b11110000
let b = x &lt;&lt; 3
// b == 240                       // 0b11110000</code></pre>

<p>Right shift operations on negative values &quot;fill in&quot; the high bits with
ones instead of zeros.</p>

<pre><code class="language-swift">let q: Int8 = -30                 // 0b11100010
let r = q &gt;&gt; 2
// r == -8                        // 0b11111000

let s = q &gt;&gt; 11
// s == -1                        // 0b11111111</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to shift.
  <strong>rhs:</strong> The number of bits to shift <code>lhs</code> to the right.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;&gt;&lt;Other&gt;(lhs: Self, rhs: Other) -&gt; Self where Other : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FixedWidthInteger/"><code>FixedWidthInteger</code></a>,    <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func--gtgteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gtgteq_rhs_">func &gt;&gt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--gtgteq_rhs_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;&gt;=&lt;Other&gt;(lhs: inout Self, rhs: Other)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func--crt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--crt_rhs_">func ^(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--crt_rhs_"><div class="p">
    <p>Returns the result of performing a bitwise XOR operation on the two given
values.</p>

<p>A bitwise XOR operation, also known as an exclusive OR operation, results
in a value that has each bit set to <code>1</code> where <em>one or the other but not
both</em> of its arguments had that bit set to <code>1</code>. For example:</p>

<pre><code class="language-swift">let x: UInt8 = 5          // 0b00000101
let y: UInt8 = 14         // 0b00001110
let z = x ^ y             // 0b00001011
// z == 11</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer value.
  <strong>rhs:</strong> Another integer value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ^(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--bar_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--bar_rhs_">func |(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--bar_rhs_"><div class="p">
    <p>Returns the result of performing a bitwise OR operation on the two given
values.</p>

<p>A bitwise OR operation results in a value that has each bit set to <code>1</code>
where <em>one or both</em> of its arguments have that bit set to <code>1</code>. For
example:</p>

<pre><code class="language-swift">let x: UInt8 = 5          // 0b00000101
let y: UInt8 = 14         // 0b00001110
let z = x | y             // 0b00001111
// z == 15</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> An integer value.
  <strong>rhs:</strong> Another integer value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func |(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func--tilde_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--tilde_">prefix func ~(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--tilde_"><div class="p">
    <p>Returns the inverse of the bits set in the argument.</p>

<p>The bitwise NOT operator (<code>~</code>) is a prefix operator that returns a value
in which all the bits of its argument are flipped: Bits that are <code>1</code> in
the argument are <code>0</code> in the result, and bits that are <code>0</code> in the argument
are <code>1</code> in the result. This is equivalent to the inverse of a set. For
example:</p>

<pre><code class="language-swift">let x: UInt8 = 5        // 0b00000101
let notX = ~x           // 0b11111010</code></pre>

<p>Performing a bitwise NOT operation on 0 returns a value with every bit
set to <code>1</code>.</p>

<pre><code class="language-swift">let allOnes = ~UInt8.min   // 0b11111111</code></pre>

<p><strong>Complexity:</strong> O(1).</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func ~(x: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func--mns_-self-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--mns_-self-rhs_-self">func -(<wbr>_:<wbr> Self, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--mns_-self-rhs_-self"><div class="p">
    <p>Subtracts one value from another and produces their difference.</p>

<p>The subtraction operator (<code>-</code>) calculates the difference of its two
arguments. For example:</p>

<pre><code class="language-swift">8 - 3                   // 5
-10 - 5                 // -15
100 - -5                // 105
10.5 - 100.0            // -89.5</code></pre>

<p>You cannot use <code>-</code> with arguments of different types. To subtract values
of different types, convert one of the values to the other value&#39;s type.</p>

<pre><code class="language-swift">let x: UInt8 = 21
let y: UInt = 1000000
y - UInt(x)             // 999979</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A numeric value.
  <strong>rhs:</strong> The value to subtract from <code>lhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func -(lhs: Self, rhs: Self) -&gt; Self.Stride</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--mns_-self-rhs_-self-stride">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--mns_-self-rhs_-self-stride">func -(<wbr>_:<wbr> Self, rhs: Self.Stride)</a>
        
<div class="comment collapse" id="comment-func--mns_-self-rhs_-self-stride"><div class="p">
    <p>Subtracts one value from another and produces their difference.</p>

<p>The subtraction operator (<code>-</code>) calculates the difference of its two
arguments. For example:</p>

<pre><code class="language-swift">8 - 3                   // 5
-10 - 5                 // -15
100 - -5                // 105
10.5 - 100.0            // -89.5</code></pre>

<p>You cannot use <code>-</code> with arguments of different types. To subtract values
of different types, convert one of the values to the other value&#39;s type.</p>

<pre><code class="language-swift">let x: UInt8 = 21
let y: UInt = 1000000
y - UInt(x)             // 999979</code></pre>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A numeric value.
  <strong>rhs:</strong> The value to subtract from <code>lhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func -(lhs: Self, rhs: Self.Stride) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--mnseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--mnseq_rhs_">func -=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--mnseq_rhs_"><div class="p">
    <p>Subtracts the second value from the first and stores the difference in the
left-hand-side variable.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A numeric value.
  <strong>rhs:</strong> The value to subtract from <code>lhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func -=(lhs: inout Self, rhs: Self.Stride)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--advanced-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--advanced-by_">func advanced(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func--advanced-by_"><div class="p">
    <p>Returns a value that is offset the specified distance from this value.</p>

<p>Use the <code>advanced(by:)</code> method in generic code to offset a value by a
specified distance. If you&#39;re working directly with numeric values, use
the addition operator (<code>+</code>) instead of this method.</p>

<p>For a value <code>x</code>, a distance <code>n</code>, and a value <code>y = x.advanced(by: n)</code>,
<code>x.distance(to: y) == n</code>.</p>

<p><strong><code>n</code>:</strong>  The distance to advance this value.
<strong>Returns:</strong> A value that is offset from this value by <code>n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func advanced(by n: Int) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--distance-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--distance-to_">func distance(<wbr>to:)</a>
        
<div class="comment collapse" id="comment-func--distance-to_"><div class="p">
    <p>Returns the distance from this value to the given value, expressed as a
stride.</p>

<p>For two values <code>x</code> and <code>y</code>, and a distance <code>n = x.distance(to: y)</code>,
<code>x.advanced(by: n) == y</code>.</p>

<p><strong><code>other</code>:</strong>  The value to calculate the distance to.
<strong>Returns:</strong> The distance from this value to <code>other</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance(to other: Self) -&gt; Int</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--quotientandremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--quotientandremainder-dividingby_">func quotientAndRemainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func--quotientandremainder-dividingby_"><div class="p">
    <p>Returns the quotient and remainder of this value divided by the given
value.</p>

<p>Use this method to calculate the quotient and remainder of a division at
the same time.</p>

<pre><code class="language-swift">let x = 1_000_000
let (q, r) = x.quotientAndRemainder(dividingBy: 933)
// q == 1071
// r == 757</code></pre>

<p><strong><code>rhs</code>:</strong>  The value to divide this value by.
<strong>Returns:</strong> A tuple containing the quotient and remainder of this value
  divided by <code>rhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func quotientAndRemainder(dividingBy rhs: Self) -&gt; (quotient: Self, remainder: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--signum">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--signum">func signum()</a>
        
<div class="comment collapse" id="comment-func--signum"><div class="p">
    <p>Returns <code>-1</code> if this value is negative and <code>1</code> if it&#39;s positive;
otherwise, <code>0</code>.</p>

<p><strong>Returns:</strong> The sign of this number, expressed as an integer of the same
  type.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func signum() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>
<div class="declaration" id="func--unsafeadding_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--unsafeadding_">func unsafeAdding(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--unsafeadding_"><div class="p">
    <p>Returns the sum of this value and the given value without checking for
arithmetic overflow.</p>

<p>Use this function only to avoid the cost of overflow checking when you
are certain that the operation won&#39;t overflow. In optimized builds (<code>-O</code>)
the compiler is free to assume that overflow won&#39;t occur. Failure to
satisfy that assumption is a serious programming error and could lead to
statements being unexpectedly executed or skipped.</p>

<p>In debug builds (<code>-Onone</code>) a runtime error is still triggered if the
operation overflows.</p>

<p><strong><code>rhs</code>:</strong>  The value to add to this value.
<strong>Returns:</strong> The sum of this value and <code>rhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func unsafeAdding(_ other: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--unsafedivided-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--unsafedivided-by_">func unsafeDivided(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func--unsafedivided-by_"><div class="p">
    <p>Returns the quotient obtained by dividing this value by the given value
without checking for arithmetic overflow.</p>

<p>Use this function only to avoid the cost of overflow checking when you
are certain that the operation won&#39;t overflow. In optimized builds (<code>-O</code>)
the compiler is free to assume that overflow won&#39;t occur. Failure to
satisfy that assumption is a serious programming error and could lead to
statements being unexpectedly executed or skipped.</p>

<p>In debug builds (<code>-Onone</code>) a runtime error is still triggered if the
operation overflows.</p>

<p><strong><code>rhs</code>:</strong>  The value to divide this value by.
<strong>Returns:</strong> The result of dividing this value by <code>rhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func unsafeDivided(by other: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--unsafemultiplied-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--unsafemultiplied-by_">func unsafeMultiplied(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func--unsafemultiplied-by_"><div class="p">
    <p>Returns the product of this value and the given value without checking
for arithmetic overflow.</p>

<p>Use this function only to avoid the cost of overflow checking when you
are certain that the operation won&#39;t overflow. In optimized builds (<code>-O</code>)
the compiler is free to assume that overflow won&#39;t occur. Failure to
satisfy that assumption is a serious programming error and could lead to
statements being unexpectedly executed or skipped.</p>

<p>In debug builds (<code>-Onone</code>) a runtime error is still triggered if the
operation overflows.</p>

<p><strong><code>rhs</code>:</strong>  The value to multiply by this value.
<strong>Returns:</strong> The product of this value and <code>rhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func unsafeMultiplied(by other: Self) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func--unsafesubtracting_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--unsafesubtracting_">func unsafeSubtracting(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--unsafesubtracting_"><div class="p">
    <p>Returns the difference obtained by subtracting the given value from this
value without checking for arithmetic overflow.</p>

<p>Use this function only to avoid the cost of overflow checking when you
are certain that the operation won&#39;t overflow. In optimized builds (<code>-O</code>)
the compiler is free to assume that overflow won&#39;t occur. Failure to
satisfy that assumption is a serious programming error and could lead to
statements being unexpectedly executed or skipped.</p>

<p>In debug builds (<code>-Onone</code>) a runtime error is still triggered if the
operation overflows.</p>

<p><strong><code>rhs</code>:</strong>  The value to subtract from this value.
<strong>Returns:</strong> The result of subtracting <code>rhs</code> from this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func unsafeSubtracting(_ other: Self) -&gt; Self</code>
    
    
</div></div>
</div>







<h4>Where Magnitude : UnsignedInteger, Stride : SignedInteger</h4>




<div class="declaration" id="func-magnitude_-unsignedinteger-stride_-signedinteger-random-in_-closedrange-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-magnitude_-unsignedinteger-stride_-signedinteger-random-in_-closedrange-self">static func random(<wbr>in: ClosedRange&lt;Self&gt;)</a>
        
<div class="comment collapse" id="comment-func-magnitude_-unsignedinteger-stride_-signedinteger-random-in_-closedrange-self"><div class="p">
    <p>Returns a random value within the specified range.</p>

<p>Use this method to generate an integer within a specific range. This
example creates three new values in the range <code>1...100</code>.</p>

<pre><code class="language-swift">for _ in 1...3 {
    print(Int.random(in: 1...100))
}
// Prints &quot;53&quot;
// Prints &quot;64&quot;
// Prints &quot;5&quot;</code></pre>

<p>This method uses the default random generator, <code>Random.default</code>. The call
to <code>Int.random(in: 1...100)</code> above is equivalent to calling
<code>Int.random(in: 1...100, using: &amp;Random.default)</code>.</p>

<p><strong><code>range</code>:</strong>  The range in which to create a random value.
<strong>Returns:</strong> A random value within the bounds of <code>range</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func random(in range: ClosedRange&lt;Self&gt;) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-magnitude_-unsignedinteger-stride_-signedinteger-random-in_-range-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-magnitude_-unsignedinteger-stride_-signedinteger-random-in_-range-self">static func random(<wbr>in: Range&lt;Self&gt;)</a>
        
<div class="comment collapse" id="comment-func-magnitude_-unsignedinteger-stride_-signedinteger-random-in_-range-self"><div class="p">
    <p>Returns a random value within the specified range.</p>

<p>Use this method to generate an integer within a specific range. This
example creates three new values in the range <code>1..&lt;100</code>.</p>

<pre><code class="language-swift">for _ in 1...3 {
    print(Int.random(in: 1..&lt;100))
}
// Prints &quot;53&quot;
// Prints &quot;64&quot;
// Prints &quot;5&quot;</code></pre>

<p>This method uses the default random generator, <code>Random.default</code>. The call
to <code>Int.random(in: 1..&lt;100)</code> above is equivalent to calling
<code>Int.random(in: 1..&lt;100, using: &amp;Random.default)</code>.</p>

<p><strong><code>range</code>:</strong>  The range in which to create a random value.
  <code>range</code> must not be empty.
<strong>Returns:</strong> A random value within the bounds of <code>range</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func random(in range: Range&lt;Self&gt;) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-magnitude_-unsignedinteger-stride_-signedinteger-random-t-in_-closedrange-self-using_-inout-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-magnitude_-unsignedinteger-stride_-signedinteger-random-t-in_-closedrange-self-using_-inout-t">static func random&lt;T&gt;(<wbr>in:<wbr> ClosedRange&lt;Self&gt;, using: inout T)</a>
        
<div class="comment collapse" id="comment-func-magnitude_-unsignedinteger-stride_-signedinteger-random-t-in_-closedrange-self-using_-inout-t"><div class="p">
    <p>Returns a random value within the specified range, using the given
generator as a source for randomness.</p>

<p>Use this method to generate an integer within a specific range when you
are using a custom random number generator. This example creates three
new values in the range <code>1...100</code>.</p>

<pre><code class="language-swift">for _ in 1...3 {
    print(Int.random(in: 1...100, using: &amp;myGenerator))
}
// Prints &quot;7&quot;
// Prints &quot;44&quot;
// Prints &quot;21&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>range:</strong> The range in which to create a random value.
  <strong>generator:</strong> The random number generator to use when creating the
    new random value.
<strong>Returns:</strong> A random value within the bounds of <code>range</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func random&lt;T&gt;(in range: ClosedRange&lt;Self&gt;, using generator: inout T) -&gt; Self where T : RandomNumberGenerator</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-magnitude_-unsignedinteger-stride_-signedinteger-random-t-in_-range-self-using_-inout-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-magnitude_-unsignedinteger-stride_-signedinteger-random-t-in_-range-self-using_-inout-t">static func random&lt;T&gt;(<wbr>in:<wbr> Range&lt;Self&gt;, using: inout T)</a>
        
<div class="comment collapse" id="comment-func-magnitude_-unsignedinteger-stride_-signedinteger-random-t-in_-range-self-using_-inout-t"><div class="p">
    <p>Returns a random value within the specified range, using the given
generator as a source for randomness.</p>

<p>Use this method to generate an integer within a specific range when you
are using a custom random number generator. This example creates three
new values in the range <code>1..&lt;100</code>.</p>

<pre><code class="language-swift">for _ in 1...3 {
    print(Int.random(in: 1..&lt;100, using: &amp;myGenerator))
}
// Prints &quot;7&quot;
// Prints &quot;44&quot;
// Prints &quot;21&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>range:</strong> The range in which to create a random value.
    <code>range</code> must not be empty.
  <strong>generator:</strong> The random number generator to use when creating the
    new random value.
<strong>Returns:</strong> A random value within the bounds of <code>range</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func random&lt;T&gt;(in range: Range&lt;Self&gt;, using generator: inout T) -&gt; Self where T : RandomNumberGenerator</code>
    
    
</div></div>
</div>





<h4>Where Stride : SignedInteger</h4>




<div class="declaration inherited" id="func-stride_-signedinteger-dotdotdot_maximum_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-stride_-signedinteger-dotdotdot_maximum_">func ...(<wbr>_:<wbr>maximum:)</a>
        
<div class="comment collapse" id="comment-func-stride_-signedinteger-dotdotdot_maximum_"><div class="p">
    <p>Returns a countable closed range that contains both of its bounds.</p>

<p>Use the closed range operator (<code>...</code>) to create a closed range of any type
that conforms to the <code>Strideable</code> protocol with an associated signed
integer <code>Stride</code> type, such as any of the standard library&#39;s integer
types. This example creates a <code>ClosedRange&lt;Int&gt;</code> from zero up to,
and including, nine.</p>

<pre><code class="language-swift">let singleDigits = 0...9
print(singleDigits.contains(9))
// Prints &quot;true&quot;</code></pre>

<p>You can use sequence or collection methods on the <code>singleDigits</code> range.</p>

<pre><code class="language-swift">print(singleDigits.count)
// Prints &quot;10&quot;
print(singleDigits.last)
// Prints &quot;9&quot;</code></pre>

<p><strong>Parameters:</strong>)`.
  <strong>minimum:</strong> The lower bound for the range.
  <strong>maximum:</strong> The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ...(minimum: Self, maximum: Self) -&gt; ClosedRange&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BinaryInteger/"><code>BinaryInteger</code></a>    
</div></div>
</div>



