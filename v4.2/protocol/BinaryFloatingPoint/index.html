---
layout: "default"
title: "BinaryFloatingPoint"
description: "Swift documentation for 'BinaryFloatingPoint': A radix-2 (binary) floating-point type."
keywords: "BinaryFloatingPoint,protocol,swift,documentation,*,*=,+,+=,/,/=,<,<=,==,>,>=,-,-,-=,addProduct,addingProduct,advanced,distance,formRemainder,formSquareRoot,formTruncatingRemainder,hash,isEqual,isLess,isLessThanOrEqualTo,isTotallyOrdered,maximum,maximumMagnitude,minimum,minimumMagnitude,negate,remainder,round,rounded,squareRoot,truncatingRemainder,binade,exponentBitCount,exponentBitPattern,significandBitCount,significandBitPattern,significandWidth,exponent,floatingPointClass,greatestFiniteMagnitude,infinity,isCanonical,isFinite,isInfinite,isNaN,isNormal,isSignalingNaN,isSubnormal,isZero,leastNonzeroMagnitude,leastNormalMagnitude,nan,nextDown,nextUp,pi,radix,sign,signalingNaN,significand,ulp,ulpOfOne,hashValue,magnitude,RawSignificand,RawExponent,FloatLiteralType,IntegerLiteralType,Magnitude,Exponent,Stride"
root: "/v4.2"
---

<div class="intro-declaration"><code class="language-swift">protocol BinaryFloatingPoint</code></div>

<div class="discussion comment">
    <p>A radix-2 (binary) floating-point type.</p>

<p>The <code>BinaryFloatingPoint</code> protocol extends the <code>FloatingPoint</code> protocol
with operations specific to floating-point binary types, as defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>. <code>BinaryFloatingPoint</code> is implemented in
the standard library by <code>Float</code>, <code>Double</code>, and <code>Float80</code> where available.</p>
</div>

<table class="standard">
<tr>
<th id="inheritance">Inheritance</th>
<td>
<code class="inherits">Comparable, Equatable, ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral, FloatingPoint, Hashable, Numeric, SignedNumeric, Strideable</code>
<span class="viz"><a href="hierarchy/">View Protocol Hierarchy &rarr;</a></span>
</td>
</tr>

<tr>
<th id="aliases">Associated Types</th>
<td>
<span id="aliasesmark"></span>
<div class="declaration">
<code class="language-swift">RawSignificand : UnsignedInteger</code>
<div class="comment">
    <p>A type that represents the encoded significand of a value.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">RawExponent : UnsignedInteger</code>
<div class="comment">
    <p>A type that represents the encoded exponent of a value.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">FloatLiteralType : _ExpressibleByBuiltinFloatLiteral</code>
<div class="comment">
    <p>A type that represents a floating-point literal.</p>

<p>Valid types for <code>FloatLiteralType</code> are <code>Float</code>, <code>Double</code>, and <code>Float80</code>
where available.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral</code>
<div class="comment">
    <p>A type that represents an integer literal.</p>

<p>The standard library integer and floating-point types are all valid types
for <code>IntegerLiteralType</code>.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">Magnitude = Self</code>
<div class="comment">
    <p>A type that can represent the absolute value of any possible value of the
conforming type.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">Exponent : SignedInteger</code>
<div class="comment">
    <p>A type that can represent any written exponent.</p>
</div>
</div>
<div class="declaration inherited">
<code class="language-swift">Stride : Comparable, SignedNumeric</code>
<div class="comment">
    <p>A type that represents the distance between two values.</p>
</div>
</div>
</td>
</tr>


<tr>
<th>Import</th>
<td><code class="language-swift">import Swift</code></td>
</tr>

</table>


<h3>Initializers</h3>
<div class="declaration" id="init_-double">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-double">init(<wbr>_: Double)</a><div class="comment collapse" id="comment-init_-double"><div class="p">
    <p>Creates a new instance from the given value, rounded to the closest
possible representation.</p>

<p><strong><code>value</code>:</strong>  A floating-point value to be converted.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Double)</code>

    </div></div>
</div>
<div class="declaration" id="init_-float">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-float">init(<wbr>_: Float)</a><div class="comment collapse" id="comment-init_-float"><div class="p">
    <p>Creates a new instance from the given value, rounded to the closest
possible representation.</p>

<p><strong><code>value</code>:</strong>  A floating-point value to be converted.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Float)</code>

    </div></div>
</div>
<div class="declaration" id="init_-float80">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-float80">init(<wbr>_: Float80)</a><div class="comment collapse" id="comment-init_-float80"><div class="p">
    <p>Creates a new instance from the given value, rounded to the closest
possible representation.</p>

<p><strong><code>value</code>:</strong>  A floating-point value to be converted.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Float80)</code>

    </div></div>
</div>
<div class="declaration" id="init-source_-source">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-source_-source">init&lt;Source&gt;(<wbr>_: Source)</a><div class="comment collapse" id="comment-init-source_-source"><div class="p">
    <p>Creates a new instance from the given value, rounded to the closest
possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  A floating-point value to be converted.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;Source&gt;(_ value: Source)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryFloatingPoint/"><code>BinaryFloatingPoint</code></a>
        ,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration" id="init-sign_exponentbitpattern_significandbitpattern_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-sign_exponentbitpattern_significandbitpattern_">init(<wbr>sign:<wbr>exponentBitPattern:<wbr>significandBitPattern:)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init-sign_exponentbitpattern_significandbitpattern_"><div class="p">
    <p>Creates a new instance from the specified sign and bit patterns.</p>

<p>The values passed as <code>exponentBitPattern</code> and <code>significandBitPattern</code> are
interpreted in the binary interchange format defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>sign:</strong> The sign of the new value.
  <strong>exponentBitPattern:</strong> The bit pattern to use for the exponent field of
    the new value.
  <strong>significandBitPattern:</strong> The bit pattern to use for the significand
    field of the new value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(sign: FloatingPointSign, exponentBitPattern: Self.RawExponent, significandBitPattern: Self.RawSignificand)</code>

    </div></div>
</div>
<div class="declaration" id="init-exactly_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-exactly_">init?(<wbr>exactly:)</a><div class="comment collapse" id="comment-init-exactly_"><div class="p">
    <p>Creates a new instance from the given value, if it can be represented
exactly.</p>

<p>If the given floating-point value cannot be represented exactly, the
result is <code>nil</code>. A value that is NaN (&quot;not a number&quot;) cannot be
represented exactly if its payload cannot be encoded exactly.</p>

<p><strong><code>value</code>:</strong>  A floating-point value to be converted.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?&lt;Source&gt;(exactly value: Source)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BinaryFloatingPoint/"><code>BinaryFloatingPoint</code></a>
        ,    <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        ,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-floatliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-floatliteral_">init(<wbr>floatLiteral:)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init-floatliteral_"><div class="p">
    <p>Creates an instance initialized to the specified floating-point value.</p>

<p>Do not call this initializer directly. Instead, initialize a variable or
constant using a floating-point literal. For example:</p>

<pre><code class="language-swift">let x = 21.5</code></pre>

<p>In this example, the assignment to the <code>x</code> constant calls this
floating-point literal initializer behind the scenes.</p>

<p><strong><code>value</code>:</strong>  The value to create.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(floatLiteral value: Self.FloatLiteralType)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/ExpressibleByFloatLiteral/"><code>ExpressibleByFloatLiteral</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-integerliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-integerliteral_">init(<wbr>integerLiteral:)</a><div class="comment collapse" id="comment-init-integerliteral_"><div class="p">
    <p>Creates an instance initialized to the specified integer value.</p>

<p>Do not call this initializer directly. Instead, initialize a variable or
constant using an integer literal. For example:</p>

<pre><code class="language-swift">let x = 23</code></pre>

<p>In this example, the assignment to the <code>x</code> constant calls this integer
literal initializer behind the scenes.</p>

<p><strong><code>value</code>:</strong>  The value to create.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(integerLiteral value: Self.IntegerLiteralType)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/ExpressibleByIntegerLiteral/"><code>ExpressibleByIntegerLiteral</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int">init(<wbr>_: Int)</a><div class="comment collapse" id="comment-init_-int"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int8">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int8">init(<wbr>_: Int8)</a><div class="comment collapse" id="comment-init_-int8"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int8)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int16">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int16">init(<wbr>_: Int16)</a><div class="comment collapse" id="comment-init_-int16"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int16)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int32">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int32">init(<wbr>_: Int32)</a><div class="comment collapse" id="comment-init_-int32"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int32)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-int64">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-int64">init(<wbr>_: Int64)</a><div class="comment collapse" id="comment-init_-int64"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: Int64)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint">init(<wbr>_: UInt)</a><div class="comment collapse" id="comment-init_-uint"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint8">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint8">init(<wbr>_: UInt8)</a><div class="comment collapse" id="comment-init_-uint8"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt8)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint16">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint16">init(<wbr>_: UInt16)</a><div class="comment collapse" id="comment-init_-uint16"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt16)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint32">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint32">init(<wbr>_: UInt32)</a><div class="comment collapse" id="comment-init_-uint32"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt32)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init_-uint64">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_-uint64">init(<wbr>_: UInt64)</a><div class="comment collapse" id="comment-init_-uint64"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(_ value: UInt64)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-sign_exponent_significand_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-sign_exponent_significand_">init(<wbr>sign:<wbr>exponent:<wbr>significand:)</a> <span class="required">Required</span><div class="comment collapse" id="comment-init-sign_exponent_significand_"><div class="p">
    <p>Creates a new value from the given sign, exponent, and significand.</p>

<p>The following example uses this initializer to create a new <code>Double</code>
instance. <code>Double</code> is a binary floating-point type that has a radix of
<code>2</code>.</p>

<pre><code class="language-swift">let x = Double(sign: .plus, exponent: -2, significand: 1.5)
// x == 0.375</code></pre>

<p>This initializer is equivalent to the following calculation, where <code>**</code>
is exponentiation, computed as if by a single, correctly rounded,
floating-point operation:</p>

<pre><code class="language-swift">let sign: FloatingPointSign = .plus
let exponent = -2
let significand = 1.5
let y = (sign == .minus ? -1 : 1) * significand * Double.radix ** exponent
// y == 0.375</code></pre>

<p>As with any basic operation, if this value is outside the representable
range of the type, overflow or underflow occurs, and zero, a subnormal
value, or infinity may result. In addition, there are two other edge
cases:</p>

<ul><li>If the value you pass to <code>significand</code> is zero or infinite, the result
is zero or infinite, regardless of the value of <code>exponent</code>.</li><li>If the value you pass to <code>significand</code> is NaN, the result is NaN.</li></ul>

<p>For any floating-point value <code>x</code> of type <code>F</code>, the result of the following
is equal to <code>x</code>, with the distinction that the result is canonicalized
if <code>x</code> is in a noncanonical encoding:</p>

<pre><code class="language-swift">let x0 = F(sign: x.sign, exponent: x.exponent, significand: x.significand)</code></pre>

<p>This initializer implements the <code>scaleB</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE
754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>sign:</strong> The sign to use for the new value.
  <strong>exponent:</strong> The new value&#39;s exponent.
  <strong>significand:</strong> The new value&#39;s significand.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(sign: FloatingPointSign, exponent: Self.Exponent, significand: Self)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="init-signof_magnitudeof_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-signof_magnitudeof_">init(<wbr>signOf:<wbr>magnitudeOf:)</a><div class="comment collapse" id="comment-init-signof_magnitudeof_"><div class="p">
    <p>Creates a new floating-point value using the sign of one value and the
magnitude of another.</p>

<p>The following example uses this initializer to create a new <code>Double</code>
instance with the sign of <code>a</code> and the magnitude of <code>b</code>:</p>

<pre><code class="language-swift">let a = -21.5
let b = 305.15
let c = Double(signOf: a, magnitudeOf: b)
print(c)
// Prints &quot;-305.15&quot;</code></pre>

<p>This initializer implements the IEEE 754 <code>copysign</code> operation.</p>

<p><strong>Parameters:</strong>
  <strong>signOf:</strong> A value from which to use the sign. The result of the
    initializer has the same sign as <code>signOf</code>.
  <strong>magnitudeOf:</strong> A value from which to use the magnitude. The result of
    the initializer has the same magnitude as <code>magnitudeOf</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(signOf: Self, magnitudeOf: Self)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>

<h3>Static Variables</h3>
<div class="declaration" id="static-var-exponentbitcount_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-exponentbitcount_-int">static var exponentBitCount: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-exponentbitcount_-int"><div class="p">
    <p>The number of bits used to represent the type&#39;s exponent.</p>

<p>A binary floating-point type&#39;s <code>exponentBitCount</code> imposes a limit on the
range of the exponent for normal, finite values. The <em>exponent bias</em> of
a type <code>F</code> can be calculated as the following, where <code>**</code> is
exponentiation:</p>

<pre><code class="language-swift">let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>

<p>The least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and
the largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved
for subnormals and zeros, and an all-ones exponent is reserved for
infinity and NaN.</p>

<p>For example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives
an exponent bias of <code>127</code> by the calculation above.</p>

<pre><code class="language-swift">let bias = 2 ** (Float.exponentBitCount - 1) - 1
// bias == 127
print(Float.greatestFiniteMagnitude.exponent)
// Prints &quot;127&quot;
print(Float.leastNormalMagnitude.exponent)
// Prints &quot;-126&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">static var exponentBitCount: Int { get }</code>

    </div></div>
</div>
<div class="declaration" id="static-var-significandbitcount_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-significandbitcount_-int">static var significandBitCount: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-significandbitcount_-int"><div class="p">
    <p>The available number of fractional significand bits.</p>

<p>For fixed-width floating-point types, this is the actual number of
fractional significand bits.</p>

<p>For extensible floating-point types, <code>significandBitCount</code> should be the
maximum allowed significand width (without counting any leading integral
bit of the significand). If there is no upper limit, then
<code>significandBitCount</code> should be <code>Int.max</code>.</p>

<p>Note that <code>Float80.significandBitCount</code> is 63, even though 64 bits are
used to store the significand in the memory representation of a
<code>Float80</code> (unlike other floating-point types, <code>Float80</code> explicitly
stores the leading integral significand bit, but the
<code>BinaryFloatingPoint</code> APIs provide an abstraction so that users don&#39;t
need to be aware of this detail).</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var significandBitCount: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="static-var-greatestfinitemagnitude_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-greatestfinitemagnitude_-self">static var greatestFiniteMagnitude: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-greatestfinitemagnitude_-self"><div class="p">
    <p>The greatest finite number representable by this type.</p>

<p>This value compares greater than or equal to all finite numbers, but less
than <code>infinity</code>.</p>

<p>This value corresponds to type-specific C macros such as <code>FLT_MAX</code> and
<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because
<code>infinity</code> is greater than this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var greatestFiniteMagnitude: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-infinity_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-infinity_-self">static var infinity: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-infinity_-self"><div class="p">
    <p>Positive infinity.</p>

<p>Infinity compares greater than all finite numbers and equal to other
infinite values.</p>

<pre><code class="language-swift">let x = Double.greatestFiniteMagnitude
let y = x * 2
// y == Double.infinity
// y &gt; x</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">static var infinity: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-leastnonzeromagnitude_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-leastnonzeromagnitude_-self">static var leastNonzeroMagnitude: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-leastnonzeromagnitude_-self"><div class="p">
    <p>The least positive number.</p>

<p>This value compares less than or equal to all positive numbers, but
greater than zero. If the type supports subnormal values,
<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;
otherwise they are equal.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var leastNonzeroMagnitude: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-leastnormalmagnitude_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-leastnormalmagnitude_-self">static var leastNormalMagnitude: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-leastnormalmagnitude_-self"><div class="p">
    <p>The least positive normal number.</p>

<p>This value compares less than or equal to all positive normal numbers.
There may be smaller positive numbers, but they are <em>subnormal</em>, meaning
that they are represented with less precision than normal numbers.</p>

<p>This value corresponds to type-specific C macros such as <code>FLT_MIN</code> and
<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because
subnormals, zeros, and negative numbers are smaller than this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var leastNormalMagnitude: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-nan_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-nan_-self">static var nan: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-nan_-self"><div class="p">
    <p>A quiet NaN (&quot;not a number&quot;).</p>

<p>A NaN compares not equal, not greater than, and not less than every
value, including itself. Passing a NaN to an operation generally results
in NaN.</p>

<pre><code class="language-swift">let x = 1.21
// x &gt; Double.nan == false
// x &lt; Double.nan == false
// x == Double.nan == false</code></pre>

<p>Because a NaN always compares not equal to itself, to test whether a
floating-point value is NaN, use its <code>isNaN</code> property instead of the
equal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.</p>

<pre><code class="language-swift">let y = x + Double.nan
print(y == Double.nan)
// Prints &quot;false&quot;
print(y.isNaN)
// Prints &quot;true&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">static var nan: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-pi_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-pi_-self">static var pi: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-pi_-self"><div class="p">
    <p>The mathematical constant pi.</p>

<p>This value should be rounded toward zero to keep user computations with
angles from inadvertently ending up in the wrong quadrant. A type that
conforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at
its best possible precision.</p>

<pre><code class="language-swift">print(Double.pi)
// Prints &quot;3.14159265358979&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">static var pi: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-radix_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-radix_-int">static var radix: Int</a><div class="comment collapse" id="comment-static-var-radix_-int"><div class="p">
    <p>The radix, or base of exponentiation, for a floating-point type.</p>

<p>The magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated
by using the following formula, where <code>**</code> is exponentiation:</p>

<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent</code></pre>

<p>A conforming type may use any integer radix, but values other than 2 (for
binary floating-point types) or 10 (for decimal floating-point types)
are extraordinarily rare in practice.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var radix: Int { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-signalingnan_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-signalingnan_-self">static var signalingNaN: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-static-var-signalingnan_-self"><div class="p">
    <p>A signaling NaN (&quot;not a number&quot;).</p>

<p>The default IEEE 754 behavior of operations involving a signaling NaN is
to raise the Invalid flag in the floating-point environment and return a
quiet NaN.</p>

<p>Operations on types conforming to the <code>FloatingPoint</code> protocol should
support this behavior, but they might also support other options. For
example, it would be reasonable to implement alternative operations in
which operating on a signaling NaN triggers a runtime error or results
in a diagnostic for debugging purposes. Types that implement alternative
behaviors for a signaling NaN must document the departure.</p>

<p>Other than these signaling operations, a signaling NaN behaves in the
same manner as a quiet NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var signalingNaN: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="static-var-ulpofone_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-static-var-ulpofone_-self">static var ulpOfOne: Self</a><div class="comment collapse" id="comment-static-var-ulpofone_-self"><div class="p">
    <p>The unit in the last place of 1.0.</p>

<p>The positive difference between 1.0 and the next greater representable
number. The <code>ulpOfOne</code> constant corresponds to the C macros
<code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, and others with a similar purpose.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var ulpOfOne: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>

<h3>Instance Variables</h3>
<div class="declaration" id="var-binade_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-binade_-self">var binade: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-binade_-self"><div class="p">
    <p>The floating-point value with the same sign and exponent as this value,
but with a significand of 1.0.</p>

<p>A <em>binade</em> is a set of binary floating-point values that all have the
same sign and exponent. The <code>binade</code> property is a member of the same
binade as this value, but with a unit significand.</p>

<p>In this example, <code>x</code> has a value of <code>21.5</code>, which is stored as
<code>1.34375 * 2**4</code>, where <code>**</code> is exponentiation. Therefore, <code>x.binade</code> is
equal to <code>1.0 * 2**4</code>, or <code>16.0</code>.</p>

<pre><code class="language-swift">let x = 21.5
// x.significand == 1.34375
// x.exponent == 4

let y = x.binade
// y == 16.0
// y.significand == 1.0
// y.exponent == 4</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var binade: Self { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-exponentbitpattern_-self-rawexponent">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-exponentbitpattern_-self-rawexponent">var exponentBitPattern: Self.RawExponent</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-exponentbitpattern_-self-rawexponent"><div class="p">
    <p>The raw encoding of the value&#39;s exponent field.</p>

<p>This value is unadjusted by the type&#39;s exponent bias.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var exponentBitPattern: Self.RawExponent { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-significandbitpattern_-self-rawsignificand">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-significandbitpattern_-self-rawsignificand">var significandBitPattern: Self.RawSignificand</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-significandbitpattern_-self-rawsignificand"><div class="p">
    <p>The raw encoding of the value&#39;s significand field.</p>

<p>The <code>significandBitPattern</code> property does not include the leading
integral bit of the significand, even for types like <code>Float80</code> that
store it explicitly.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var significandBitPattern: Self.RawSignificand { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-significandwidth_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-significandwidth_-int">var significandWidth: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-significandwidth_-int"><div class="p">
    <p>The number of bits required to represent the value&#39;s significand.</p>

<p>If this value is a finite nonzero number, <code>significandWidth</code> is the
number of fractional bits required to represent the value of
<code>significand</code>; otherwise, <code>significandWidth</code> is -1. The value of
<code>significandWidth</code> is always -1 or between zero and
<code>significandBitCount</code>. For example:</p>

<ul><li>For any representable power of two, <code>significandWidth</code> is zero, because
<code>significand</code> is <code>1.0</code>.</li><li>If <code>x</code> is 10, <code>x.significand</code> is <code>1.01</code> in binary, so
<code>x.significandWidth</code> is 2.</li><li>If <code>x</code> is Float.pi, <code>x.significand</code> is <code>1.10010010000111111011011</code> in
binary, and <code>x.significandWidth</code> is 23.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var significandWidth: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="var-exponent_-self-exponent">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-exponent_-self-exponent">var exponent: Self.Exponent</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-exponent_-self-exponent"><div class="p">
    <p>The exponent of the floating-point value.</p>

<p>The <em>exponent</em> of a floating-point value is the integer part of the
logarithm of the value&#39;s magnitude. For a value <code>x</code> of a floating-point
type <code>F</code>, the magnitude can be calculated as the following, where <code>**</code>
is exponentiation:</p>

<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent</code></pre>

<p>In the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as
<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.</p>

<pre><code class="language-swift">let y: Double = 21.5
// y.significand == 1.34375
// y.exponent == 4
// Double.radix == 2</code></pre>

<p>The <code>exponent</code> property has the following edge cases:</p>

<ul><li>If <code>x</code> is zero, then <code>x.exponent</code> is <code>Int.min</code>.</li><li>If <code>x</code> is +/-infinity or NaN, then <code>x.exponent</code> is <code>Int.max</code></li></ul>

<p>This property implements the <code>logB</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var exponent: Self.Exponent { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-floatingpointclass_-floatingpointclassification">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-floatingpointclass_-floatingpointclassification">var floatingPointClass: FloatingPointClassification</a><div class="comment collapse" id="comment-var-floatingpointclass_-floatingpointclassification"><div class="p">
    <p>The classification of this value.</p>

<p>A value&#39;s <code>floatingPointClass</code> property describes its &quot;class&quot; as
described by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var floatingPointClass: FloatingPointClassification { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-iscanonical_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-iscanonical_-bool">var isCanonical: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-iscanonical_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance&#39;s representation is in
the canonical form.</p>

<p>The <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a> defines a <em>canonical</em>, or preferred,
encoding of a floating-point value&#39;s representation. Every <code>Float</code> or
<code>Double</code> value is canonical, but noncanonical values of the <code>Float80</code>
type exist, and noncanonical values may exist for other types that
conform to the <code>FloatingPoint</code> protocol.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isCanonical: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-isfinite_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isfinite_-bool">var isFinite: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-isfinite_-bool"><div class="p">
    <p>A Boolean value indicating whether this instance is finite.</p>

<p>All values other than NaN and infinity are considered finite, whether
normal or subnormal.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isFinite: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-isinfinite_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isinfinite_-bool">var isInfinite: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-isinfinite_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is infinite.</p>

<p>Note that <code>isFinite</code> and <code>isInfinite</code> do not form a dichotomy, because
they are not total: If <code>x</code> is <code>NaN</code>, then both properties are <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isInfinite: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-isnan_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isnan_-bool">var isNaN: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-isnan_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is NaN (&quot;not a number&quot;).</p>

<p>Because NaN is not equal to any value, including NaN, use this property
instead of the equal-to operator (<code>==</code>) or not-equal-to operator (<code>!=</code>)
to test whether a value is or is not NaN. For example:</p>

<pre><code class="language-swift">let x = 0.0
let y = x * .infinity
// y is a NaN

// Comparing with the equal-to operator never returns &#39;true&#39;
print(x == Double.nan)
// Prints &quot;false&quot;
print(y == Double.nan)
// Prints &quot;false&quot;

// Test with the &#39;isNaN&#39; property instead
print(x.isNaN)
// Prints &quot;false&quot;
print(y.isNaN)
// Prints &quot;true&quot;</code></pre>

<p>This property is <code>true</code> for both quiet and signaling NaNs.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isNaN: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-isnormal_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isnormal_-bool">var isNormal: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-isnormal_-bool"><div class="p">
    <p>A Boolean value indicating whether this instance is normal.</p>

<p>A <em>normal</em> value is a finite number that uses the full precision
available to values of a type. Zero is neither a normal nor a subnormal
number.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isNormal: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-issignalingnan_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-issignalingnan_-bool">var isSignalingNaN: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-issignalingnan_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is a signaling NaN.</p>

<p>Signaling NaNs typically raise the Invalid flag when used in general
computing operations.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isSignalingNaN: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-issubnormal_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-issubnormal_-bool">var isSubnormal: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-issubnormal_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is subnormal.</p>

<p>A <em>subnormal</em> value is a nonzero number that has a lesser magnitude than
the smallest normal number. Subnormal values do not use the full
precision available to values of a type.</p>

<p>Zero is neither a normal nor a subnormal number. Subnormal numbers are
often called <em>denormal</em> or <em>denormalized</em>---these are different names
for the same concept.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isSubnormal: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-iszero_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-iszero_-bool">var isZero: Bool</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-iszero_-bool"><div class="p">
    <p>A Boolean value indicating whether the instance is equal to zero.</p>

<p>The <code>isZero</code> property of a value <code>x</code> is <code>true</code> when <code>x</code> represents either
<code>-0.0</code> or <code>+0.0</code>. <code>x.isZero</code> is equivalent to the following comparison:
<code>x == 0.0</code>.</p>

<pre><code class="language-swift">let x = -0.0
x.isZero        // true
x == 0.0        // true</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var isZero: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-nextdown_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-nextdown_-self">var nextDown: Self</a><div class="comment collapse" id="comment-var-nextdown_-self"><div class="p">
    <p>The greatest representable value that compares less than this value.</p>

<p>For any finite value <code>x</code>, <code>x.nextDown</code> is less than <code>x</code>. For <code>nan</code> or
<code>-infinity</code>, <code>x.nextDown</code> is <code>x</code> itself. The following special cases
also apply:</p>

<ul><li>If <code>x</code> is <code>infinity</code>, then <code>x.nextDown</code> is <code>greatestFiniteMagnitude</code>.</li><li>If <code>x</code> is <code>leastNonzeroMagnitude</code>, then <code>x.nextDown</code> is <code>0.0</code>.</li><li>If <code>x</code> is zero, then <code>x.nextDown</code> is <code>-leastNonzeroMagnitude</code>.</li><li>If <code>x</code> is <code>-greatestFiniteMagnitude</code>, then <code>x.nextDown</code> is <code>-infinity</code>.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var nextDown: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-nextup_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-nextup_-self">var nextUp: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-nextup_-self"><div class="p">
    <p>The least representable value that compares greater than this value.</p>

<p>For any finite value <code>x</code>, <code>x.nextUp</code> is greater than <code>x</code>. For <code>nan</code> or
<code>infinity</code>, <code>x.nextUp</code> is <code>x</code> itself. The following special cases also
apply:</p>

<ul><li>If <code>x</code> is <code>-infinity</code>, then <code>x.nextUp</code> is <code>-greatestFiniteMagnitude</code>.</li><li>If <code>x</code> is <code>-leastNonzeroMagnitude</code>, then <code>x.nextUp</code> is <code>-0.0</code>.</li><li>If <code>x</code> is zero, then <code>x.nextUp</code> is <code>leastNonzeroMagnitude</code>.</li><li>If <code>x</code> is <code>greatestFiniteMagnitude</code>, then <code>x.nextUp</code> is <code>infinity</code>.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var nextUp: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-sign_-floatingpointsign">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-sign_-floatingpointsign">var sign: FloatingPointSign</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-sign_-floatingpointsign"><div class="p">
    <p>The sign of the floating-point value.</p>

<p>The <code>sign</code> property is <code>.minus</code> if the value&#39;s signbit is set, and
<code>.plus</code> otherwise. For example:</p>

<pre><code class="language-swift">let x = -33.375
// x.sign == .minus</code></pre>

<p>Do not use this property to check whether a floating point value is
negative. For a value <code>x</code>, the comparison <code>x.sign == .minus</code> is not
necessarily the same as <code>x &lt; 0</code>. In particular, <code>x.sign == .minus</code> if
<code>x</code> is -0, and while <code>x &lt; 0</code> is always <code>false</code> if <code>x</code> is NaN, <code>x.sign</code>
could be either <code>.plus</code> or <code>.minus</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var sign: FloatingPointSign { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-significand_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-significand_-self">var significand: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-significand_-self"><div class="p">
    <p>The significand of the floating-point value.</p>

<p>The magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated
by using the following formula, where <code>**</code> is exponentiation:</p>

<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent</code></pre>

<p>In the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as
<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.</p>

<pre><code class="language-swift">let y: Double = 21.5
// y.significand == 1.34375
// y.exponent == 4
// Double.radix == 2</code></pre>

<p>If a type&#39;s radix is 2, then for finite nonzero numbers, the significand
is in the range <code>1.0 ..&lt; 2.0</code>. For other values of <code>x</code>, <code>x.significand</code>
is defined as follows:</p>

<ul><li>If <code>x</code> is zero, then <code>x.significand</code> is 0.0.</li><li>If <code>x</code> is infinity, then <code>x.significand</code> is 1.0.</li><li>If <code>x</code> is NaN, then <code>x.significand</code> is NaN.
<strong>Note:</strong> The significand is frequently also called the <em>mantissa</em>, but
significand is the preferred terminology in the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>, to allay confusion with the use of mantissa for
the fractional part of a logarithm.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var significand: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-ulp_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-ulp_-self">var ulp: Self</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-ulp_-self"><div class="p">
    <p>The unit in the last place of this value.</p>

<p>This is the unit of the least significant digit in this value&#39;s
significand. For most numbers <code>x</code>, this is the difference between <code>x</code>
and the next greater (in magnitude) representable number. There are some
edge cases to be aware of:</p>

<ul><li>If <code>x</code> is not a finite number, then <code>x.ulp</code> is NaN.</li><li>If <code>x</code> is very small in magnitude, then <code>x.ulp</code> may be a subnormal
number. If a type does not support subnormals, <code>x.ulp</code> may be rounded
to zero.</li><li><code>greatestFiniteMagnitude.ulp</code> is a finite number, even though the next
greater representable value is <code>infinity</code>.</li></ul>

<p>This quantity, or a related quantity, is sometimes called <em>epsilon</em> or
<em>machine epsilon.</em> Avoid that name because it has different meanings in
different languages, which can lead to confusion, and because it
suggests that it is a good tolerance to use for comparisons, which it
almost never is.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var ulp: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-hashvalue_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-hashvalue_-int">var hashValue: Int</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-hashvalue_-int"><div class="p">
    <p>The hash value.</p>

<p>Hash values are not guaranteed to be equal across different executions of
your program. Do not save hash values to use during a future execution.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var hashValue: Int { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Hashable/"><code>Hashable</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-magnitude_-self-magnitude">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-magnitude_-self-magnitude">var magnitude: Self.Magnitude</a> <span class="required">Required</span><div class="comment collapse" id="comment-var-magnitude_-self-magnitude"><div class="p">
    <p>The magnitude of this value.</p>

<p>For any numeric value <code>x</code>, <code>x.magnitude</code> is the absolute value of <code>x</code>.
You can use the <code>magnitude</code> property in operations that are simpler to
implement in terms of unsigned values, such as printing the value of an
integer, which is just printing a &#39;-&#39; character in front of an absolute
value.</p>

<pre><code class="language-swift">let x = -200
// x.magnitude == 200</code></pre>

<p>The global <code>abs(_:)</code> function provides more familiar syntax when you need
to find an absolute value. In addition, because <code>abs(_:)</code> always returns
a value of the same type, even in a generic context, using the function
instead of the <code>magnitude</code> property is encouraged.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var magnitude: Self.Magnitude { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Numeric/"><code>Numeric</code></a>
        </div></div>
</div>


<h3>Static Methods</h3>
<div class="declaration inherited" id="func-maximum__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-maximum__">static func maximum(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-maximum__"><div class="p">
    <p>Returns the greater of the two given values.</p>

<p>This method returns the maximum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>maximum(x, y)</code> is <code>x</code> if <code>x &gt; y</code>, <code>y</code> if <code>x &lt;= y</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>

<pre><code class="language-swift">Double.maximum(10.0, -25.0)
// 10.0
Double.maximum(10.0, .nan)
// 10.0
Double.maximum(.nan, -25.0)
// -25.0
Double.maximum(.nan, .nan)
// nan</code></pre>

<p>The <code>maximum</code> method implements the <code>maxNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> The greater of <code>x</code> and <code>y</code>, or whichever is a number if the
  other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func maximum(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-maximummagnitude__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-maximummagnitude__">static func maximumMagnitude(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-maximummagnitude__"><div class="p">
    <p>Returns the value with greater magnitude.</p>

<p>This method returns the value with greater magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>maximumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &gt; y.magnitude</code>, <code>y</code> if <code>x.magnitude &lt;= y.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>

<pre><code class="language-swift">Double.maximumMagnitude(10.0, -25.0)
// -25.0
Double.maximumMagnitude(10.0, .nan)
// 10.0
Double.maximumMagnitude(.nan, -25.0)
// -25.0
Double.maximumMagnitude(.nan, .nan)
// nan</code></pre>

<p>The <code>maximumMagnitude</code> method implements the <code>maxNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has greater magnitude, or whichever is
  a number if the other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func maximumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-minimum__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-minimum__">static func minimum(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-minimum__"><div class="p">
    <p>Returns the lesser of the two given values.</p>

<p>This method returns the minimum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>minimum(x, y)</code> is <code>x</code> if <code>x &lt;= y</code>, <code>y</code> if <code>y &lt; x</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>

<pre><code class="language-swift">Double.minimum(10.0, -25.0)
// -25.0
Double.minimum(10.0, .nan)
// 10.0
Double.minimum(.nan, -25.0)
// -25.0
Double.minimum(.nan, .nan)
// nan</code></pre>

<p>The <code>minimum</code> method implements the <code>minNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> The minimum of <code>x</code> and <code>y</code>, or whichever is a number if the
  other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func minimum(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-minimummagnitude__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-minimummagnitude__">static func minimumMagnitude(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-minimummagnitude__"><div class="p">
    <p>Returns the value with lesser magnitude.</p>

<p>This method returns the value with lesser magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>minimumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &lt;= y.magnitude</code>, <code>y</code> if <code>y.magnitude &lt; x.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>

<pre><code class="language-swift">Double.minimumMagnitude(10.0, -25.0)
// 10.0
Double.minimumMagnitude(10.0, .nan)
// 10.0
Double.minimumMagnitude(.nan, -25.0)
// -25.0
Double.minimumMagnitude(.nan, .nan)
// nan</code></pre>

<p>The <code>minimumMagnitude</code> method implements the <code>minNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has lesser magnitude, or whichever is
  a number if the other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func minimumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>

<h3>Instance Methods</h3>
<div class="declaration inherited" id="func-star_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-star_rhs_">func *(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-star_rhs_"><div class="p">
    <p>Multiplies two values and produces their product, rounding to a
representable value.</p>

<p>The multiplication operator (<code>*</code>) calculates the product of its two
arguments. For example:</p>

<pre><code class="language-swift">let x = 7.5
let y = x * 2.25
// y == 16.875</code></pre>

<p>The <code>*</code> operator implements the multiplication operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to multiply.
  <strong>rhs:</strong> The second value to multiply.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func *(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-stareq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-stareq_rhs_">func *=(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-stareq_rhs_"><div class="p">
    <p>Multiplies two values and stores the result in the left-hand-side
variable, rounding to a representable value.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to multiply.
  <strong>rhs:</strong> The second value to multiply.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func *=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-pls_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-pls_rhs_">func +(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-pls_rhs_"><div class="p">
    <p>Adds two values and produces their sum, rounded to a
representable value.</p>

<p>The addition operator (<code>+</code>) calculates the sum of its two arguments. For
example:</p>

<pre><code class="language-swift">let x = 1.5
let y = x + 2.25
// y == 3.75</code></pre>

<p>The <code>+</code> operator implements the addition operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to add.
  <strong>rhs:</strong> The second value to add.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func +(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-plseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-plseq_rhs_">func +=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-plseq_rhs_"><div class="p">
    <p>Adds two values and stores the result in the left-hand-side variable,
rounded to a representable value.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The first value to add.
  <strong>rhs:</strong> The second value to add.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func +=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-slash_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-slash_rhs_">func /(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-slash_rhs_"><div class="p">
    <p>Returns the quotient of dividing the first value by the second, rounded
to a representable value.</p>

<p>The division operator (<code>/</code>) calculates the quotient of the division if
<code>rhs</code> is nonzero. If <code>rhs</code> is zero, the result of the division is
infinity, with the sign of the result matching the sign of <code>lhs</code>.</p>

<pre><code class="language-swift">let x = 16.875
let y = x / 2.25
// y == 7.5

let z = x / 0
// z.isInfinite == true</code></pre>

<p>The <code>/</code> operator implements the division operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE
754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to divide.
  <strong>rhs:</strong> The value to divide <code>lhs</code> by.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func /(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-slasheq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-slasheq_rhs_">func /=(<wbr>_:<wbr>rhs:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-slasheq_rhs_"><div class="p">
    <p>Divides the first value by the second and stores the quotient in the
left-hand-side variable, rounding to a representable value.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> The value to divide.
  <strong>rhs:</strong> The value to divide <code>lhs</code> by.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func /=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-lt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-lt_rhs_">func &lt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-lt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.</p>

<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-lteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-lteq_rhs_">func &lt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-lteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-eqeq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-eqeq_rhs_">func ==(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-eqeq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether two values are equal.</p>

<p>Equality is the inverse of inequality. For any values <code>a</code> and <code>b</code>,
<code>a == b</code> implies that <code>a != b</code> is <code>false</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ==(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Equatable/"><code>Equatable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-gt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-gt_rhs_">func &gt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-gt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-gteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-gteq_rhs_">func &gt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-gteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-mns_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-mns_">prefix func -(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-mns_"><div class="p">
    <p>Calculates the additive inverse of a value.</p>

<p>The unary minus operator (prefix <code>-</code>) calculates the negation of its
operand. The result is always exact.</p>

<pre><code class="language-swift">let x = 21.5
let y = -x
// y == -21.5</code></pre>

<p><strong><code>operand</code>:</strong>  The value to negate.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func -(operand: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/SignedNumeric/"><code>SignedNumeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-mns_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-mns_rhs_">func -(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-mns_rhs_"><div class="p">
    <p>Subtracts one value from another and produces their difference, rounded
to a representable value.</p>

<p>The subtraction operator (<code>-</code>) calculates the difference of its two
arguments. For example:</p>

<pre><code class="language-swift">let x = 7.5
let y = x - 2.25
// y == 5.25</code></pre>

<p>The <code>-</code> operator implements the subtraction operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A numeric value.
  <strong>rhs:</strong> The value to subtract from <code>lhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func -(lhs: Self, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-mnseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-mnseq_rhs_">func -=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func-mnseq_rhs_"><div class="p">
    <p>Subtracts the second value from the first and stores the difference in
the left-hand-side variable, rounding to a representable value.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A numeric value.
  <strong>rhs:</strong> The value to subtract from <code>lhs</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func -=(lhs: inout Self, rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-addproduct__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-addproduct__">mutating func addProduct(<wbr>_:<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-addproduct__"><div class="p">
    <p>Adds the product of the two given values to this value in place, computed
without intermediate rounding.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> One of the values to multiply before adding to this value.
  <strong>rhs:</strong> The other value to multiply.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func addProduct(_ lhs: Self, _ rhs: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-addingproduct__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-addingproduct__">func addingProduct(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-addingproduct__"><div class="p">
    <p>Returns the result of adding the product of the two given values to this
value, computed without intermediate rounding.</p>

<p>This method is equivalent to the C <code>fma</code> function and implements the
<code>fusedMultiplyAdd</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> One of the values to multiply before adding to this value.
  <strong>rhs:</strong> The other value to multiply.
<strong>Returns:</strong> The product of <code>lhs</code> and <code>rhs</code>, added to this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func addingProduct(_ lhs: Self, _ rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-advanced-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-advanced-by_">func advanced(<wbr>by:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-advanced-by_"><div class="p">
    <p>Returns a value that is offset the specified distance from this value.</p>

<p>Use the <code>advanced(by:)</code> method in generic code to offset a value by a
specified distance. If you&#39;re working directly with numeric values, use
the addition operator (<code>+</code>) instead of this method.</p>

<pre><code class="language-swift">func addOne&lt;T: Strideable&gt;(to x: T) -&gt; T
    where T.Stride : ExpressibleByIntegerLiteral
{
    return x.advanced(by: 1)
}

let x = addOne(to: 5)
// x == 6
let y = addOne(to: 3.5)
// y = 4.5</code></pre>

<p>If this type&#39;s <code>Stride</code> type conforms to <code>BinaryInteger</code>, then for a
value <code>x</code>, a distance <code>n</code>, and a value <code>y = x.advanced(by: n)</code>,
<code>x.distance(to: y) == n</code>. Using this method with types that have a
noninteger <code>Stride</code> may result in an approximation.</p>

<p><strong><code>n</code>:</strong>  The distance to advance this value.
<strong>Returns:</strong> A value that is offset from this value by <code>n</code>.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func advanced(by n: Self.Stride) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-distance-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-distance-to_">func distance(<wbr>to:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-distance-to_"><div class="p">
    <p>Returns the distance from this value to the given value, expressed as a 
stride.</p>

<p>If this type&#39;s <code>Stride</code> type conforms to <code>BinaryInteger</code>, then for two
values <code>x</code> and <code>y</code>, and a distance <code>n = x.distance(to: y)</code>,
<code>x.advanced(by: n) == y</code>. Using this method with types that have a
noninteger <code>Stride</code> may result in an approximation.</p>

<p><strong><code>other</code>:</strong>  The value to calculate the distance to.
<strong>Returns:</strong> The distance from this value to <code>other</code>.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance(to other: Self) -&gt; Self.Stride</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formremainder-dividingby_">mutating func formRemainder(<wbr>dividingBy:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-formremainder-dividingby_"><div class="p">
    <p>Replaces this value with the remainder of itself divided by the given
value.</p>

<p>For two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by
<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to
<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is
chosen to be even. Note that <code>q</code> is <em>not</em> <code>x / y</code> computed in
floating-point arithmetic, and that <code>q</code> may not be representable in any
available integer type.</p>

<p>The following example calculates the remainder of dividing 8.625 by 0.75:</p>

<pre><code class="language-swift">var x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.toNearestOrEven)
// q == 12.0
x.formRemainder(dividingBy: 0.75)
// x == -0.375

let x1 = 0.75 * q + x
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are finite numbers, the remainder is in the
closed range <code>-abs(other / 2)...abs(other / 2)</code>. The
<code>formRemainder(dividingBy:)</code> method is always exact.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formRemainder(dividingBy other: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formsquareroot">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formsquareroot">mutating func formSquareRoot()</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-formsquareroot"><div class="p">
    <p>Replaces this value with its square root, rounded to a representable
value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formSquareRoot()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formtruncatingremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formtruncatingremainder-dividingby_">mutating func formTruncatingRemainder(<wbr>dividingBy:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-formtruncatingremainder-dividingby_"><div class="p">
    <p>Replaces this value with the remainder of itself divided by the given
value using truncating division.</p>

<p>Performing truncating division with floating-point values results in a
truncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and
their truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies
<code>x == y * q + r</code>.</p>

<p>The following example calculates the truncating remainder of dividing
8.625 by 0.75:</p>

<pre><code class="language-swift">var x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.towardZero)
// q == 11.0
x.formTruncatingRemainder(dividingBy: 0.75)
// x == 0.375

let x1 = 0.75 * q + x
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are both finite numbers, the truncating
remainder has the same sign as this value and is strictly smaller in
magnitude than <code>other</code>. The <code>formTruncatingRemainder(dividingBy:)</code>
method is always exact.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formTruncatingRemainder(dividingBy other: Self)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-hash-into_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-hash-into_">func hash(<wbr>into:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-hash-into_"><div class="p">
    <p>Hashes the essential components of this value by feeding them into the
given hasher.</p>

<p>Implement this method to conform to the <code>Hashable</code> protocol. The
components used for hashing must be the same as the components compared
in your type&#39;s <code>==</code> operator implementation. Call <code>hasher.combine(_:)</code>
with each of these components.</p>

<p><strong>Important:</strong> Never call <code>finalize()</code> on <code>hasher</code>. Doing so may become a
  compile-time error in the future.</p>

<p><strong><code>hasher</code>:</strong>  The hasher to use when combining the components
  of this instance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func hash(into hasher: inout Hasher)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Hashable/"><code>Hashable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-isequal-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isequal-to_">func isEqual(<wbr>to:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-isequal-to_"><div class="p">
    <p>Returns a Boolean value indicating whether this instance is equal to the
given value.</p>

<p>This method serves as the basis for the equal-to operator (<code>==</code>) for
floating-point values. When comparing two values with this method, <code>-0</code>
is equal to <code>+0</code>. NaN is not equal to any value, including itself. For
example:</p>

<pre><code class="language-swift">let x = 15.0
x.isEqual(to: 15.0)
// true
x.isEqual(to: .nan)
// false
Double.nan.isEqual(to: .nan)
// false</code></pre>

<p>The <code>isEqual(to:)</code> method implements the equality predicate defined by
the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to compare with this value.
<strong>Returns:</strong> <code>true</code> if <code>other</code> has the same value as this instance;
  otherwise, <code>false</code>. If either this value or <code>other</code> is NaN, the result
  of this method is <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isEqual(to other: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-isless-than_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isless-than_">func isLess(<wbr>than:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-isless-than_"><div class="p">
    <p>Returns a Boolean value indicating whether this instance is less than the
given value.</p>

<p>This method serves as the basis for the less-than operator (<code>&lt;</code>) for
floating-point values. Some special cases apply:</p>

<ul><li>Because NaN compares not less than nor greater than any value, this
method returns <code>false</code> when called on NaN or when NaN is passed as
<code>other</code>.</li><li><code>-infinity</code> compares less than all values except for itself and NaN.</li><li><p>Every value except for NaN and <code>+infinity</code> compares less than
<code>+infinity</code>.</p><p>let x = 15.0
x.isLess(than: 20.0)
// true
x.isLess(than: .nan)
// false
Double.nan.isLess(than: x)
// false</p></li></ul>

<p>The <code>isLess(than:)</code> method implements the less-than predicate defined by
the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to compare with this value.
<strong>Returns:</strong> <code>true</code> if this value is less than <code>other</code>; otherwise, <code>false</code>.
  If either this value or <code>other</code> is NaN, the result of this method is
  <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isLess(than other: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-islessthanorequalto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-islessthanorequalto_">func isLessThanOrEqualTo(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-islessthanorequalto_"><div class="p">
    <p>Returns a Boolean value indicating whether this instance is less than or
equal to the given value.</p>

<p>This method serves as the basis for the less-than-or-equal-to operator
(<code>&lt;=</code>) for floating-point values. Some special cases apply:</p>

<ul><li>Because NaN is incomparable with any value, this method returns <code>false</code>
when called on NaN or when NaN is passed as <code>other</code>.</li><li><code>-infinity</code> compares less than or equal to all values except NaN.</li><li><p>Every value except NaN compares less than or equal to <code>+infinity</code>.</p><p>let x = 15.0
x.isLessThanOrEqualTo(20.0)
// true
x.isLessThanOrEqualTo(.nan)
// false
Double.nan.isLessThanOrEqualTo(x)
// false</p></li></ul>

<p>The <code>isLessThanOrEqualTo(_:)</code> method implements the less-than-or-equal
predicate defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to compare with this value.
<strong>Returns:</strong> <code>true</code> if <code>other</code> is greater than this value; otherwise,
  <code>false</code>. If either this value or <code>other</code> is NaN, the result of this
  method is <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isLessThanOrEqualTo(_ other: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-istotallyordered-beloworequalto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-istotallyordered-beloworequalto_">func isTotallyOrdered(<wbr>belowOrEqualTo:)</a>
        
<div class="comment collapse" id="comment-func-istotallyordered-beloworequalto_"><div class="p">
    <p>Returns a Boolean value indicating whether this instance should precede
or tie positions with the given value in an ascending sort.</p>

<p>This relation is a refinement of the less-than-or-equal-to operator
(<code>&lt;=</code>) that provides a total order on all values of the type, including
signed zeros and NaNs.</p>

<p>The following example uses <code>isTotallyOrdered(belowOrEqualTo:)</code> to sort an
array of floating-point values, including some that are NaN:</p>

<pre><code class="language-swift">var numbers = [2.5, 21.25, 3.0, .nan, -9.5]
numbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }
// numbers == [-9.5, 2.5, 3.0, 21.25, NaN]</code></pre>

<p>The <code>isTotallyOrdered(belowOrEqualTo:)</code> method implements the total order
relation as defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  A floating-point value to compare to this value.
<strong>Returns:</strong> <code>true</code> if this value is ordered below or the same as <code>other</code>
  in a total ordering of the floating-point type; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isTotallyOrdered(belowOrEqualTo other: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-negate">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-negate">mutating func negate()</a>
        
<div class="comment collapse" id="comment-func-negate"><div class="p">
    <p>Replaces this value with its additive inverse.</p>

<p>The result is always exact. This example uses the <code>negate()</code> method to
negate the value of the variable <code>x</code>:</p>

<pre><code class="language-swift">var x = 21.5
x.negate()
// x == -21.5</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func negate()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/SignedNumeric/"><code>SignedNumeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-remainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-remainder-dividingby_">func remainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func-remainder-dividingby_"><div class="p">
    <p>Returns the remainder of this value divided by the given value.</p>

<p>For two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by
<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to
<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is
chosen to be even. Note that <code>q</code> is <em>not</em> <code>x / y</code> computed in
floating-point arithmetic, and that <code>q</code> may not be representable in any
available integer type.</p>

<p>The following example calculates the remainder of dividing 8.625 by 0.75:</p>

<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.toNearestOrEven)
// q == 12.0
let r = x.remainder(dividingBy: 0.75)
// r == -0.375

let x1 = 0.75 * q + r
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are finite numbers, the remainder is in the
closed range <code>-abs(other / 2)...abs(other / 2)</code>. The
<code>remainder(dividingBy:)</code> method is always exact. This method implements
the remainder operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.
<strong>Returns:</strong> The remainder of this value divided by <code>other</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func remainder(dividingBy other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-round_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-round_">mutating func round(<wbr>_:)</a>
     <span class="required">Required</span>    
<div class="comment collapse" id="comment-func-round_"><div class="p">
    <p>Rounds the value to an integral value using the specified rounding rule.</p>

<p>The following example rounds a value using four different rounding rules:</p>

<pre><code class="language-swift">// Equivalent to the C &#39;round&#39; function:
var w = 6.5
w.round(.toNearestOrAwayFromZero)
// w == 7.0

// Equivalent to the C &#39;trunc&#39; function:
var x = 6.5
x.round(.towardZero)
// x == 6.0

// Equivalent to the C &#39;ceil&#39; function:
var y = 6.5
y.round(.up)
// y == 7.0

// Equivalent to the C &#39;floor&#39; function:
var z = 6.5
z.round(.down)
// z == 6.0</code></pre>

<p>For more information about the available rounding rules, see the
<code>FloatingPointRoundingRule</code> enumeration. To round a value using the
default &quot;schoolbook rounding&quot;, you can use the shorter <code>round()</code> method
instead.</p>

<pre><code class="language-swift">var w1 = 6.5
w1.round()
// w1 == 7.0</code></pre>

<p><strong><code>rule</code>:</strong>  The rounding rule to use.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func round(_ rule: FloatingPointRoundingRule)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-rounded_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-rounded_">func rounded(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-rounded_"><div class="p">
    <p>Returns this value rounded to an integral value using the specified
rounding rule.</p>

<p>The following example rounds a value using four different rounding rules:</p>

<pre><code class="language-swift">let x = 6.5

// Equivalent to the C &#39;round&#39; function:
print(x.rounded(.toNearestOrAwayFromZero))
// Prints &quot;7.0&quot;

// Equivalent to the C &#39;trunc&#39; function:
print(x.rounded(.towardZero))
// Prints &quot;6.0&quot;

// Equivalent to the C &#39;ceil&#39; function:
print(x.rounded(.up))
// Prints &quot;7.0&quot;

// Equivalent to the C &#39;floor&#39; function:
print(x.rounded(.down))
// Prints &quot;6.0&quot;</code></pre>

<p>For more information about the available rounding rules, see the
<code>FloatingPointRoundingRule</code> enumeration. To round a value using the
default &quot;schoolbook rounding&quot;, you can use the shorter <code>rounded()</code>
method instead.</p>

<pre><code class="language-swift">print(x.rounded())
// Prints &quot;7.0&quot;</code></pre>

<p><strong><code>rule</code>:</strong>  The rounding rule to use.
<strong>Returns:</strong> The integral value found by rounding using <code>rule</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func rounded(_ rule: FloatingPointRoundingRule) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-squareroot">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-squareroot">func squareRoot()</a>
        
<div class="comment collapse" id="comment-func-squareroot"><div class="p">
    <p>Returns the square root of the value, rounded to a representable value.</p>

<p>The following example declares a function that calculates the length of
the hypotenuse of a right triangle given its two perpendicular sides.</p>

<pre><code class="language-swift">func hypotenuse(_ a: Double, _ b: Double) -&gt; Double {
    return (a * a + b * b).squareRoot()
}

let (dx, dy) = (3.0, 4.0)
let distance = hypotenuse(dx, dy)
// distance == 5.0</code></pre>

<p><strong>Returns:</strong> The square root of the value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func squareRoot() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-truncatingremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-truncatingremainder-dividingby_">func truncatingRemainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func-truncatingremainder-dividingby_"><div class="p">
    <p>Returns the remainder of this value divided by the given value using
truncating division.</p>

<p>Performing truncating division with floating-point values results in a
truncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and
their truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies
<code>x == y * q + r</code>.</p>

<p>The following example calculates the truncating remainder of dividing
8.625 by 0.75:</p>

<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.towardZero)
// q == 11.0
let r = x.truncatingRemainder(dividingBy: 0.75)
// r == 0.375

let x1 = 0.75 * q + r
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are both finite numbers, the truncating
remainder has the same sign as this value and is strictly smaller in
magnitude than <code>other</code>. The <code>truncatingRemainder(dividingBy:)</code> method
is always exact.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.
<strong>Returns:</strong> The remainder of this value divided by <code>other</code> using
  truncating division.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func truncatingRemainder(dividingBy other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>


<h3>Default Implementations</h3>




<div class="declaration" id="-init-source_-source">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-source_-source">init&lt;Source&gt;(<wbr>_: Source)</a><div class="comment collapse" id="comment--init-source_-source"><div class="p">
    <p>Creates a new value, rounded to the closest possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;Source&gt;(_ value: Source)</code>

    </div></div>
</div>
<div class="declaration" id="-init-source_-source">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-source_-source">init&lt;Source&gt;(<wbr>_: Source)</a><div class="comment collapse" id="comment--init-source_-source"><div class="p">
    <p>Creates a new instance from the given value, rounded to the closest
possible representation.</p>

<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>

<p><strong><code>value</code>:</strong>  A floating-point value to be converted.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;Source&gt;(_ value: Source)</code>

    </div></div>
</div>
<div class="declaration inherited" id="-init-integerliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-integerliteral_">init(<wbr>integerLiteral:)</a><div class="comment collapse" id="comment--init-integerliteral_"><div class="p">
    <p>Creates an instance initialized to the specified integer value.</p>

<p>Do not call this initializer directly. Instead, initialize a variable or
constant using an integer literal. For example:</p>

<pre><code class="language-swift">let x = 23</code></pre>

<p>In this example, the assignment to the <code>x</code> constant calls this integer
literal initializer behind the scenes.</p>

<p><strong><code>value</code>:</strong>  The value to create.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(integerLiteral value: Self)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/ExpressibleByIntegerLiteral/"><code>ExpressibleByIntegerLiteral</code></a>
        </div></div>
</div>
<div class="declaration" id="-init-signof_magnitudeof_">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-signof_magnitudeof_">init(<wbr>signOf:<wbr>magnitudeOf:)</a><div class="comment collapse" id="comment--init-signof_magnitudeof_"><div class="p">
    <p>Creates a new floating-point value using the sign of one value and the
magnitude of another.</p>

<p>The following example uses this initializer to create a new <code>Double</code>
instance with the sign of <code>a</code> and the magnitude of <code>b</code>:</p>

<pre><code class="language-swift">let a = -21.5
let b = 305.15
let c = Double(signOf: a, magnitudeOf: b)
print(c)
// Prints &quot;-305.15&quot;</code></pre>

<p>This initializer implements the IEEE 754 <code>copysign</code> operation.</p>

<p><strong>Parameters:</strong>
  <strong>signOf:</strong> A value from which to use the sign. The result of the
    initializer has the same sign as <code>signOf</code>.
  <strong>magnitudeOf:</strong> A value from which to use the magnitude. The result of
    the initializer has the same magnitude as <code>magnitudeOf</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(signOf: Self, magnitudeOf: Self)</code>

    </div></div>
</div>
<div class="declaration" id="-init-source-exactly_-source">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-source-exactly_-source">init?&lt;Source&gt;(<wbr>exactly: Source)</a><div class="comment collapse" id="comment--init-source-exactly_-source"><div class="p">
    <p>Creates a new value, if the given integer can be represented exactly.</p>

<p>If the given integer cannot be represented exactly, the result is <code>nil</code>.</p>

<p><strong><code>value</code>:</strong>  The integer to convert to a floating-point value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?&lt;Source&gt;(exactly value: Source)</code>

    </div></div>
</div>
<div class="declaration" id="-init-source-exactly_-source">
<a class="toggle-link" data-toggle="collapse" href="#comment--init-source-exactly_-source">init?&lt;Source&gt;(<wbr>exactly: Source)</a><div class="comment collapse" id="comment--init-source-exactly_-source"><div class="p">
    <p>Creates a new instance from the given value, if it can be represented
exactly.</p>

<p>If the given floating-point value cannot be represented exactly, the
result is <code>nil</code>. A value that is NaN (&quot;not a number&quot;) cannot be
represented exactly if its payload cannot be encoded exactly.</p>

<p><strong><code>value</code>:</strong>  A floating-point value to be converted.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init?&lt;Source&gt;(exactly value: Source)</code>

    </div></div>
</div>

<div class="declaration" id="-static-var-radix_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment--static-var-radix_-int">static var radix: Int</a><div class="comment collapse" id="comment--static-var-radix_-int"><div class="p">
    <p>The radix, or base of exponentiation, for this floating-point type.</p>

<p>All binary floating-point types have a radix of 2. The magnitude of a
floating-point value <code>x</code> of type <code>F</code> can be calculated by using the
following formula, where <code>**</code> is exponentiation:</p>

<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">static var radix: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="-static-var-ulpofone_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment--static-var-ulpofone_-self">static var ulpOfOne: Self</a><div class="comment collapse" id="comment--static-var-ulpofone_-self"><div class="p">
    <p>The unit in the last place of 1.0.</p>

<p>The positive difference between 1.0 and the next greater representable
number. The <code>ulpOfOne</code> constant corresponds to the C macros
<code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, and others with a similar purpose.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static var ulpOfOne: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="-var-floatingpointclass_-floatingpointclassification">
<a class="toggle-link" data-toggle="collapse" href="#comment--var-floatingpointclass_-floatingpointclassification">var floatingPointClass: FloatingPointClassification</a><div class="comment collapse" id="comment--var-floatingpointclass_-floatingpointclassification"><div class="p">
    <p>The classification of this value.</p>

<p>A value&#39;s <code>floatingPointClass</code> property describes its &quot;class&quot; as
described by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var floatingPointClass: FloatingPointClassification { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="-var-nextdown_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment--var-nextdown_-self">var nextDown: Self</a><div class="comment collapse" id="comment--var-nextdown_-self"><div class="p">
    <p>The greatest representable value that compares less than this value.</p>

<p>For any finite value <code>x</code>, <code>x.nextDown</code> is less than <code>x</code>. For <code>nan</code> or
<code>-infinity</code>, <code>x.nextDown</code> is <code>x</code> itself. The following special cases
also apply:</p>

<ul><li>If <code>x</code> is <code>infinity</code>, then <code>x.nextDown</code> is <code>greatestFiniteMagnitude</code>.</li><li>If <code>x</code> is <code>leastNonzeroMagnitude</code>, then <code>x.nextDown</code> is <code>0.0</code>.</li><li>If <code>x</code> is zero, then <code>x.nextDown</code> is <code>-leastNonzeroMagnitude</code>.</li><li>If <code>x</code> is <code>-greatestFiniteMagnitude</code>, then <code>x.nextDown</code> is <code>-infinity</code>.</li></ul>

    <h4>Declaration</h4>    
    <code class="language-swift">var nextDown: Self { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>
        </div></div>
</div>


<div class="declaration inherited" id="func--excleq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--excleq_rhs_">func !=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--excleq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether two values are not equal.</p>

<p>Inequality is the inverse of equality. For any values <code>a</code> and <code>b</code>, <code>a != b</code>
implies that <code>a == b</code> is <code>false</code>.</p>

<p>This is the default implementation of the not-equal-to operator (<code>!=</code>)
for any type that conforms to <code>Equatable</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func !=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Equatable/"><code>Equatable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--pls_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--pls_">prefix func +(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--pls_"><div class="p">
    <p>Returns the given number unchanged.</p>

<p>You can use the unary plus operator (<code>+</code>) to provide symmetry in your
code for positive numbers when also using the unary minus operator.</p>

<pre><code class="language-swift">let x = -21
let y = +21
// x == -21
// y == 21</code></pre>

<p><strong>Returns:</strong> The given argument without any changes.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func +(x: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Numeric/"><code>Numeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--pls_-self-rhs_-self-stride">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--pls_-self-rhs_-self-stride">func +(<wbr>_:<wbr> Self, rhs: Self.Stride)</a>
        
<div class="comment collapse" id="comment-func--pls_-self-rhs_-self-stride"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func +(lhs: Self, rhs: Self.Stride) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--pls_-self-stride-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--pls_-self-stride-rhs_-self">func +(<wbr>_:<wbr> Self.Stride, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--pls_-self-stride-rhs_-self"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func +(lhs: Self.Stride, rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--plseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--plseq_rhs_">func +=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--plseq_rhs_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func +=(lhs: inout Self, rhs: Self.Stride)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--dotdotdot_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--dotdotdot_-self">prefix func ...(<wbr>_: Self)</a>
        
<div class="comment collapse" id="comment-func--dotdotdot_-self"><div class="p">
    <p>Returns a partial range up to, and including, its upper bound.</p>

<p>Use the prefix closed range operator (prefix <code>...</code>) to create a partial
range of any type that conforms to the <code>Comparable</code> protocol. This
example creates a <code>PartialRangeThrough&lt;Double&gt;</code> instance that includes
any value less than or equal to <code>5.0</code>.</p>

<pre><code class="language-swift">let throughFive = ...5.0

throughFive.contains(4.0)     // true
throughFive.contains(5.0)     // true
throughFive.contains(6.0)     // false</code></pre>

<p>You can use this type of partial range of a collection&#39;s indices to
represent the range from the start of the collection up to, and
including, the partial range&#39;s upper bound.</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60, 70]
print(numbers[...3])
// Prints &quot;[10, 20, 30, 40]&quot;</code></pre>

<p><strong><code>maximum</code>:</strong>  The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func ...(maximum: Self) -&gt; PartialRangeThrough&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--dotdotdot_maximum_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--dotdotdot_maximum_">func ...(<wbr>_:<wbr>maximum:)</a>
        
<div class="comment collapse" id="comment-func--dotdotdot_maximum_"><div class="p">
    <p>Returns a closed range that contains both of its bounds.</p>

<p>Use the closed range operator (<code>...</code>) to create a closed range of any type
that conforms to the <code>Comparable</code> protocol. This example creates a
<code>ClosedRange&lt;Character&gt;</code> from &quot;a&quot; up to, and including, &quot;z&quot;.</p>

<pre><code class="language-swift">let lowercase = &quot;a&quot;...&quot;z&quot;
print(lowercase.contains(&quot;z&quot;))
// Prints &quot;true&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>minimum:</strong> The lower bound for the range.
  <strong>maximum:</strong> The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ...(minimum: Self, maximum: Self) -&gt; ClosedRange&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--dotdotlt_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--dotdotlt_">prefix func ..&lt;(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--dotdotlt_"><div class="p">
    <p>Returns a partial range up to, but not including, its upper bound.</p>

<p>Use the prefix half-open range operator (prefix <code>..&lt;</code>) to create a
partial range of any type that conforms to the <code>Comparable</code> protocol.
This example creates a <code>PartialRangeUpTo&lt;Double&gt;</code> instance that includes
any value less than <code>5.0</code>.</p>

<pre><code class="language-swift">let upToFive = ..&lt;5.0

upToFive.contains(3.14)       // true
upToFive.contains(6.28)       // false
upToFive.contains(5.0)        // false</code></pre>

<p>You can use this type of partial range of a collection&#39;s indices to
represent the range from the start of the collection up to, but not
including, the partial range&#39;s upper bound.</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60, 70]
print(numbers[..&lt;3])
// Prints &quot;[10, 20, 30]&quot;</code></pre>

<p><strong><code>maximum</code>:</strong>  The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func ..&lt;(maximum: Self) -&gt; PartialRangeUpTo&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--dotdotlt_maximum_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--dotdotlt_maximum_">func ..&lt;(<wbr>_:<wbr>maximum:)</a>
        
<div class="comment collapse" id="comment-func--dotdotlt_maximum_"><div class="p">
    <p>Returns a half-open range that contains its lower bound but not its upper
bound.</p>

<p>Use the half-open range operator (<code>..&lt;</code>) to create a range of any type
that conforms to the <code>Comparable</code> protocol. This example creates a
<code>Range&lt;Double&gt;</code> from zero up to, but not including, 5.0.</p>

<pre><code class="language-swift">let lessThanFive = 0.0..&lt;5.0
print(lessThanFive.contains(3.14))  // Prints &quot;true&quot;
print(lessThanFive.contains(5.0))   // Prints &quot;false&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>minimum:</strong> The lower bound for the range.
  <strong>maximum:</strong> The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ..&lt;(minimum: Self, maximum: Self) -&gt; Range&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--lt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--lt_rhs_">func &lt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--lt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.</p>

<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--lt_y_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--lt_y_">func &lt;(<wbr>_:<wbr>y:)</a>
        
<div class="comment collapse" id="comment-func--lt_y_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;(x: Self, y: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--lteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--lteq_rhs_">func &lt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--lteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is less than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &lt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--eqeq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--eqeq_rhs_">func ==(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--eqeq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether two values are equal.</p>

<p>Equality is the inverse of inequality. For any values <code>a</code> and <code>b</code>,
<code>a == b</code> implies that <code>a != b</code> is <code>false</code>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ==(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--eqeq_y_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--eqeq_y_">func ==(<wbr>_:<wbr>y:)</a>
        
<div class="comment collapse" id="comment-func--eqeq_y_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func ==(x: Self, y: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--gt_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gt_rhs_">func &gt;(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--gt_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--gteq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--gteq_rhs_">func &gt;=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--gteq_rhs_"><div class="p">
    <p>Returns a Boolean value indicating whether the value of the first
argument is greater than or equal to that of the second argument.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> A value to compare.
  <strong>rhs:</strong> Another value to compare.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func &gt;=(lhs: Self, rhs: Self) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>,    <a href="../../protocol/Comparable/"><code>Comparable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--mns_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--mns_">prefix func -(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--mns_"><div class="p">
    <p>Returns the additive inverse of the specified value.</p>

<p>The negation operator (prefix <code>-</code>) returns the additive inverse of its
argument.</p>

<pre><code class="language-swift">let x = 21
let y = -x
// y == -21</code></pre>

<p>The resulting value must be representable in the same type as the
argument. In particular, negating a signed, fixed-width integer type&#39;s
minimum results in a value that cannot be represented.</p>

<pre><code class="language-swift">let z = -Int8.min
// Overflow error</code></pre>

<p><strong>Returns:</strong> The additive inverse of the argument.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">prefix func -(operand: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SignedNumeric/"><code>SignedNumeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--mns_-self-rhs_-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--mns_-self-rhs_-self">func -(<wbr>_:<wbr> Self, rhs: Self)</a>
        
<div class="comment collapse" id="comment-func--mns_-self-rhs_-self"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func -(lhs: Self, rhs: Self) -&gt; Self.Stride</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--mns_-self-rhs_-self-stride">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--mns_-self-rhs_-self-stride">func -(<wbr>_:<wbr> Self, rhs: Self.Stride)</a>
        
<div class="comment collapse" id="comment-func--mns_-self-rhs_-self-stride"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func -(lhs: Self, rhs: Self.Stride) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--mnseq_rhs_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--mnseq_rhs_">func -=(<wbr>_:<wbr>rhs:)</a>
        
<div class="comment collapse" id="comment-func--mnseq_rhs_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func -=(lhs: inout Self, rhs: Self.Stride)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--addingproduct__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--addingproduct__">func addingProduct(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--addingproduct__"><div class="p">
    <p>Returns the result of adding the product of the two given values to this
value, computed without intermediate rounding.</p>

<p>This method is equivalent to the C <code>fma</code> function and implements the
<code>fusedMultiplyAdd</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>lhs:</strong> One of the values to multiply before adding to this value.
  <strong>rhs:</strong> The other value to multiply.
<strong>Returns:</strong> The product of <code>lhs</code> and <code>rhs</code>, added to this value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func addingProduct(_ lhs: Self, _ rhs: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration" id="func--istotallyordered-beloworequalto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--istotallyordered-beloworequalto_">func isTotallyOrdered(<wbr>belowOrEqualTo:)</a>
        
<div class="comment collapse" id="comment-func--istotallyordered-beloworequalto_"><div class="p">
    <p>Returns a Boolean value indicating whether this instance should precede
or tie positions with the given value in an ascending sort.</p>

<p>This relation is a refinement of the less-than-or-equal-to operator
(<code>&lt;=</code>) that provides a total order on all values of the type, including
signed zeros and NaNs.</p>

<p>The following example uses <code>isTotallyOrdered(belowOrEqualTo:)</code> to sort an
array of floating-point values, including some that are NaN:</p>

<pre><code class="language-swift">var numbers = [2.5, 21.25, 3.0, .nan, -9.5]
numbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }
// numbers == [-9.5, 2.5, 3.0, 21.25, NaN]</code></pre>

<p>The <code>isTotallyOrdered(belowOrEqualTo:)</code> method implements the total order
relation as defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  A floating-point value to compare to this value.
<strong>Returns:</strong> <code>true</code> if this value is ordered below or the same as <code>other</code>
  in a total ordering of the floating-point type; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isTotallyOrdered(belowOrEqualTo other: Self) -&gt; Bool</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func--maximum__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--maximum__">static func maximum(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--maximum__"><div class="p">
    <p>Returns the greater of the two given values.</p>

<p>This method returns the maximum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>maximum(x, y)</code> is <code>x</code> if <code>x &gt; y</code>, <code>y</code> if <code>x &lt;= y</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>

<pre><code class="language-swift">Double.maximum(10.0, -25.0)
// 10.0
Double.maximum(10.0, .nan)
// 10.0
Double.maximum(.nan, -25.0)
// -25.0
Double.maximum(.nan, .nan)
// nan</code></pre>

<p>The <code>maximum</code> method implements the <code>maxNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> The greater of <code>x</code> and <code>y</code>, or whichever is a number if the
  other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func maximum(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--maximummagnitude__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--maximummagnitude__">static func maximumMagnitude(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--maximummagnitude__"><div class="p">
    <p>Returns the value with greater magnitude.</p>

<p>This method returns the value with greater magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>maximumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &gt; y.magnitude</code>, <code>y</code> if <code>x.magnitude &lt;= y.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>

<pre><code class="language-swift">Double.maximumMagnitude(10.0, -25.0)
// -25.0
Double.maximumMagnitude(10.0, .nan)
// 10.0
Double.maximumMagnitude(.nan, -25.0)
// -25.0
Double.maximumMagnitude(.nan, .nan)
// nan</code></pre>

<p>The <code>maximumMagnitude</code> method implements the <code>maxNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has greater magnitude, or whichever is
  a number if the other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func maximumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--minimum__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--minimum__">static func minimum(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--minimum__"><div class="p">
    <p>Returns the lesser of the two given values.</p>

<p>This method returns the minimum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>minimum(x, y)</code> is <code>x</code> if <code>x &lt;= y</code>, <code>y</code> if <code>y &lt; x</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>

<pre><code class="language-swift">Double.minimum(10.0, -25.0)
// -25.0
Double.minimum(10.0, .nan)
// 10.0
Double.minimum(.nan, -25.0)
// -25.0
Double.minimum(.nan, .nan)
// nan</code></pre>

<p>The <code>minimum</code> method implements the <code>minNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> The minimum of <code>x</code> and <code>y</code>, or whichever is a number if the
  other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func minimum(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--minimummagnitude__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--minimummagnitude__">static func minimumMagnitude(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--minimummagnitude__"><div class="p">
    <p>Returns the value with lesser magnitude.</p>

<p>This method returns the value with lesser magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>minimumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &lt;= y.magnitude</code>, <code>y</code> if <code>y.magnitude &lt; x.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>

<pre><code class="language-swift">Double.minimumMagnitude(10.0, -25.0)
// 10.0
Double.minimumMagnitude(10.0, .nan)
// 10.0
Double.minimumMagnitude(.nan, -25.0)
// -25.0
Double.minimumMagnitude(.nan, .nan)
// nan</code></pre>

<p>The <code>minimumMagnitude</code> method implements the <code>minNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong>Parameters:</strong>
  <strong>x:</strong> A floating-point value.
  <strong>y:</strong> Another floating-point value.
<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has lesser magnitude, or whichever is
  a number if the other is NaN.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func minimumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--negate">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--negate">mutating func negate()</a>
        
<div class="comment collapse" id="comment-func--negate"><div class="p">
    <p>Replaces this value with its additive inverse.</p>

<p>The following example uses the <code>negate()</code> method to negate the value of
an integer <code>x</code>:</p>

<pre><code class="language-swift">var x = 21
x.negate()
// x == -21</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func negate()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SignedNumeric/"><code>SignedNumeric</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--remainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--remainder-dividingby_">func remainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func--remainder-dividingby_"><div class="p">
    <p>Returns the remainder of this value divided by the given value.</p>

<p>For two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by
<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to
<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is
chosen to be even. Note that <code>q</code> is <em>not</em> <code>x / y</code> computed in
floating-point arithmetic, and that <code>q</code> may not be representable in any
available integer type.</p>

<p>The following example calculates the remainder of dividing 8.625 by 0.75:</p>

<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.toNearestOrEven)
// q == 12.0
let r = x.remainder(dividingBy: 0.75)
// r == -0.375

let x1 = 0.75 * q + r
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are finite numbers, the remainder is in the
closed range <code>-abs(other / 2)...abs(other / 2)</code>. The
<code>remainder(dividingBy:)</code> method is always exact. This method implements
the remainder operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.
<strong>Returns:</strong> The remainder of this value divided by <code>other</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func remainder(dividingBy other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--round">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--round">mutating func round()</a>
        
<div class="comment collapse" id="comment-func--round"><div class="p">
    <p>Rounds this value to an integral value using &quot;schoolbook rounding.&quot;</p>

<p>The <code>round()</code> method uses the <code>.toNearestOrAwayFromZero</code> rounding rule,
where a value halfway between two integral values is rounded to the one
with greater magnitude. The following example rounds several values
using this default rule:</p>

<pre><code class="language-swift">var x = 5.2
x.round()
// x == 5.0
var y = 5.5
y.round()
// y == 6.0
var z = -5.5
z.round()
// z == -6.0</code></pre>

<p>To specify an alternative rule for rounding, use the <code>round(_:)</code> method
instead.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func round()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--rounded">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--rounded">func rounded()</a>
        
<div class="comment collapse" id="comment-func--rounded"><div class="p">
    <p>Returns this value rounded to an integral value using &quot;schoolbook
rounding.&quot;</p>

<p>The <code>rounded()</code> method uses the <code>.toNearestOrAwayFromZero</code> rounding rule,
where a value halfway between two integral values is rounded to the one
with greater magnitude. The following example rounds several values
using this default rule:</p>

<pre><code class="language-swift">(5.2).rounded()
// 5.0
(5.5).rounded()
// 6.0
(-5.2).rounded()
// -5.0
(-5.5).rounded()
// -6.0</code></pre>

<p>To specify an alternative rule for rounding, use the <code>rounded(_:)</code> method
instead.</p>

<p><strong>Returns:</strong> The nearest integral value, or, if two integral values are
  equally close, the integral value with greater magnitude.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func rounded() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--rounded_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--rounded_">func rounded(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func--rounded_"><div class="p">
    <p>Returns this value rounded to an integral value using the specified
rounding rule.</p>

<p>The following example rounds a value using four different rounding rules:</p>

<pre><code class="language-swift">let x = 6.5

// Equivalent to the C &#39;round&#39; function:
print(x.rounded(.toNearestOrAwayFromZero))
// Prints &quot;7.0&quot;

// Equivalent to the C &#39;trunc&#39; function:
print(x.rounded(.towardZero))
// Prints &quot;6.0&quot;

// Equivalent to the C &#39;ceil&#39; function:
print(x.rounded(.up))
// Prints &quot;7.0&quot;

// Equivalent to the C &#39;floor&#39; function:
print(x.rounded(.down))
// Prints &quot;6.0&quot;</code></pre>

<p>For more information about the available rounding rules, see the
<code>FloatingPointRoundingRule</code> enumeration. To round a value using the
default &quot;schoolbook rounding&quot;, you can use the shorter <code>rounded()</code>
method instead.</p>

<pre><code class="language-swift">print(x.rounded())
// Prints &quot;7.0&quot;</code></pre>

<p><strong><code>rule</code>:</strong>  The rounding rule to use.
<strong>Returns:</strong> The integral value found by rounding using <code>rule</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func rounded(_ rule: FloatingPointRoundingRule) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--squareroot">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--squareroot">func squareRoot()</a>
        
<div class="comment collapse" id="comment-func--squareroot"><div class="p">
    <p>Returns the square root of the value, rounded to a representable value.</p>

<p>The following example declares a function that calculates the length of
the hypotenuse of a right triangle given its two perpendicular sides.</p>

<pre><code class="language-swift">func hypotenuse(_ a: Double, _ b: Double) -&gt; Double {
    return (a * a + b * b).squareRoot()
}

let (dx, dy) = (3.0, 4.0)
let distance = hypotenuse(dx, dy)
// distance == 5.0</code></pre>

<p><strong>Returns:</strong> The square root of the value.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func squareRoot() -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func--truncatingremainder-dividingby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func--truncatingremainder-dividingby_">func truncatingRemainder(<wbr>dividingBy:)</a>
        
<div class="comment collapse" id="comment-func--truncatingremainder-dividingby_"><div class="p">
    <p>Returns the remainder of this value divided by the given value using
truncating division.</p>

<p>Performing truncating division with floating-point values results in a
truncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and
their truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies
<code>x == y * q + r</code>.</p>

<p>The following example calculates the truncating remainder of dividing
8.625 by 0.75:</p>

<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.towardZero)
// q == 11.0
let r = x.truncatingRemainder(dividingBy: 0.75)
// r == 0.375

let x1 = 0.75 * q + r
// x1 == 8.625</code></pre>

<p>If this value and <code>other</code> are both finite numbers, the truncating
remainder has the same sign as this value and is strictly smaller in
magnitude than <code>other</code>. The <code>truncatingRemainder(dividingBy:)</code> method
is always exact.</p>

<p><strong><code>other</code>:</strong>  The value to use when dividing this value.
<strong>Returns:</strong> The remainder of this value divided by <code>other</code> using
  truncating division.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func truncatingRemainder(dividingBy other: Self) -&gt; Self</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/FloatingPoint/"><code>FloatingPoint</code></a>    
</div></div>
</div>







<h4>Where RawSignificand : FixedWidthInteger, RawSignificand.Magnitude : UnsignedInteger, RawSignificand.Stride : SignedInteger</h4>




<div class="declaration" id="func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-in_-closedrange-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-in_-closedrange-self">static func random(<wbr>in: ClosedRange&lt;Self&gt;)</a>
        
<div class="comment collapse" id="comment-func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-in_-closedrange-self"><div class="p">
    <p>Returns a random value within the specified range.</p>

<p>Use this method to generate a floating-point value within a specific
range. This example creates three new values in the range
<code>10.0...20.0</code>.</p>

<pre><code class="language-swift">for _ in 1...3 {
    print(Double.random(in: 10.0...20.0))
}
// Prints &quot;18.1900709259179&quot;
// Prints &quot;14.2286325689993&quot;
// Prints &quot;13.1485686260762&quot;</code></pre>

<p>The <code>random()</code> static method chooses a random value from a continuous
uniform distribution in <code>range</code>, and then converts that value to the
nearest representable value in this type. Depending on the size and span
of <code>range</code>, some concrete values may be represented more frequently than
others.</p>

<p>This method uses the default random generator, <code>Random.default</code>. The call
to <code>Double.random(in: 10.0...20.0)</code> above is equivalent to calling
<code>Double.random(in: 10.0...20.0, using: &amp;Random.default)</code>.</p>

<p><strong><code>range</code>:</strong>  The range in which to create a random value.
<strong>Returns:</strong> A random value within the bounds of <code>range</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func random(in range: ClosedRange&lt;Self&gt;) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-in_-range-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-in_-range-self">static func random(<wbr>in: Range&lt;Self&gt;)</a>
        
<div class="comment collapse" id="comment-func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-in_-range-self"><div class="p">
    <p>Returns a random value within the specified range.</p>

<p>Use this method to generate a floating-point value within a specific
range. This example creates three new values in the range
<code>10.0..&lt;20.0</code>.</p>

<pre><code class="language-swift">for _ in 1...3 {
    print(Double.random(in: 10.0..&lt;20.0))
}
// Prints &quot;18.1900709259179&quot;
// Prints &quot;14.2286325689993&quot;
// Prints &quot;13.1485686260762&quot;</code></pre>

<p>The <code>random()</code> static method chooses a random value from a continuous
uniform distribution in <code>range</code>, and then converts that value to the
nearest representable value in this type. Depending on the size and span
of <code>range</code>, some concrete values may be represented more frequently than
others.</p>

<p>This method uses the default random generator, <code>Random.default</code>. The call
to <code>Double.random(in: 10.0..&lt;20.0)</code> above is equivalent to calling
<code>Double.random(in: 10.0..&lt;20.0, using: &amp;Random.default)</code>.</p>

<p><strong><code>range</code>:</strong>  The range in which to create a random value.
  <code>range</code> must not be empty.
<strong>Returns:</strong> A random value within the bounds of <code>range</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func random(in range: Range&lt;Self&gt;) -&gt; Self</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-t-in_-closedrange-self-using_-inout-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-t-in_-closedrange-self-using_-inout-t">static func random&lt;T&gt;(<wbr>in:<wbr> ClosedRange&lt;Self&gt;, using: inout T)</a>
        
<div class="comment collapse" id="comment-func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-t-in_-closedrange-self-using_-inout-t"><div class="p">
    <p>Returns a random value within the specified range, using the given
generator as a source for randomness.</p>

<p>Use this method to generate a floating-point value within a specific
range when you are using a custom random number generator. This example
creates three new values in the range <code>10.0...20.0</code>.</p>

<pre><code class="language-swift">for _ in 1...3 {
    print(Double.random(in: 10.0...20.0, using: &amp;myGenerator))
}
// Prints &quot;18.1900709259179&quot;
// Prints &quot;14.2286325689993&quot;
// Prints &quot;13.1485686260762&quot;</code></pre>

<p>The <code>random(in:using:)</code> static method chooses a random value from a
continuous uniform distribution in <code>range</code>, and then converts that value
to the nearest representable value in this type. Depending on the size and
span of <code>range</code>, some concrete values may be represented more frequently
than others.</p>

<p><strong>Parameters:</strong>
  <strong>range:</strong> The range in which to create a random value.
  <strong>generator:</strong> The random number generator to use when creating the
    new random value.
<strong>Returns:</strong> A random value within the bounds of <code>range</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func random&lt;T&gt;(in range: ClosedRange&lt;Self&gt;, using generator: inout T) -&gt; Self where T : RandomNumberGenerator</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-t-in_-range-self-using_-inout-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-t-in_-range-self-using_-inout-t">static func random&lt;T&gt;(<wbr>in:<wbr> Range&lt;Self&gt;, using: inout T)</a>
        
<div class="comment collapse" id="comment-func-rawsignificand_-fixedwidthinteger-rawsignificand-magnitude_-unsignedinteger-rawsignificand-stride_-signedinteger-random-t-in_-range-self-using_-inout-t"><div class="p">
    <p>Returns a random value within the specified range, using the given
generator as a source for randomness.</p>

<p>Use this method to generate a floating-point value within a specific
range when you are using a custom random number generator. This example
creates three new values in the range <code>10.0..&lt;20.0</code>.</p>

<pre><code class="language-swift">for _ in 1...3 {
    print(Double.random(in: 10.0..&lt;20.0, using: &amp;myGenerator))
}
// Prints &quot;18.1900709259179&quot;
// Prints &quot;14.2286325689993&quot;
// Prints &quot;13.1485686260762&quot;</code></pre>

<p>The <code>random(in:using:)</code> static method chooses a random value from a
continuous uniform distribution in <code>range</code>, and then converts that value
to the nearest representable value in this type. Depending on the size and
span of <code>range</code>, some concrete values may be represented more frequently
than others.</p>

<p><strong>Parameters:</strong>
  <strong>range:</strong> The range in which to create a random value.
    <code>range</code> must not be empty.
  <strong>generator:</strong> The random number generator to use when creating the
    new random value.
<strong>Returns:</strong> A random value within the bounds of <code>range</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">static func random&lt;T&gt;(in range: Range&lt;Self&gt;, using generator: inout T) -&gt; Self where T : RandomNumberGenerator</code>
    
    
</div></div>
</div>





<h4>Where Stride : SignedInteger</h4>




<div class="declaration inherited" id="func-stride_-signedinteger-dotdotdot_maximum_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-stride_-signedinteger-dotdotdot_maximum_">func ...(<wbr>_:<wbr>maximum:)</a>
        
<div class="comment collapse" id="comment-func-stride_-signedinteger-dotdotdot_maximum_"><div class="p">
    <p>Returns a countable closed range that contains both of its bounds.</p>

<p>Use the closed range operator (<code>...</code>) to create a closed range of any type
that conforms to the <code>Strideable</code> protocol with an associated signed
integer <code>Stride</code> type, such as any of the standard library&#39;s integer
types. This example creates a <code>ClosedRange&lt;Int&gt;</code> from zero up to,
and including, nine.</p>

<pre><code class="language-swift">let singleDigits = 0...9
print(singleDigits.contains(9))
// Prints &quot;true&quot;</code></pre>

<p>You can use sequence or collection methods on the <code>singleDigits</code> range.</p>

<pre><code class="language-swift">print(singleDigits.count)
// Prints &quot;10&quot;
print(singleDigits.last)
// Prints &quot;9&quot;</code></pre>

<p><strong>Parameters:</strong>)`.
  <strong>minimum:</strong> The lower bound for the range.
  <strong>maximum:</strong> The upper bound for the range.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func ...(minimum: Self, maximum: Self) -&gt; ClosedRange&lt;Self&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Strideable/"><code>Strideable</code></a>    
</div></div>
</div>



